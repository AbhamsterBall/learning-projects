<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>mybatis</title>
    <link href="main.css" rel="stylesheet"/>
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
</head>
<body>
<div class="main-title">MYBATIS-1 BY HYH <a href="#" onclick="hideAll()" class="expand">代码全部收起</a></div>
    <div class="text"  style="border-radius: 0px 0px 20px 20px;">
<span style="color: #4472C4">
    1.这个网页多一个人看都是错的 /爱心<br>
    2.当一个人感觉无聊的时候，它就会感觉很无聊。<br>
    参考：文心一言 讯飞星火 chatGPT MYBATIS白皮书 gamma.app(bilibili)<br>
    <a href="https://www.tutorialspoint.com/mybatis/mybatis_annotations.htm">https://www.tutorialspoint.com/mybatis/mybatis_annotations.htm<br></a>
    <a href="https://blog.csdn.net/weixin_51725434/article/details/128396111">https://blog.csdn.net/weixin_51725434/article/details/128396111<br></a>
    <a href="https://howtodoinjava.com/log4j2/log4j2-properties-example/">https://howtodoinjava.com/log4j2/log4j2-properties-example/<br></a>
    spring transaction: <a href="https://www.digitalocean.com/community/tutorials/spring-transaction-management-jdbc-example">https://www.digitalocean.com/community/tutorials/spring-transaction-management-jdbc-example<br></a>
    <a href="https://blog.csdn.net/xcnaabb/article/details/130102571">https://blog.csdn.net/xcnaabb/article/details/130102571<br></a>
    mapper SQL process: <a href="https://blog.csdn.net/weixin_44451022/article/details/128641020">https://blog.csdn.net/weixin_44451022/article/details/128641020<br></a>
    source Code: <a href="https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java">https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java<br></a>
    德鲁伊：<a href="https://blog.csdn.net/qq_15204179/article/details/83050229">https://blog.csdn.net/qq_15204179/article/details/83050229<br></a>
</a>
</span> <br/>
<h3>数据库操作：mybatis中实现数据库增删查改的mapper一共有三种方式</h3><br/>
1.通过xml方式<br/>
这是最常见的方式，其中 Mapper 接口的 SQL 映射规则被定义在 XML 文件中，这个 XML 文件通常以 ".xml" 为后缀名。您可以通过 `&lt;mapper&gt;` 元素的 `resource` 属性来引入 XML Mapper 文件。<br/>
2.通过注解的方式<br/>
可以使用注解方式来定义 SQL 映射规则。在这种方式中，您在 Mapper 接口的方法上使用注解来指定 SQL 查询。这种方式通常比较简洁，但不如 XML 配置文件灵活。<br/>
3.通过实现接口结合xml的方式<br/>
该接口，用于定义与数据库交互的 SQL 方法。这些接口通常没有实现类，但是 MyBatis 在运行时会生成代理类来实现这些接口的方法。Mapper 接口的方法名和参数与 SQL 查询的配置相关联，这种方式称为 "Mapper 接口方式"。<br/>
        <br/>
        <h4>1. mybatis增删查改:通过xml方式</h4><br>
        Mapper.xml文件
    </div>
    <textarea class="code" id="auto-growable-textarea">
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.hyh.dao.TestDao">
    <!--查询-->
    <resultMap type="com.hyh.pojo.User" id="userSet">
        <id column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="sex" property="sex"/>
        <result column="age" property="age"/>
    </resultMap>
    <!--通过id查询-->
    <select id="selectUser" parameterType = "int" resultType="com.hyh.pojo.User">
        select * from mybatis_user where id = #{id}
    </select>
    <!--查询所有-->
    <select id = "getAll" resultMap = "userSet">
        SELECT * FROM mybatis_user
    </select>

    <!--插入-->
    <insert id="insert"> <!--可能是databaseId没有检测到-->
        <selectKey keyProperty="id" resultType="int" order="BEFORE">
            <if test="_databaseId == 'oracle'"> <!--可以针对不同的数据库做出不同响应-->
                select mybatis_seq.nextVal from dual
            </if>
        </selectKey>
        insert into mybatis_user values (#{id}, #{name}, #{sex}, #{age})
    </insert>

    <!--更新-->
    <update id="update">
        update mybatis_user
        <set>
            <if test="name != null">name=#{name},</if>
            <if test="sex != null">sex=#{sex},</if>
            <if test="age != null">age=#{age}</if>
        </set>
        where id=#{id}
    </update>

    <!--删除-->
    <delete id="delete"
            parameterType="com.hyh.pojo.User"
            flushCache="true"
            statementType="PREPARED"
            timeout="20">
    <!--以上参数均为可选参数，可以不写，参数为：id, 返回类型，是否清空缓存，prepared statement/static statement, 超时时限-->
        delete from mybatis_user where id = #{id}
    </delete>

</mapper>
    </textarea>
    <div class="text">mybatis配置文件<br>
    <br><h4>property文件设置</h4><br>
    <pre class="preText">
· 利用resource属性添加文件名
· 利用property name="" value=''子项，添加属性</pre>
    </div>
    <textarea class="code">
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <properties resource="db.properties">
        <property name="username" value="dev_user"/>
        <property name="password" value="F2Fa3!33TYyg"/>
    </properties>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com\hyh\mapper\TestMapper.xml"/> <!--根据不同的mapper有不同的编写和结构-->
    </mappers>
</configuration>
    </textarea>
    <div class="text">测试文件</div>
    <textarea class="code">
    public SqlSessionFactory giveFactory() { //启用mybatis配置文件
        SqlSessionFactory factory = null;
        try { // 2.1.2 Building SqlSessionFactory from XML
            InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml");
            factory = new SqlSessionFactoryBuilder().build(inputStream);
            inputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        factory.getConfiguration().setDatabaseId("oracle"); //set database type
        System.out.println(factory.getConfiguration().getDatabaseId());

        return factory;
    }

    public void XMLSelect(SqlSession sqlSession) { //查找
        System.out.println("XMLSelect");
        List<User> users = sqlSession.selectList("com.hyh.dao.TestDao.getAll");
        User user = sqlSession.selectOne("com.hyh.dao.TestDao.selectUser", 1);

        System.out.println(users);
        System.out.println(user);
    }

    @Test
    public void buildForXML() {
        System.out.println("============Test buildForXML==============");

        SqlSessionFactory factory = giveFactory();

        try (SqlSession sqlSession = factory.openSession()) {
            factory.getConfiguration().setDatabaseId("oracle"); //set database type
            System.out.println(factory.getConfiguration().getDatabaseId());

            XMLSelect(sqlSession);

            User userInserted = new User(2, "WWW", "W", 10); //添加
            int bo = sqlSession.insert("com.hyh.dao.TestDao.insert", userInserted);

            User userUpdated = new User(3, "xxxpoipioip", "op", 9); //修改
            int boo = sqlSession.update("com.hyh.dao.TestDao.update", userUpdated);

            int fii = sqlSession.delete("com.hyh.dao.TestDao.delete", 1); //删除
            User userDeleted = new User(3, "WWW", "W", 10);
            int fiii = sqlSession.delete("com.hyh.dao.TestDao.deleteObject", userDeleted);

            System.out.println("others");
            System.out.println(bo);
            System.out.println(boo);
            System.out.println(fii);
            System.out.println(fiii);

            sqlSession.commit(); //!!!!!!提交
        }
    </textarea>
    <div class="text">
        <h4>2. mybatis增删查改:通过注解方式</h4><br/>
        使用包：<br>
        因为之前已经载入了很多其它的包，所以没有采用maven，包的搜索网址为：<a href="https://search.maven.org/search">https://search.maven.org/search</a><br>
<!--        spring-dao<br>-->
        spring-orm: 用于将对象模型与关系数据库之间的数据进行映射和转换，解决它们之间数据表示不匹配的问题，具有sql语言对象化，自动化数据访问，多数据库支持，简化代码提高效率的特点<br>
        mybatis-spring<br>
        mybatis<br>
        ojdbc8<br>
        <br>
        annotation Interface
    </div>
    <textarea class="code">
@Mapper
public interface TestMapperAnnotation {

    @Select("select * from mybatis_user where id = #{id}")
    User getUserById(int id);

    @Delete("delete from mybatis_user where id = #{id}")
    int deleteUserById(int id);

    @Insert("insert into mybatis_user values (#{id}, #{name}, #{sex}, #{age})") //多个参数要用@Param来区分
    int insertUserByObject(@Param("id") int id, @Param("name") String name, @Param("sex") String sex, @Param("age") int age);

    @Update("update mybatis_user set name=#{name}, sex=#{sex}, age=#{age} where id=#{id}")
    int updateByObject(@Param("id") int id, @Param("name") String name, @Param("sex") String sex, @Param("age") int age);
}
    </textarea>
    <div class="text">测试</div>
    <textarea class="code">
    @Test
    public void buildForAnnotation() {
        System.out.println("============Test buildForAnnotation=============");
        SqlSessionFactory factory = giveFactory();

        try (SqlSession session = factory.openSession()) {
            session.getConfiguration().addMapper(TestMapperAnnotation.class);

            TestMapperAnnotation mapper = session.getMapper(TestMapperAnnotation.class);
            System.out.println(mapper.getUserById(51));
            System.out.println(mapper.deleteUserById(51));
            System.out.println(mapper.insertUserByObject(1000, "asdf", "ew", 0));
            System.out.println(mapper.updateByObject(1000, "mmm", "ooo", 999));

            session.commit();
        }
    }
    </textarea>
    <div class="text">
        <h4>3. mybatis增删查改：通过接口结合xml文件的方式</h4><br>
        - mapper接口的全类名和映射文件的命名空间(namespace)保持一致 <br>
        - mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 <br>
        <br>
        中途遇到的问题：out文件夹的内容没有跟着更新需要手动复制进去/out文件夹没有.class文件，删除out重新生成 ---编译器IDEA<br>
        没有设置数据库名称(测试方法效率不高)<br><br>
        接口文件
    </div>
    <textarea class="code">
import com.hyh.pojo.User;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface TestMapperInterface {
    User selectUser(@Param("id") int id); //一接口方式实现的哪怕只有一个变量也要声明@Param
    List<User> getAll();
    boolean insert(@Param("id") int id, @Param("name") String name, @Param("sex") String sex, @Param("age") int age);
    boolean update(@Param("id") int id, @Param("name") String name, @Param("sex") String sex, @Param("age") int age);
    boolean delete(@Param("id") int id);
}
    </textarea>
<div class="text">mapper.xml文件与上一个mapper的差别</div>
<textarea class="code">
<mapper namespace="com.hyh.dao.TestMapperInterface">
</textarea>
<div class="text">输出文件</div>
<textarea class="code">
    @Test
    public void testForInterfacePlusXML() {
        System.out.println("============Test testForInterfacePlusXML=============");

        SqlSessionFactory factory = giveFactory();

        try (SqlSession session = factory.openSession()) {
            factory.getConfiguration().setDatabaseId("oracle"); //set database type
            System.out.println(factory.getConfiguration().getDatabaseId());
            //在xml里面添加了接口

            TestMapperInterface tmi = session.getMapper(TestMapperInterface.class);
            System.out.println("" +
            tmi.delete(51) + " " +
            tmi.update(45, "asdf", "wee", 90) + " " +
            tmi.insert(23, "sd", "sd", 88) + " " +
                    tmi.getAll() + " \n" +
                    tmi.selectUser(45)
            ); //这里查找的数据想要改变中途需要commit

            session.commit();

        }
    }
</textarea>
    <div class="text">
        <br><h3>对mybatis-config.XML文件的解释之TransactionManager</h3><br>
        白皮书翻译（CHATGPT + HYH）P24
<pre>
事务管理器
MyBatis包含两种事务管理器类型（即type="[JDBC|MANAGED]"）：

·JDBC - 这个配置简单地直接使用JDBC的提交（commit）和回滚（rollback）功能。它依赖于从dataSource获取的连接来管理事务的范围。
·MANAGED - 这个配置几乎什么都不做。它不会提交或回滚连接。相反，它会让容器管理事务的完整生命周期（例如，在JEE应用服务器上的上下文）。默认情况下，它会关闭连接。但是，有些容器不希望这样做，因此如果您需要阻止它关闭连接，请将"closeConnection"属性设置为false。例如：

        JEE应用服务器上是JNDI(Java Naming and Directory Interface）上下文(context))，通俗地理解，Spring Web应用程序是部署在JEE应用服务器上的。

【注意】如果您计划在Spring中使用MyBatis，就不需要配置任何TransactionManager，因为Spring模块会设置自己的TransactionManager，覆盖任何之前设置的配置。

·这两种TransactionManager类型都不需要任何属性配置。然而，它们都是类型别名（Type Aliases）。换句话说，您可以使用自己的完全限定类名或类型别名来引用您自己实现的TransactionFactory接口。
</pre>
        <br><h4>TransactionFactory接口</h4><br>
        source Code: <a href="https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java">
        https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java
        </a>
<pre class="preText">
    > 如果设置失败，检查可能是mybatis-config.xml路径问题，可能迁移了项目但是没有修改参数，可以输出文件流查看

    + 以下为自定义接口实现：
    - mybatis-config.xml文件
</pre>
    </div>
    <textarea class="code">
            <transactionManager type="com.hyh.transaction.impl.TransactionFactoryImpl">
                <property name="autoCommit" value="false"/>
            </transactionManager>
    </textarea>
<div class="text">
<pre class="preText">
    - TransactionFactory接口实现
</pre>
</div>
<textarea class="code">
import org.apache.ibatis.session.TransactionIsolationLevel;
import org.apache.ibatis.transaction.Transaction;
import org.apache.ibatis.transaction.TransactionFactory;
import javax.sql.DataSource;
import java.sql.Connection;
import java.util.Properties;

public class TransactionFactoryImpl implements TransactionFactory {

    public boolean autoCommit;

    public boolean isAutoCommit() {
        return autoCommit;
    }

    public void setAutoCommit(boolean autoCommit) {
        this.autoCommit = autoCommit;
    }

    @Override
    public void setProperties(Properties props) {
        TransactionFactory.super.setProperties(props); //当前版本3.5.8, 3.5.2之后变为默认方法
    }

    @Override
    public Transaction newTransaction(Connection connection) {
        return new TransactionImpl(connection, autoCommit);
    }

    @Override
    public Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel transactionIsolationLevel, boolean b) {
        return new TransactionImpl(dataSource, autoCommit);
    }
}</textarea>
<div class="text">- Transaction接口实现</div>
<textarea class="code">
import com.hyh.dbUtil.DBUtils;
import org.apache.ibatis.transaction.Transaction;
import org.mybatis.logging.Logger;
import org.mybatis.logging.LoggerFactory;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import org.mybatis.spring.transaction.SpringManagedTransaction;

/**
 * 参考：org.mybatis.spring.transaction.SpringManagedTransaction
 */
public class TransactionImpl implements Transaction {

    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionImpl.class); //通过mybatis获取日志
    private DataSource dataSource;

    private Connection connection;
    public Boolean autoCommit; //connection.setAutoCommit  包装类才可以设置为空(默认为null)

    private int commitCount = 0;
    private int rollbackCount = 0;

    public TransactionImpl(Connection connection, boolean autoCommit) {
        this.connection = connection;
        this.autoCommit = autoCommit;
        LOGGER.debug(() -> {
            return "initialize HAMSTER Connection through connection AUTOCOMMIT " + this.autoCommit;
        });
    }

    public TransactionImpl(DataSource dataSource, boolean autoCommit) {
        this.dataSource = dataSource;
        this.autoCommit = autoCommit;
        LOGGER.debug(() -> {
            return "initialize HAMSTER Connection through datasource AUTOCOMMIT " + this.autoCommit;
        });
    }

    @Override
    public Connection getConnection() throws SQLException {

        if (this.connection == null) {
            this.openConnection();
        }

        return this.connection;
    }

    @Override
    public void commit() throws SQLException {
        if (this.connection != null &&  !this.autoCommit) {
            LOGGER.debug(() -> {
                return ++commitCount + "Committing HAMSTER Connection [" + this.connection + "]";
            });
            this.connection.commit();
        }
    }

    @Override
    public void rollback() throws SQLException {
        if (this.connection != null && !this.autoCommit) {
            LOGGER.debug(() -> {
                return ++rollbackCount + "Rolling back HAMSTER Connection [" + this.connection + "]";
            });
            this.connection.rollback();
        }
    }

    @Override
    public void close() throws SQLException {
        LOGGER.debug(() -> {
            return "HAMSTER Connection [" + this.connection + "] is closing";
        });
        this.connection.close();
    }

    @Override
    public Integer getTimeout() throws SQLException {
        LOGGER.debug(() -> {
            return "HAMSTER Connection [" + this.connection + "] is checking timeout";
        });
        return this.connection.getNetworkTimeout();
    }

    /**
     * Sets this connection's auto-commit mode to the given state.
     * If a connection is in auto-commit mode, then all its SQL statements will be executed and committed as individual
     * transactions. Otherwise, its SQL statements are grouped into transactions that are terminated by a call to either
     * the method commit or the method rollback. By default, new connections are in auto-commit mode.
     * 大概是说：自动提交为真，那么就单个sql每次都提交，自动提交为假，那么就手动提交，并将本次提交前的所有sql称为一个事务，这个事务会被提交方法或者回滚方法终止。
     * @throws SQLException
     */
    private void openConnection() {
        try {
            this.connection = dataSource != null ? dataSource.getConnection() : new DBUtils().getConnection();
            this.autoCommit = this.autoCommit == null? this.connection.getAutoCommit() : this.autoCommit;
            this.connection.setAutoCommit(this.autoCommit); // 设置/传入值
        } catch (SQLException e) {
            e.printStackTrace();
        }

        LOGGER.debug(() -> {
            return "HAMSTER Connection [" + this.connection + "] will be managed by Hamster";
        });
    }
}
</textarea>
<div class="text">DBUtil类</div>
<textarea class="code">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DBUtils {

    private String driver = "oracle.jdbc.driver.OracleDriver";
    private String url = "jdbc:oracle:thin:@localhost:1521:orcl";
    private String username = "hyh";
    private String password = "123456";

    public Connection getConnection() {
        System.out.println("get Connection");

        Connection conn = null;
        try {
            Class.forName(driver);
            conn = DriverManager.getConnection(url, username, password);
        } catch (ClassNotFoundException | SQLException e) {
            e.printStackTrace();
        }

        return conn;
    }

}
</textarea>
<div class="text">- 测试</div>
<textarea class="code">
    @Test
    public void testTransaction() {
        System.out.println("====================test testTransaction===============");

        // 获取 MyBatis SqlSessionFactory（假设你已经初始化了它）
        SqlSessionFactory factory = giveFactory(); //!!!set Oracle Factory in this method

        LogFactory.useStdOutLogging(); //开启日志打印到控制台

        // 创建一个 SqlSession
        try (SqlSession sqlSession = factory.openSession()) {
            // 获取你的 Mapper
            TestMapperInterface yourMapper = sqlSession.getMapper(TestMapperInterface.class);

            // 开始事务
            sqlSession.getConnection().setAutoCommit(false);

            try {
                // 执行数据库操作，例如插入或更新数据
                yourMapper.insert(5000, "sss", "sdf", 80); // 替换成你的实际操作

                // 手动提交事务
                sqlSession.getConnection().commit();

                // 如果一切顺利，事务将被提交
            } catch (Exception e) {
                // 如果发生异常，回滚事务
                sqlSession.getConnection().rollback();

                // 处理异常，例如记录错误信息或抛出异常
                e.printStackTrace();
            }
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        }
    }
</textarea>
<div class="text">- 输出</div>
<textarea class="code">
oracle
Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
initialize HAMSTER Connection through datasource AUTOCOMMIT false
HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] will be managed by Hamster
HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is checking timeout
DEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual
DEBUG [main] - ==> Parameters:
DEBUG [main] - <==      Total: 1
HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is checking timeout
DEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)
DEBUG [main] - ==> Parameters: 398(Integer), sss(String), sdf(String), 80(Integer)
DEBUG [main] - <==    Updates: 1
1Rolling back HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67]
HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is closing

Process finished with exit code 0</textarea>
    <div class="text">
<pre class="preText" id="dataSource">
    可以得出sql事务的加载顺序为：
</pre>
        <br><h5>getConnection ---> check timeout ---> roll back / commit ---> close</h5><br>
<pre>
    XML 中配置的任何属性都会在实例化后传递给 setProperties() 方法。你的实现还需要创建一个 Transaction 实现，这也是一个非常简单的接口：getConnection() commit() rollback() close() getTimeout() + 上面有实现
    使用上面两种接口，你可以完全自定义mybatis处理事务的方式。
</pre>
        <br><h3>对mybatis-config.XML文件的解释之dataSource</h3><br>
<pre>
    dataSource 元素配置了使用标准 JDBC DataSource 接口的 JDBC 连接对象的源头。
    • 大多数 MyBatis 应用程序将配置一个如示例中的 dataSource。然而，这不是必需的。请注意，如果要支持延迟加载，则必须配置dataSource。
    内置了三种 dataSource 类型（即 type="[UNPOOLED|POOLED|JNDI]"）：

    （总结部分）
    UNPOOLED: 每次请求时都会打开和关闭连接，适用于不需要高可用连接（随用随连）的简单应用程序以及对性能要求不高的数据库。
        - UNPOOLED DataSource 具有以下属性：driver[class of JDBC driver] url username password
            • defaultTransactionIsolationLevel – 连接的默认事务隔离级别。
                # NONE 数据库默认隔离级别
                # READ_UNCOMMITED 可以读取未提交数据的更改，可能导致脏读/不可重复读/幻读。
                # READ_COMMITTED 只能读取已提交数据的更改，可能不可重复读/幻读。
                # REPEATABLE_READ 在同一事务中多次读取相同数据时，数据保持一致，可能幻读。
                # SERIALIZABLE 事务会锁定访问的数据，什么都不可能发生，但是会导致性能下降，并发受到限制。
                    - 脏读：主要是因为没有提交。
                    - 不可重复读：行内容对不上。不可重复读发生在一个事务在多次读取同一行数据时，得到了不同的结果。这是因为在事务执行期间，另一个事务修改了同一行数据。
                    - 幻读：行数量对不上。幻读发生在一个事务在同一个查询中多次执行时，发现了不同数量的行。这是因为在事务执行期间，另一个事务插入或删除了符合查询条件的行。
            • defaultNetworkTimeout – 默认等待数据库操作完成的时间（以毫秒为单位）。
            * 您还可以将属性传递给数据库驱动程序。要做到这一点，请使用 driver. 前缀，例如：
                # driver.encoding=UTF8
                这将通过 DriverManager.getConnection(url, driverProperties) 方法将属性 encoding 的值设置为 UTF8，传递给您的数据库驱动程序。

    POOLED - 此实现的 DataSource 使用连接池来避免创建新的 Connection 实例所需的初始连接和身份验证时间。这是用于并发Web应用程序以实现最快响应的常见方法。
        属性：
        # poolMaximumActiveConnections - 此属性表示在任何给定时间可以存在的活动（即正在使用的）连接数。默认值：10
        # poolMaximumIdleConnections - 可以在任何给定时间存在的空闲连接数。
        # poolMaximumCheckoutTime - 这是在被强制结束之前，连接可以自行登出的最大时间。默认值：20000毫秒（即20秒）
        # poolTimeToWait - 这是一个低级别设置，设置后，如果获得连接的时间过长，连接池才有机会打印日志状态并进行重试。（以免配置不正确导致启动失败却无报错无重试）。默认值：20000毫秒（即20秒）
        # poolMaximumLocalBadConnectionTolerance - 这是有关线程获得坏连接的容忍度的低级别设置。如果线程获得了坏连接，它仍然可以有另一次尝试获取另一个有效连接的机会。但是，重试次数不应超过 poolMaximumIdleConnections 和 poolMaximumLocalBadConnectionTolerance 的总和。默认值：3（自3.4.5版本以来）
        # poolPingQuery - Ping查询用于验证连接是否正常工作并准备接受请求。默认值为 "NO PING QUERY SET"，这将使大多数数据库驱动不正常工作的时候显示合理的错误消息，所以非必要不要更改。
        # poolPingEnabled - 这启用或禁用ping查询。如果启用，您还必须将 poolPingQuery 的值设置为有效的SQL语句（最好是执行快速的）。默认值：false。
        # poolPingConnectionsNotUsedFor - 这配置了池将使用 poolPingQuery 的频率。可以与数据库连接的最大超时时间相同，以避免不必要的ping。默认值：0（即每次都会ping所有连接 - 但前提是 poolPingEnabled 为true）。

    JNDI - 此 DataSource 实现适用于容器，如EJB或应用程序服务器，它们可以在JNDI上下文中配置DataSource并放置对它的引用，用于告诉 MyBatis 使用 JNDI 来查找和获取数据源。此DataSource配置仅需要两个属性：
        # initial_context - 用于从 InitialContext 里查找上下文([Context])（即 initialContext.lookup(initial_context)）。此属性是可选的，如果省略，则将直接从 InitialContext 里直接查找 data_source 属性。
        # data_source - 数据源实例的引用所在的上下文路径。它将针对由 initial_context 找到的上下文[Context]进行查找，如果没有提供 initial_context 属性，则将直接从 InitialContext 里查找。
        * 与其他DataSource配置类似，可以通过在属性前缀 env. 来将属性直接发送到 InitialContext，例如：
            # env.encoding=UTF8
            这将把属性 encoding 的值作为 UTF8 直接发送到 InitialContext 构造函数。

    您可以通过实现 org.apache.ibatis.datasource.DataSourceFactory 接口来插入任何第三方DataSource。
</pre>
<pre class="preText">
    添加包：c3p0-0.9.5.5.jar mchange-commons-java-0.2.20.jar

    自定义接口 dataSourceFactoryImpl/DataSourceFactoryImpl
</pre>
    </div>
<textarea class="code">
import com.mchange.v2.c3p0.*;
import org.apache.ibatis.datasource.DataSourceFactory;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.SystemMetaObject;

import javax.sql.DataSource;
import java.util.Properties;

public class DataSourceFactoryImpl implements DataSourceFactory {

    private DataSource dataSource;

    public DataSourceFactoryImpl() {
        this.dataSource = new ComboPooledDataSource(); //只有它有driver, url, user, pass属性
    }

    // 参考：https://github.com/fuzhengwei/CodeGuide/blob/e9ff44b894ba2033bee782573b3f0fb33ad1f097/docs/md/spring/develop-mybatis/2022-05-03-%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E6%8A%8A%E5%8F%8D%E5%B0%84%E7%94%A8%E5%88%B0%E5%87%BA%E7%A5%9E%E5%85%A5%E5%8C%96.md?plain=1#L465
    @Override
    public void setProperties(Properties props) { // 通过 反射 的方式控制数据源的属性
        System.out.println("setting");
        MetaObject metaObject = SystemMetaObject.forObject(dataSource);

        if (metaObject.hasSetter("dmds")) {
            DriverManagerDataSource dmds = (DriverManagerDataSource) metaObject.getValue("dmds"); // 上一层为dmds
            MetaObject metaObjectDMDS = SystemMetaObject.forObject(dmds);
            for (Object key : props.keySet()) {
                String propertyName = (String) key;
                String str[] = metaObjectDMDS.getSetterNames();
                if (metaObjectDMDS.hasSetter(propertyName)) { // 查看数据源是否有该类型
                    String value = (String) props.get(propertyName);
                    Object convertedValue = convertValue(metaObject, propertyName, value);
                    metaObjectDMDS.setValue(propertyName, convertedValue);
                }
            }
            metaObject.setValue("dmds", dmds);
        }

    }

    @Override
    public DataSource getDataSource() {
        return this.dataSource;
    }

    // https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/datasource/unpooled/UnpooledDataSourceFactory.java
    private Object convertValue(MetaObject metaDataSource, String propertyName, String value) {
        Object convertedValue = value;
        Class<?> targetType = metaDataSource.getSetterType(propertyName); // 获取元数据中设定的类型
        if (targetType == Integer.class || targetType == int.class) {
            convertedValue = Integer.valueOf(value);
        } else if (targetType == Long.class || targetType == long.class) {
            convertedValue = Long.valueOf(value);
        } else if (targetType == Boolean.class || targetType == boolean.class) {
            convertedValue = Boolean.valueOf(value);
        }
        return convertedValue; // 返回设置好类型的对象
    }
}
</textarea>
<div class="text">mybatis-config.xml不同的部分</div>
<textarea class="code">
    <dataSource type="com.hyh.dataSourceFactoryImpl.DataSourceFactoryImpl"> <!--它的属性名与POOLED的完全不同-->
        <property name="driverClass" value="${oracle_driver}"/>
        <property name="jdbcUrl" value="${oracle_url}"/>
        <property name="user" value="${oracle_username}"/>
        <property name="password" value="${oracle_password}"/>
    </dataSource>
</textarea>
<div class="text">mybatis-config.xml对UNPOOLED，POOLED和JNDI的属性应用</div>
<textarea class="code">
            <!--unpooled只支持READ_COMMITED和SERIALIZABLE，主要因为每次创建新的连接。不可能同连接同时访问-->
            <dataSource type="UNPOOLED"> <!--org.apache.ibatis.datasource.unpooled.UnpooledDataSource 中可以找到Connection.READ_COMMITTED是里面的常量-->
                <property name="driver" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>
                <property name="defaultTransactionIsolationLevel" value="2"/>
                <!-- * 接口名：Connection
                int TRANSACTION_NONE             = 0;
                int TRANSACTION_READ_UNCOMMITTED = 1;
                int TRANSACTION_READ_COMMITTED   = 2;
                int TRANSACTION_REPEATABLE_READ  = 4;
                int TRANSACTION_SERIALIZABLE     = 8;-->
                <property name="defaultNetworkTimeout" value="1000"/>
            </dataSource>

            <!--新文件-->
            <dataSource type="POOLED"> <!--org.apache.ibatis.datasource.pooled.pooledDataSource-->
                <property name="driver" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>
                <property name="poolMaximumActiveConnections" value="20"/>
                <property name="poolMaximumIdleConnections" value="5"/>
                <property name="poolMaximumCheckoutTime" value="30000"/>
                <property name="poolTimeToWait" value="25000"/>
                <property name="poolMaximumLocalBadConnectionTolerance" value="5"/>
                <property name="poolPingQuery" value="select * from mybatis_user where id = 1"/>
                <property name="poolPingEnabled" value="true"/>
                <property name="poolPingConnectionsNotUsedFor" value="30000"/>
            </dataSource>
</textarea>
<div class="text">
<pre>
    org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可以作为构建新的数据源适配器的父类使用。

    - C3P0DataSourceFactory类
    * mybatis-config.xml和上面的一样
</pre>
</div>
<textarea class="code">
import com.mchange.v2.c3p0.ComboPooledDataSource;
import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;

public class C3P0DataSourceFactory extends UnpooledDataSourceFactory {

    public C3P0DataSourceFactory() {
        this.dataSource = new ComboPooledDataSource();
    }
}
</textarea>
<div class="text">
    <br><h4>JNDI的应用(spring + mybatis)：是对容器设置的应用</h4><br>
    JNDI在mybatis中底层连接池就是DBCP(2)，详情看 <a href="#dbcp">这里</a>  <br>
    * context.xml！！！！！！这个文件一定在tomcat安装路径下的conf里contex.xml添加，也就是是tomcat容器本身的环境配置
        - 对web.xml的修改也是在tomcat目录下修改
        - 需要在目录下lib文件夹添加jdbc的包 eg:ojdbc8.jar

    tomcat路径下context.xml
</div>
<textarea class="code">
    <!--！！！！！！这个文件一定在tomcat安装路径下的conf里contex.xml添加-->
        <Resource name="jdbc/test" auth="Container"
              type="javax.sql.DataSource"
              driverClassName="com.mysql.jdbc.Driver"
              url="jdbc:oracle:thin:@localhost:1521:orcl"
              username="hyh"
              password="123456"
              maxActive="100" maxIdle="30" maxWait="10000"
              removeAbandoned="true"
              removeAbandonedTimeout="60"
              logAbandoned="true"
    />
</textarea>
<div class="text">tomcat路径下web.xml添加</div>
<textarea class="code">
    <resource-ref>
        <description>Oracle Datasource example</description>
        <res-ref-name>jdbc/test</res-ref-name>
        <res-type>javax.sql.DataSource</res-type>
        <res-auth>Container</res-auth>
    </resource-ref>
</textarea>
<div class="text">spring基本设置</div>
<textarea class="code">
    ++ applicationContext.xml
    <context:component-scan base-package="web.hyh"/>

    ++ dispatcher-servlet.xml
    <context:component-scan base-package="web.hyh.controller"/>
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" id="internalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <property name="suffix" value=".jsp"/>
    </bean>

    ++ web.xml
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
            /WEB-INF/applicationContext.xml
        </param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>

    ++ index.jsp
    <body>
        <% response.sendRedirect( "/index" ); %>
    </body>
</textarea>
<div class="text">web.hyh.controller.IndexController类</div>
<textarea class="code">
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import web.hyh.service.DataProcess;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Controller
public class IndexController {

    @Autowired
    DataProcess dataProcess;

    @RequestMapping("/index")
    public String handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) {

        dataProcess.index(httpServletRequest, httpServletResponse);

        return "index";
    }

}
</textarea>
<div class="text">
    web.hyh.service包内内容
</div>
<textarea class="code">
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public interface DataProcess {
    void index(HttpServletRequest request, HttpServletResponse response);
    void setDataProcess(HttpServletRequest request, HttpServletResponse response);

    int StaticExample = 1;
}
-----------------------------------------------
package web.hyh.service.impl;

import com.hyh.dao.TestMapperInterface;
import com.hyh.pojo.User;
import com.sun.deploy.net.HttpResponse;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.springframework.stereotype.Service;
import web.hyh.service.DataProcess;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.sql.DataSource;
import java.io.*;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

@Service
public class DataProcessImpl implements DataProcess {

    protected HttpServletRequest request;
    protected HttpServletResponse response;

    private HttpSession session;
    private PrintWriter out;

    public DataProcessImpl() {
    }

    public void setDataProcess(HttpServletRequest request, HttpServletResponse response) {
        this.request = request;
        this.response = response;

        try {
            response.setContentType("text/html");
            response.setCharacterEncoding("UTF-8");
            out = response.getWriter();
        } catch (IOException e) {
            e.printStackTrace();
        }
        session = request.getSession();
    }

    @Override
    public void index(HttpServletRequest request, HttpServletResponse response) {
        setDataProcess(request, response);

        SqlSessionFactory factory = giveFactory();
        SqlSession sqlSession = factory.openSession();
        out.print(sqlSession.getMapper(TestMapperInterface.class).getAll());
        out.flush();
        System.out.println(sqlSession.getMapper(TestMapperInterface.class).getAll());
    }

    public SqlSessionFactory giveFactory() { //启用mybatis配置文件
        SqlSessionFactory factory = null;
        try {
            InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); //使用
            factory = new SqlSessionFactoryBuilder().build(inputStream);
            inputStream.close();
        } catch (IOException exception) {
            exception.printStackTrace();
        }

        factory.getConfiguration().setDatabaseId("oracle"); //set database type
        System.out.println(factory.getConfiguration().getDatabaseId());

        return factory;
    }

}
</textarea>
<div class="text">mybatis-config.xml修改部分</div>
<textarea class="code">
    <dataSource type="JNDI">
        <property name="initial_context" value="java:/comp/env"/> <!--在java:/comp/env这个上下文里查找 https://github.com/yeecode/MyBatisCN/blob/489e130b318d4e46f0b2e70a5ed71b25914bda20/src/main/java/org/apache/ibatis/datasource/jndi/JndiDataSourceFactory.java#L40-->
        <property name="data_source" value="/jdbc/test"/>
    <dataSource/>
</textarea>
<div class="text">
        <br><h3>mybatis-config.xml settings属性大全</h3><br>
    </div>
    <textarea class="codeNonClose">
    <settings>

        <!--settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定 活着就是恶心-->
        <setting name="logImpl" value="LOG4J"/>
        <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->

        <!-- 使全局的映射器启用或禁用缓存。 -->
        <setting name="cacheEnabled" value="true"/>

        <!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 -->
        <setting name="lazyLoadingEnabled" value="true"/>

        <!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 -->
        <setting name="aggressiveLazyLoading" value="true"/>

        <!-- 是否允许单条sql 返回多个数据集  (取决于驱动的兼容性) default:true -->
        <setting name="multipleResultSetsEnabled" value="true"/>

        <!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true -->
        <setting name="useColumnLabel" value="true"/>

        <!-- 允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。  default:false  -->
        <setting name="useGeneratedKeys" value="false"/>

        <!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不隐射　PARTIAL:部分  FULL:全部  -->
        <setting name="autoMappingBehavior" value="PARTIAL"/>

        <!-- 这是默认的执行类型  （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新）  -->
        <setting name="defaultExecutorType" value="SIMPLE"/>

        <!-- 使用驼峰命名法转换字段。 -->
        <setting name="mapUnderscoreToCamelCase" value="true"/>

        <!-- 设置本地缓存范围 session:就会有数据的共享  statement:语句范围 (这样就不会有数据的共享 ) defalut:session -->
        <setting name="localCacheScope" value="SESSION"/>

        <!-- 当参数没有设置(JDBC)数据类型的时候，设定该参数的null值的数据类型。某些数据库驱动要指定数据类型，某些不需要指定类型，可以直接使用通用值比如null, varchar 或者 other-->
        <setting name="jdbcTypeForNull" value="NULL"/>

    </settings>
    </textarea>
    <div class="text">
        <br><h3>mybatis日志</h3><br>
        1. **日志的配置**：MyBatis 允许您配置日志记录器（Logger），这些日志记录器用于捕获 MyBatis 执行的详细信息。通常，您可以选择不同的日志记录器实现，例如 Log4j、Logback、Slf4j、Java Util Logging 等。<br>
        2. **MyBatis 的日志级别**：MyBatis 通常支持不同的日志级别，如 DEBUG、INFO、WARN 和 ERROR。您可以根据需要配置所需的日志级别。通常情况下，在开发和调试阶段，将日志级别设置为 DEBUG 可以显示详细的 SQL 执行信息。<br>
        3. **日志的输出位置**：您可以配置日志输出的位置，通常可以将日志输出到控制台、文件或其他自定义位置。这可以通过配置日志框架的 appender 或 MyBatis 的配置文件来完成。<br>
        4. **MyBatis 内置的日志实现**：MyBatis 通常包括一个内置的日志实现，它可以用于快速设置和查看日志。但在生产环境中，通常会使用更强大的日志框架。<br>
        5. **使用 SLF4J 适配器**：SLF4J（Simple Logging Facade for Java）是一个常用的日志门面，它可以与不同的日志实现（如 Log4j、Logback）一起使用。MyBatis 提供了 SLF4J 的适配器，以便您可以将 MyBatis 的日志输出集成到您的 SLF4J 日志系统中。<br>
        6. **示例配置**：官方文档通常提供示例配置，以帮助用户配置适当的日志记录器和级别。<br>
        7. **生产环境的最佳实践**：文档通常会提供关于在生产环境中如何配置和使用日志的最佳实践建议，以确保日志记录不会对性能产生不利影响。<br>
        <br>
        注意chatGPT同一对话保存信息太多会变卡，记得新开一个。<br>
        <h4>mybatis日志官方文档（翻译chatGPT+HYH）</h4><br>
<pre>
    mybatis使用内部日志工厂来生成日志，内部日志工厂会将日志信息委派给下列日志实现中的一个：
        SLF4J
        Apache Commons Logging
        Log4j 2
        Log4j
        JDK logging
    具体选择的实现由mybatis内部的日志工厂在运行时审查决定。MyBatis日志工厂将使用它找到的第一个日志实现（按上述顺序搜索实现）。如果MyBatis找不到上述任何实现，则日志记录将被禁用。

    许多环境将Commons Logging装载为应用内路径的一部分（例如Tomcat和WebSphere），在这种环境中，MyBatis将使用Commons Logging作为日志实现，这意味着您的Log4J配置将被忽略，但如果您更愿意使用其他日志实现，您可以通过在mybatis-config.xml文件中添加以下设置来选择不同的日志实现：
</pre>
        <br>
        mybatis-config.xml<br>
    </div>
    <textarea class="code">
        <settings> <!--settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定 活着就是恶心-->
            <setting name="logImpl" value="LOG4J"/>
            <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->
        </settings>
    </textarea>
    <div class="text">你也可以使用以下方法设定LogFactory的类型：(前提是你的路径里面有该日志实现，否则mybatis就会忽略它)</div>
    <textarea class="code">
    @Test
    public void testForInterfacePlusXMLWithLog() {
        System.out.println("============Test testForInterfacePlusXMLWithLog=============");

        SqlSessionFactory factory = giveFactory();
        LogFactory.useSlf4jLogging(); //选择org.apache.ibatis.logging.LogFactory
        //        报错没找到路径，可能mybatis虽然忽略没有路径的配置，但它下面的LoggerFactory不会，仍然会报错
        //        甚至底层可以看见它是抛出了异常的 可以用try catch跳过  <好想死>
        //        添加包：slf4j-api-1.7.32.jar
        org.apache.ibatis.logging.LogFactory.useLog4JLogging();
        //log4j-1.2.17.jar log4j-slf4j-impl-3.0.0-alpha1.jar log4j-api-2.17.2.jar log4j-core-2.11.2.jar
        System.setProperty("myproperty", "F:\\JAVA\\20230925\\mybitis\\src\\resources\\log4j2.properties");
        org.apache.ibatis.logging.LogFactory.useLog4J2Logging();
        //提示需要设置配置文件 注意非class文件out和实际文件可能不同步，需要手动复制 卡了好几小时...
        //分析原因：可能是曾经修改项目到maven结构导致的idea识别问题，重新建一个项目就可以解决了。
        org.apache.ibatis.logging.LogFactory.useJdkLogging();
        org.apache.ibatis.logging.LogFactory.useCommonsLogging();
        org.apache.ibatis.logging.LogFactory.useStdOutLogging();

        try (SqlSession session = factory.openSession()) {
            factory.getConfiguration().setDatabaseId("oracle"); //set database type
            System.out.println(factory.getConfiguration().getDatabaseId());
            //在xml里面添加了接口

            TestMapperInterface tmi = session.getMapper(TestMapperInterface.class);
            System.out.println("" +
                    tmi.delete(51) + " " +
                    tmi.update(45, "asdf", "wee", 90) + " " +
                    tmi.insert(23, "sd", "sd", 88) + " " +
                    tmi.getAll() + " \n" +
                    tmi.selectUser(45)
            ); //这里查找的数据想要改变中途需要commit

            session.commit();

        }
    }
    </textarea>
    <div class="text">输出（包含StdOutLogging日志内容）</div>
    <textarea class="code">
2023-09-30 20:06:36 DEBUG LogFactory:105 - Logging initialized using 'class org.apache.ibatis.logging.log4j2.Log4j2Impl' adapter.
Logging initialized using 'class org.apache.ibatis.logging.stdout.StdOutImpl' adapter.
oracle
Opening JDBC Connection
Setting autocommit to false on JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]
true true true [User{id=175, name='sd', sex='sd', age=88}, User{id=45, name='asdf', sex='wee', age=90}, User{id=42, name='WWW', sex='W', age=10}, User{id=43, name='WWW', sex='W', age=10}, User{id=44, name='WWW', sex='W', age=10}, User{id=46, name='WWW', sex='W', age=10}, User{id=47, name='WWW', sex='W', age=10}, User{id=48, name='WWW', sex='W', age=10}, User{id=49, name='WWW', sex='W', age=10}, User{id=50, name='WWW', sex='W', age=10}]
User{id=45, name='asdf', sex='wee', age=90}
Rolling back JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]
Resetting autocommit to true on JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]
Closing JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]
    </textarea>
    <div class="text">
<pre>
    要查看MyBatis的日志记录语句，您可以针对一些对象启用日志，其中包含一个包，一个mapper指向的类或其中的namespace或一个合法的sql语句id名。

    如何实现这一点取决于所使用的日志记录实现方式。我们将展示如何使用Log4J来实现它。配置日志服务只是简单地包含一个或多个额外的配置文件（例如log4j.properties）和有时一个新的JAR文件（例如log4j.jar）。以下示例配置将使用Log4J作为提供者配置完整的日志记录服务。共有2个步骤。

    第一步：添加包

    第二步：配置
    log4j.properties文件
</pre>
    </div>
    <textarea class="code">
# Global logging configuration
log4j.rootLogger=ERROR, stdout
# MyBatis logging configuration...
log4j.logger.com.hyh.dao.TestDao=TRACE
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n
    </textarea>
    <div class="text">打印出如下所示的日志</div>
    <textarea class="code">
XMLSelect
Opening JDBC Connection
Setting autocommit to false on JDBC Connection [oracle.jdbc.driver.T4CConnection@5c3b6c6e]
DEBUG [main] - ==>  Preparing: SELECT * FROM mybatis_user
DEBUG [main] - ==> Parameters:
TRACE [main] - <==    Columns: ID, NAME, SEX, AGE
TRACE [main] - <==        Row: 51, WWW, W, 10
TRACE [main] - <==        Row: 45, WWW, W, 10
TRACE [main] - <==        Row: 42, WWW, W, 10
...
DEBUG [main] - <==      Total: 10
DEBUG [main] - ==>  Preparing: select * from mybatis_user where id = ?
DEBUG [main] - ==> Parameters: 51(Integer)
TRACE [main] - <==    Columns: ID, NAME, SEX, AGE
TRACE [main] - <==        Row: 51, WWW, W, 10
DEBUG [main] - <==      Total: 1
[User{id=51, name='WWW', sex='W', age=10}, User{id=45, name='WWW', sex='W', age=10}, User{id=42, name='WWW', sex='W', age=10}, User{id=43, name='WWW', sex='W', age=10}, User{id=44, name='WWW', sex='W', age=10}, User{id=46, name='WWW', sex='W', age=10}, User{id=47, name='WWW', sex='W', age=10}, User{id=48, name='WWW', sex='W', age=10}, User{id=49, name='WWW', sex='W', age=10}, User{id=50, name='WWW', sex='W', age=10}]
User{id=51, name='WWW', sex='W', age=10}
DEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual
DEBUG [main] - ==> Parameters:
TRACE [main] - <==    Columns: NEXTVAL
TRACE [main] - <==        Row: 179
DEBUG [main] - <==      Total: 1
DEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)
DEBUG [main] - ==> Parameters: 179(Integer), WWW(String), W(String), 10(Integer)
DEBUG [main] - <==    Updates: 1
DEBUG [main] - ==>  Preparing: update mybatis_user SET name=?, sex=?, age=? where id=?
DEBUG [main] - ==> Parameters: xxxpoipioip(String), op(String), 9(Integer), 51(Integer)
DEBUG [main] - <==    Updates: 1
DEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?
DEBUG [main] - ==> Parameters: 51(Integer)
DEBUG [main] - <==    Updates: 1
DEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?
DEBUG [main] - ==> Parameters: 45(Integer)
DEBUG [main] - <==    Updates: 1
    </textarea>
    <div class="text">
<pre>
上面的文件将导致log4J对org.mybatis.example.BlogMapper报告详细的日志，而对您应用程序的其余类只报告错误日志。

如果您想更精细地调整日志记录级别，可以为特定语句打开日志记录，而不是整个映射器文件。例如下面语句只对更新操作报告日志：

    log4j.logger.com.hyh.dao.TestDao.update=TRACE

如果想对多个mappers打印日志，你可以将以上条目修改为其包所在的根目录

    log4j.logger.com.hyh.dao=TRACE

有一些查询可能会返回大量的结果集。在这种情况下，您可能希望查看SQL语句，但不需要看到结果。出于这个目的，SQL语句被记录在DEBUG级别（在JDK日志中是FINE级别），而结果则在TRACE级别（在JDK日志中是FINER级别）记录。因此，如果您想查看语句但不需要查看结果，将日志级别设置为DEBUG。

    log4j.logger.com.hyh.dao=DEBUG

</pre>
        debug输出内容
    </div>
    <textarea class="code">
DEBUG [main] - ==>  Preparing: select * from mybatis_user where id = ?
DEBUG [main] - ==> Parameters: 51(Integer)
DEBUG [main] - <==      Total: 1
[User{id=51, name='WWW', sex='W', age=10}, User{id=45, name='WWW', sex='W', age=10}, User{id=42, name='WWW', sex='W', age=10}, User{id=43, name='WWW', sex='W', age=10}, User{id=44, name='WWW', sex='W', age=10}, User{id=46, name='WWW', sex='W', age=10}, User{id=47, name='WWW', sex='W', age=10}, User{id=48, name='WWW', sex='W', age=10}, User{id=49, name='WWW', sex='W', age=10}, User{id=50, name='WWW', sex='W', age=10}]
User{id=51, name='WWW', sex='W', age=10}
DEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual
DEBUG [main] - ==> Parameters:
DEBUG [main] - <==      Total: 1
DEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)
DEBUG [main] - ==> Parameters: 188(Integer), WWW(String), W(String), 10(Integer)
DEBUG [main] - <==    Updates: 1
DEBUG [main] - ==>  Preparing: update mybatis_user SET name=?, sex=?, age=? where id=?
DEBUG [main] - ==> Parameters: xxxpoipioip(String), op(String), 9(Integer), 51(Integer)
DEBUG [main] - <==    Updates: 1
DEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?
DEBUG [main] - ==> Parameters: 51(Integer)
DEBUG [main] - <==    Updates: 1
    </textarea>
    <div class="text">
<pre>
    在对日志记录对象的设置中如果增删查改使用的是接口那么设置的就是包名，如果使用的是xml那么设置的是namespace和sql语句的id值。也就是说两者的设置差别不大。
</pre>
        <br>
    <h3>连接池：它是一种多用户释放资源的策略</h3><br>
        <a href="https://blog.csdn.net/qq_30257081/article/details/86554585">
            https://blog.csdn.net/qq_30257081/article/details/86554585
        </a><br>
<pre>
连接池的优点
    1.资源重用
    2.提升系统响应速度
    3.避免数据库连接遗漏
它定义的工作原理
    S1. 当服务器启动时，创建一些连接放在连接池中，等待客户端请求。
    S2. 当客户端发来请求需要连接数据库时，容器首先查看连接池中是否有可用的连接，如果有，则返回将连接返回；如果没有则查看当前的连接数是否超过了最大的可用连接数。如果没有超过，则创建新的链接返回；如果超过了，则抛出无可用连接的异常。
    S3. 当连接使用完毕后，连接再次被放回到连接池中，从而实现连接的重用。
</pre>
        1.dbcp<br>
        2.c3p0:基于dbcp<br>
        3.DBUtils:基于dbcp和dbutil<br>
        4.druid:它是一个独立的国有连接池，中文名德鲁伊<br>
        如果您需要一个轻量级的连接池，可以考虑使用DBCP。对于更高级的连接池管理功能，C3P0和Druid是更好的选择。DBUtils则适用于需要简化JDBC操作的场景，通常与其它连接池库(如DBCP或C3PO)一起使用。<br>
<pre class="preText">
    性能比较：
    druid > DBUtil > dbcp > c3p0
</pre>
    <br><h4 id="dbcp">1.dbcp</h4><br>
        Apache DBCP（Database Connection Pool）是一个开源的Java连接池库，用于管理和维护数据库连接。它的底层工作原理涉及以下几个关键组件和步骤：<br>

        1.数据源（DataSource）：DBCP使用数据源来创建和管理数据库连接。数据源通常是数据库驱动程序提供的实现。数据源包含有关如何创建和配置连接的信息。<br>

        2.连接池（Connection Pool）：连接池是连接的缓存，它维护一组可供应用程序使用的数据库连接。连接池的大小可以配置，以确定可以同时支持的最大连接数。它的主要作用是为了避免反复开启/结束对数据库的连接，具有即用性。<br>

        3.连接池管理器（Pool Manager）：连接池管理器负责维护连接池的状态，包括创建、释放、回收和管理连接。它确保连接的可用性，并防止连接泄漏和资源浪费。<br>

        4.连接工厂（Connection Factory）：连接工厂是负责创建数据库连接的组件。它使用数据源配置信息来创建连接，并将这些连接添加到连接池中。<br>

        5.连接状态跟踪（Connection State Tracking）：DBCP可以跟踪连接的状态，以检测闲置连接、失效连接和超时连接。这有助于回收和重新利用连接，以减少连接的创建和销毁开销。<br>
<br>
        连接池配置：连接池的配置参数包括最小连接数、最大连接数、连接超时时间、闲置连接检测等。这些参数可以根据应用程序的需求进行调整。<br>

        连接的获取和释放：应用程序通过请求连接来从连接池中获取连接，使用完后，将连接释放回池中。连接池管理器会确保连接的有效性，并在需要时重新创建连接或回收不再使用的连接。<br>
<br>
        总的来说，DBCP通过维护连接池、跟踪连接状态和提供连接管理功能，使得应用程序可以高效地使用数据库连接，并在需要时动态创建和销毁连接，从而降低了数据库连接的开销，提高了应用程序的性能和可伸缩性。<br>

        <br>
<pre class="preText">
    dbcp实现添加包:
        - commons-dbcp:commons-dbcp
        - commons-pool:commons-pool
        - commons-collections:commons-collections

    DBCPDataSourceFactory类
</pre>
    </div>
    <textarea class="code">
import org.apache.ibatis.datasource.pooled.PooledDataSourceFactory;
import org.apache.commons.dbcp.BasicDataSource;

public class DBCPDataSourceFactory extends PooledDataSourceFactory {

    public DBCPDataSourceFactory() {
        this.dataSource = new BasicDataSource();
    }
}
    </textarea>
<div class="text">
    TransactionImpl自定义类的修改
</div>
<textarea class="code">
    @Override
    public Integer getTimeout() throws SQLException {
        LOGGER.debug(() -> {
            return "HAMSTER Connection [" + this.connection + "] is checking timeout";
        });
        return this.connection.createStatement().getQueryTimeout(); // 因为DBCP没有实现获取网络超时时间，就只能获取sql语句执行超时时间
    }
</textarea>
<div class="text">dbcp config-mybatis.xml文件及<h4>属性大全</h4></div>
<textarea class="codeNonClose">
            <dataSource type="com.hyh.dataSourceFactoryImpl.DBCPDataSourceFactory">
                <property name="driverClassName" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>

                <!--初始化连接:连接池启动时创建的初始化连接数量-->
                <property name="initialSize" value="3"/>

                <!--最大活跃数-->
                <property name="maxActive" value="20"/>

                <!--最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制-->
                <property name="maxIdle" value="10"/>

                <!--最小空闲连接:连接池中容许保持空闲状态的最小连接数量,负数表示没有现在-->
                <!--如果空闲连接的数量设置的太少且系统负载高，有可能导致实际的空闲连接超过最大空闲连接的限制，因为关闭连接的速度比打开连接的速度快，所以有许多被关闭的连接保持空闲等待被打开的连接，这就导致了实际空闲连接会大于最大空闲连接-->
                <property name="minIdle" value="2"/>

                <!--最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为-1表示无限等待-->
                <property name="maxWait" value="10000"/>

                <!--在将连接返回给调用者之前，一个用来验证从连接池取出连接的可用性的SQL查询，如果指定,则查询必须是一个SELECT语句并且必须返回至少一行记录-->
                <property name="validationQuery" value="select * from mybatis_user where id = 1"/>

                <!--指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个.注意:设置为true后如果要生效,validationQuery参数必须设置为非空字符串-->
                <property name="testOnBorrow" value="true"/>

                <!--指明是否在归还到池中前进行检验-->
                <property name="testOnReturn" value="true"/>

                <!--指明连接是否被空闲连接排错器(如果有)进行检验.如果检测失败,则连接将被从池中去除.注意:设置为true后如果要生效,validationQuery参数必须设置为非空字符串-->
                <property name="testWhileIdle" value="true"/>

                <!--在每次空闲连接排错器线程(如果有)运行时检查的连接数量-->
                <property name="numTestsPerEvictionRun" value="3"/>

                <!--开启prepared statement池 开启需要添加包：commons-pool-1.6.jar-->
                <property name="poolPreparedStatements" value="true"/>

                <!--statement池在同一时间能够分配的活跃prepared statements的最大数量,如果设置为0表示不限制
                        为了避免最大活跃prepared statements超过最大开启游标数而导致的游标耗尽，请保证最大活跃数小于最大开启游标数-->
                <property name="maxOpenPreparedStatements" value="1000"/>

                <!--控制PoolGuard是否容许获取底层连接 默认false不开启, 这是一个有潜在危险的功能, 不适当的编码会造成危险.(可能关闭底层连接或者在守护连接已经关闭的情况下继续使用连接).请谨慎使用,并且仅当需要直接访问驱动的扩展功能时使用.注意:不要直接关闭底层连接,只能关闭原本的连接.-->
                <property name="accessToUnderlyingConnectionAllowed" value="true"/>

                <!--标记是否删除超过removeAbandonedTimout时长连接，如果连接超过时长就会被视作被抛弃的连接。设置该项可以让服务器有空闲去恢复配置糟糕的应用连接-->
                    <!--如果开启则连接在被抛弃时可能被回收，当空闲数<2，活跃数>最大活跃数 - 3时且空闲时间大于removeAbandonedTimeout，就会被回收，但如果一旦创建了动态或者静态的statement或者执行了任何一个查询，空闲时间就会清空。-->
                <property name="removeAbandoned" value="true"/>

                <!--定义为被抛弃并删除的连接前的最大时长-->
                <property name="removeAbandonedTimeout" value="500"/>

                <!--是否为被抛弃的连接或者Statement生成日志，该日志会在每个连接或者Statement开启的时候不断叠加，因为日志的生成依赖于堆栈信息的生成。-->
                <property name="logAbandoned" value="true"/>

            </dataSource>
</textarea>
    <div class="text">
        <br><h4>2. c3p0</h4><br>
        在 <a href="#dataSource">之前</a> 使用过的类的图表<br>
<!--        <img src="c0p3diagram.png"/>-->
        <img src="c3p02.png"/>
<pre class="preText">
    C3PO与DBCP的区别
    - C3P0有自动回收空闲连接功能，DBCP没有。
        # maxIdleTime：定义连接在池中保持空闲的最长时间（以毫秒为单位）。默认值为0，表示不启用空闲连接的回收。
        # maxIdleTimeExcessConnections：定义在连接池中保持空闲的超出最小连接数的连接的最长时间。默认值为0。
        # maxConnectionAge：定义连接在池中的最长生命周期，包括使用和空闲时间。默认值为0，表示不限制连接寿命。
    - C3P0提供最大空闲时间，DBCP提供最大连接数。
    也就是说C3P0在连接回收方便更复杂，所以在性能表现：DBCP > C3P0

    连接代理类：
</pre>
    </div>
<textarea class="code">
    com.mchange.v2.c3p0.impl.NewProxyConnection@d554c5f [wrapping: oracle.jdbc.driver.T4CConnection@48fd1fe4]
</textarea>
<div class="text">
    <br><h4>3. DBUtil</h4><br>
<pre class="preText">
    DBUtil的定义：DBUtil 连接池是一个通用的数据库连接池管理工具，用于管理数据库连接的创建、使用和释放，管理它的生命周期。连接池的主要目标是提高数据库连接的重复利用率和性能，减少每次数据库操作都重新创建和关闭连接的开销。
    本质：基于DBCP | C3P0 | 德鲁伊连接池，对数据库存取的方法经行了简单封装，它对连接池中连接的操作不需要依靠mybatis
        ————————————————————————————————————————————————————————————————————————————————————
        比较一下 JDBC, dbutils, Mybatis 和 Hibernate
        JDBC: 原生访问数据库的方式, 其它三个都是对 JDBC 不同程度的包装 访问数据库比较麻烦, 代码重复度极高
        dbutils: 是对jdbc进行了相对简单的包装, 主要就是能自动封装查询结构 集, 需要在代码中写 sql 语句
        Mybatis: 进一步封装 jdbc, Sql 语句写在配置文件中, 面向对象操作, 有一 二级缓存功能
        Hibernate: 对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL
            ————————————————
            版权声明：本文为CSDN博主「jkljkil」的原创文章。
            原文链接：https://blog.csdn.net/jkljkil/article/details/110723911
        ————————————————————————————————————————————————————————————————————————————————————
    生命周期：
        初始化 -> 获取 -> 操作 -> 释放
        连接池管理：超时处理 -> 连接验证 -> 连接自动回收
        销毁：释放连接 -> 销毁连接池
    DBUtil和 (DBCP | C3P0) 相比
        1. dbutil更轻量，比另外两个小。
        2. DBCP和C3P0都相对成熟，有较丰富的社区支持和活跃度，更容易获得更新修复BUG。
        3. 它的性能更好。

    添加包：
        - commons-dbutils-1.7.jar
        - log4j-api的版本需要为2.17.1及以下，否则找不到java.util.Stack org.apache.logging.log4j.util.StackLocatorUtil.getCurrentStackTrace()

        * 注意：IDEA里面properties文件容易乱码，要及时调整在：Settings -> Editor -> File encoding

    测试文件(使用了之前提到过的DataSourceFactoryImpl类)：
</pre>
</div>
<textarea class="code">
    @Test
    public void testDBUtil() { //RUN UNDER JAVA 11!! --ADD MODULE JAVA-BASE --Add java-module... == all resolved by alt + enter >><<   ---> close by Settings > Build > Execution, Deployment > Compiler > Java Compiler 删除定义的那一条
        DataSourceFactoryImpl dsfi = new DataSourceFactoryImpl(); //为DBUtil封装的工具提供DataSource
        Properties properties = new Properties();
        try {
            FileInputStream fis = new FileInputStream("F:\\JAVA\\20230925\\testMybatis\\src\\c3p0config.properties");
            properties.load(fis);
        } catch (IOException e) {
            e.printStackTrace();
        }
        dsfi.setProperties(properties);
        QueryRunner qr = new QueryRunner(dsfi.getDataSource());

        try {
            List<User> li = (List<User>) qr.query("select * from mybatis_user", new BeanListHandler(User.class));
            System.out.println(li);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
</textarea>
<div class="text">c3p0config.properties文件</div>
<textarea class="code">
#<!-- oracle以及反射类的属性 -->
driverClass=oracle.jdbc.driver.OracleDriver
jdbcUrl=jdbc:oracle:thin:@localhost:1521:orcl
user=hyh
password=123456
</textarea>
<div class="text">输出日志为DBUtil特有的，如下：</div>
<textarea class="code">
C:\Users\AJH41\.jdks\corretto-11.0.20.1\bin\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 "-javaagent:F:\IntelliJ IDEA 2021.2.3\lib\idea_rt.jar=7457:F:\IntelliJ IDEA 2021.2.3\bin" -Dfile.encoding=UTF-8 -classpath "F:\IntelliJ IDEA 2021.2.3\lib\idea_rt.jar;F:\IntelliJ IDEA 2021.2.3\plugins\junit\lib\junit5-rt.jar;F:\IntelliJ IDEA 2021.2.3\plugins\junit\lib\junit-rt.jar;F:\JAVA\20230925\testMybatis\out\production\testMybatis;F:\JAVA\20230925\testMybatis\lib\ojdbc8.jar;F:\JAVA\20230925\testMybatis\lib\c3p0-0.9.5.5.jar;F:\JAVA\20230925\testMybatis\lib\log4j-1.2.17.jar;F:\JAVA\20230925\testMybatis\lib\mybatis-3.5.8.jar;F:\JAVA\20230925\testMybatis\lib\aopalliance-1.0.jar;F:\JAVA\20230925\testMybatis\lib\commons-dbcp-1.4.jar;F:\JAVA\20230925\testMybatis\lib\log4j-api-2.17.1.jar;F:\JAVA\20230925\testMybatis\lib\slf4j-api-1.7.32.jar;F:\JAVA\20230925\testMybatis\lib\spring-dao-2.0.1.jar;F:\JAVA\20230925\testMybatis\lib\log4j-core-2.11.2.jar;F:\JAVA\20230925\testMybatis\lib\commons-dbutils-1.7.jar;F:\JAVA\20230925\testMybatis\lib\commons-logging-1.2.jar;F:\JAVA\20230925\testMybatis\lib\mybatis-spring-2.0.1.jar;F:\JAVA\20230925\testMybatis\lib\spring-tx-5.2.3.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\spring-aop-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\spring-orm-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\spring-web-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\spring-core-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\spring-beans-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\mchange-commons-java-0.2.20.jar;F:\JAVA\20230925\testMybatis\lib\spring-webmvc-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\commons-collections-20040616.jar;F:\JAVA\20230925\testMybatis\lib\commons-pool-20030825.183949.jar;F:\JAVA\20230925\testMybatis\lib\spring-context-5.2.5.RELEASE.jar;F:\JAVA\20230925\testMybatis\lib\log4j-slf4j-impl-3.0.0-alpha1.jar;F:\JAVA\20230925\testMybatis\lib\spring-expression-5.2.5.RELEASE.jar;C:\Users\AJH41\.m2\repository\junit\junit\4.13.1\junit-4.13.1.jar;C:\Users\AJH41\.m2\repository\org\hamcrest\hamcrest-core\1.3\hamcrest-core-1.3.jar;C:\Program Files\Apache Software Foundation\Tomcat 9.0\lib\jsp-api.jar;C:\Program Files\Apache Software Foundation\Tomcat 9.0\lib\servlet-api.jar" com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit4 com.hyh.test.TestUnderJava11,testDBUtil
2023-10-07 13:12:23 INFO  MLog:212 - MLog clients using slf4j logging.
2023-10-07 13:12:23 DEBUG MLog:207 - Reading VM config for path list /com/mchange/v2/log/default-mchange-log.properties, /mchange-commons.properties, /c3p0.properties, hocon:/reference,/application,/c3p0,/, /mchange-log.properties, /
2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier '/mchange-commons.properties' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier '/c3p0.properties' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier 'hocon:/reference,/application,/c3p0,/' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier '/mchange-commons.properties' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier '/mchange-log.properties' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier '/mchange-log.properties' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier 'hocon:/reference,/application,/c3p0,/' could not be found. Skipping.
2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier '/c3p0.properties' could not be found. Skipping.
2023-10-07 13:12:24 INFO  C3P0Registry:212 - Initializing c3p0-0.9.5.5 [built 11-December-2019 22:18:33 -0800; debug? true; trace: 10]
2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 registered.
2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 unregistered, in order to be reregistered after update.
2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 registered.
setting
2023-10-07 13:12:24 INFO  AbstractPoolBackedDataSource:212 - Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -> 3, acquireRetryAttempts -> 30, acquireRetryDelay -> 1000, autoCommitOnClose -> false, automaticTestTable -> null, breakAfterAcquireFailure -> false, checkoutTimeout -> 0, connectionCustomizerClassName -> null, connectionTesterClassName -> com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -> caller, dataSourceName -> 1hgeby9az2devs5yqoxvu|386f0da3, debugUnreturnedConnectionStackTraces -> false, description -> null, driverClass -> oracle.jdbc.driver.OracleDriver, extensions -> {}, factoryClassLocation -> null, forceIgnoreUnresolvedTransactions -> false, forceSynchronousCheckins -> false, forceUseNamedDriverClass -> false, identityToken -> 1hgeby9az2devs5yqoxvu|386f0da3, idleConnectionTestPeriod -> 0, initialPoolSize -> 3, jdbcUrl -> jdbc:oracle:thin:@localhost:1521:orcl, maxAdministrativeTaskTime -> 0, maxConnectionAge -> 0, maxIdleTime -> 0, maxIdleTimeExcessConnections -> 0, maxPoolSize -> 15, maxStatements -> 0, maxStatementsPerConnection -> 0, minPoolSize -> 3, numHelperThreads -> 3, preferredTestQuery -> null, privilegeSpawnedThreads -> false, properties -> {password=******, user=******}, propertyCycle -> 0, statementCacheNumDeferredCloseThreads -> 0, testConnectionOnCheckin -> false, testConnectionOnCheckout -> false, unreturnedConnectionTimeout -> 0, userOverrides -> {}, usesTraditionalReflectiveProxies -> false ]
2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier '/mchange-commons.properties' could not be found. Skipping.
2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier '/mchange-log.properties' could not be found. Skipping.
2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier '/c3p0.properties' could not be found. Skipping.
2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier 'hocon:/reference,/application,/c3p0,/' could not be found. Skipping.
2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - com.mchange.v2.resourcepool.BasicResourcePool@74a6a609 config: [start -> 3; min -> 3; max -> 15; inc -> 3; num_acq_attempts -> 30; acq_attempt_delay -> 1000; check_idle_resources_delay -> 0; max_resource_age -> 0; max_idle_time -> 0; excess_max_idle_time -> 0; destroy_unreturned_resc_time -> 0; expiration_enforcement_delay -> 0; break_on_acquisition_failure -> false; debug_store_checkout_exceptions -> false; force_synchronous_checkins -> false]
2023-10-07 13:12:24 DEBUG C3P0PooledConnectionPoolManager:204 - Created new pool for auth, username (masked): 'hy******'.
2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - acquire test -- pool size: 0; target_pool_size: 3; desired target? 1
2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - awaitAvailable(): [unknown]
[User{id=387, name='sss', sex='sdf', age=80}, User{id=391, name='sss', sex='sdf', age=80}, User{id=395, name='sss', sex='sdf', age=80}, User{id=379, name='sss', sex='sdf', age=80}, User{id=383, name='sss', sex='sdf', age=80}, User{id=2, name='xx', sex='pp', age=100}, User{id=1, name='xx', sex='pp', age=100}, User{id=403, name='sss', sex='sdf', age=80}, User{id=407, name='sss', sex='sdf', age=80}, User{id=411, name='sss', sex='sdf', age=80}, User{id=415, name='sss', sex='sdf', age=80}, User{id=436, name='sss', sex='sdf', age=80}, User{id=399, name='sss', sex='sdf', age=80}, User{id=419, name='sss', sex='sdf', age=80}, User{id=423, name='sss', sex='sdf', age=80}, User{id=397, name='sss', sex='sdf', age=80}, User{id=398, name='sss', sex='sdf', age=80}, User{id=443, name='sss', sex='sdf', age=80}, User{id=447, name='sss', sex='sdf', age=80}, User{id=400, name='sss', sex='sdf', age=80}, User{id=427, name='sss', sex='sdf', age=80}, User{id=431, name='sss', sex='sdf', age=80}, User{id=433, name='sss', sex='sdf', age=80}]

Process finished with exit code 0

</textarea>
<div class="text">
    <br><h4>4. druid</h4><br>
<pre class="preText">
    定义：Druid是阿里巴巴的开源连接池组件，是世界上最好的连接池之一。Druid能对数据库连接进行有效管理和重用，最大化程序执行的效率。连接池负责创建和管理连接，程序只负责取用与归还。
    优势：它是Java语言中功能强大、性能优秀的数据库连接池之一。Druid连接池结合了C3P0、DBCP等数据库连接池的优点。
        druid和前两个连接池的对比：druid功能强大，性能最强，具有极强的扩展性
            参考数据：https://blog.51cto.com/u_15553139/5205148
            总结如下：
            在获取连接的时间方面：druid > c3p0 > dbcp
            在功能拓展方便：druid > dbcp > c3p0 也就是说druid可以扩展很多插件
    获取数据源：
        使用com.alibaba.druid.pool.DruidDataSource类来创建新的数据源，具体属性可以在类里面查看到
            类里面使用的变量
                protected volatile String username; ---volatile 的修改和读取都是直接针对主存，且操作不会被重新排序优化，对所有线程都具有可见性
                protected volatile String password;
                protected volatile String jdbcUrl;
                protected volatile String driverClass;
            类变量使用的接口
                void setDriverClassName(String driverClass)
                void setUrl(String jdbcUrl)
                void setUsername(String username)
                void setPassword(String password)
            实验结论：对这些属性的操作要基于它的接口名称
    添加包：
        - druid-1.2.18.jar

    DruidDataSource类
</pre>
</div>
<textarea class="code">
import com.alibaba.druid.pool.DruidDataSourceFactory;
import org.apache.ibatis.datasource.DataSourceFactory;

import javax.sql.DataSource;
import java.util.Properties;

// https://blog.csdn.net/m0_70031574/article/details/131947655
public class DruidDataSource implements DataSourceFactory { // java: illegal character: '\ufeff' remove BOM in File Editor and recreate file

    private DataSource dataSource;
    private Properties properties;

    public DruidDataSource() {
    }

    @Override
    public void setProperties(Properties properties) {
        this.properties = properties;
        try {
            this.dataSource = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public DataSource getDataSource() {
        return this.dataSource;
    }
}
</textarea>
<div class="text">
    mybatis-config.xml文件
</div>
<textarea class="code">
    <dataSource type="com.hyh.dataSourceFactoryImpl.DruidDataSource">
                <property name="driver" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>
    </dataSource>
</textarea>



    <div class="text">
        <h3>ssh/ss(h)m：ssh/ss(h)m/spring对数据库事务的处理</h3><br>
        <br><h4>1. ssh</h4><br>
<pre class="preText">
    ssh的定义：Struts + Spring + Hibernate
        Structs：流程控制
        Spring：业务流转
        Hibernate：数据库操作的封装
            这里介绍一下Hibernate:
                首先，它是对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL。
                其次，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JavaEE架构中取代CMP，完成数据持久化的重任。
                    EJB: Enterprise JavaBeans
                        分布式企业级应用程序的Java组件模型，包含Session Bean，Entity(实体) Bean等组件
                    CMP: Container-Managed Persistence(被容器管理的持久性[模型])
                        例如，Entity Bean就具有持久性
                    JavaEE: Java Platform, [Enterprise Edition]
                        它的规范包含各种持久性和通信API
                            通信API例如TCP/UDP
    类别：属于MVC软件开发模式
    >>翻译（CHATGPT + HYH）https://www.codejava.net/frameworks/struts/struts-2-spring-4-hibernate-4-integration-tutorial-part-1-xml-configuration

    SSH教学 第一部分（XML配置）

    该教学项目的目的为从数据库里打印一张表里的所有产品到JSP页面，它会帮助我们理解在这种高集成的环境下究竟发生了什么。

    为什么要集成Struts、Spring和Hibernate？
        Struts是一个Web应用程序框架，Spring是一个企业应用程序框架，Hibernate是一个ORM（对象和数据库的数据映射和转换）框架。Hibernate在数据库层工作，而Struts和Spring都可以在Web层工作。Spring比Struts更强大，它可以替代Struts。因此，如果你正在使用Spring和Hibernate开始一个新项目，就不需要再使用Struts了！
        这种集成只对以Struts构建的旧项目才是必要的，现在你必须将它们升级为Spring和Hibernate，同时保留Struts。因此，在实际中很少有Struts-Spring-Hibernate应用程序。

    Struts、Spring和Hibernate的集成是如何工作的？
        在这种集成中，Struts应该充当调度过滤器的角色，拦截所有进入应用程序的请求。Spring应该作为依赖注入容器，还管理Hibernate会话并提供事务管理服务。
        有趣的一点是，Struts的Action类由Spring管理。因此，Struts中映射的操作可以绑定一个Spring bean。这只能通过使用Struts提供的Spring插件来实现。

    首先让我们创建一个maven项目。

    oracle表结构：
    1 create table product(
      2  id number(11) primary key,
      3  name varchar2(128) not null,
      4  description varchar2(512) not null,
      5  price number(10,2) not null);

    ** 注意strut的名字念 /strʌt/ 而不是 /strʌkt/ ，它的构词和structure这些没有绝对关系，所以配置文件叫strut.xml，这个BUG我排查了将近半天，最近怎么老打错而且还半天找不到，看来该回炉重造了。

    下面为项目结构：
</pre>
        <img src="sshProjectStructure.png" style="width: 35%">
        <img src="sshProjectStructure2.png" style="width: 35%">
<pre class="preText">
    注意项目中的log4j.properties只有在resources内部的生效了。我修改后忘记删除了。

    文件分类：strut相关(pom.xml or maven依赖 在最后)
        - struts.xml  web.xml  ListProductAction.java  ProductList.jsp
</pre>
    </div>
<textarea class="code">
    + struts.xml
    <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE struts PUBLIC
        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"
        "http://struts.apache.org/dtds/struts-2.0.dtd">

<struts>
    <package name="demo" extends="struts-default" namespace="/">

        <default-action-ref name="listProduct"/> <!--strut设置首页-->

<!--        <action name="*">-->  <!--该项目没有使用但该设置可以使view下面的jsp通过文件名访问，相当于servlet-dispatcher-->
<!--            <result>/WEB-INF/views/{1}.jsp</result>-->
<!--        </action>-->

        <action name="listProduct" class="com.hyh.structAction.ListProductAction" method="execute">
            <result name="success">/WEB-INF/views/ProductList.jsp</result>
        </action>

    </package>
</struts>

    ______________________________________________

    + web.xml
    <?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring/appContext.xml</param-value>
    </context-param>

    <listener> <!--artifact -> WEB-INF -> <CREATE> file called lib -> <right click> -> add a copy of -> library files-->
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <filter> <!--它取代了servlet-->
        <filter-name>DispatcherFilter</filter-name>
        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>DispatcherFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>

    ----------------------------------------------

    + ListProductAction.java

    package com.hyh.structAction;

import com.hyh.dao.ProductDAO;
import com.hyh.pojo.Product;
import com.opensymphony.xwork2.ActionSupport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("listProductActionBean")
public class ListProductAction extends ActionSupport {
    @Autowired
    private ProductDAO productDAO;
    private List<Product> listProduct;

    @Autowired
    public void setProductDAO(ProductDAO productDAO) { // spring通过setter注入
        this.productDAO = productDAO;
    }

    @Override
    public String execute() {
        listProduct = productDAO.list();
        return SUCCESS;
    }

    public List<Product> getListProduct() { // JSP通过get获取
        return listProduct;
    }
}

    -----------------------------------

    + ProductList.jsp

    <%@ taglib prefix="s" uri="/struts-tags" %>
<%--
  Created by IntelliJ IDEA.
  User: AJH41
  Date: 2023-10-08
  Time: 3:29 PM
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<div align="center">
    <table width="80%" border="1" style="border-collapse: collapse;">
        <tr>
            <th>No</th>
            <th>Product Name</th>
            <th>Description</th>
            <th>Price</th>
        </tr>
        <s:iterator value="listProduct" status="stat"> <!--struct-tags-->
            <tr>
                <td><s:property value="#stat.count" /></td>  <%--#stat.count是指当前行是第几个而不是id值--%>
                <td><s:property value="name" /></td>
                <td><s:property value="description" /></td>
                <td><s:property value="price" /></td>
            </tr>
        </s:iterator>
    </table>
</div>
</body>
</html>


</textarea>
<div class="text">
<pre class="preText">
    spring
        - appContext.xml dao包下
</pre>

</div>
<textarea class="code">
    + appContext.xml

    <?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">

    <bean id="sessionFactory"
          class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="configLocation" value="file:F:\JAVA\20230925\sshMaven\src\main\java\hibernate.cfg.xml" /> <!---->
    </bean>

    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          destroy-method="close">
        <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />
        <property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl" />
        <property name="username" value="hyh" />
        <property name="password" value="123456" />
    </bean>

    <tx:annotation-driven /> <!--利用@Transactional注解来处理事务-->

    <bean id="transactionManager"
          class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
    </bean>

    <context:component-scan base-package="com.hyh"/>

</beans>

    ----------------------------------------------

    + dao包
        + 1
    public interface ProductDAO {
        List<Product> list();
    }

        + 2
    import com.hyh.dao.ProductDAO;
import com.hyh.pojo.Product;
import org.hibernate.Criteria;
import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository("productDAO")
public class ProductDAOImpl implements ProductDAO {
    @Autowired
    private SessionFactory sessionFactory;

    @Autowired
    public ProductDAOImpl(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    @Override
    @Transactional
    public List<Product> list() {
        @SuppressWarnings("unchecked") //unchecked是对编译器来说不可预知的错误 checked对编译器来说可以预知所以会强制捕获
        List<Product> listProduct = (List<Product>)
                sessionFactory.getCurrentSession().createCriteria(Product.class) // hibernate数据库操作会话通过元数据了解表结构后生成相应SQL
                        .setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY) // DISTINCT_ROOT_ENTITY代表了数据库中的DISTINCT
                        .list(); // 返回类型
        System.out.println(listProduct);
        return listProduct;
    }

}
</textarea>
<div class="text">
<pre class="preText">
    hibernate
        - hibernate.cfg.xml  Product.hbm.xml
</pre>
</div>
<textarea class="code">
    + .cfg.xml

    <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.hyh.pojo">
    <class name="Product" table="product"> <!--hibernate是面向对象的-->
        <id name="id" column="id"/>
        <property name="name" />
        <property name="description" />
        <property name="price" />
    </class>
</hibernate-mapping>

    ====================================

    + hbm.xml

    <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="com.hyh.pojo">
    <class name="Product" table="product"> <!--hibernate是面向对象的-->
        <id name="id" column="id"/>
        <property name="name" />
        <property name="description" />
        <property name="price" />
    </class>
</hibernate-mapping>
</textarea>
<div class="text">其它文件：log4j.properties  pom.xml</div>
<textarea class="code">
    + properties
# stdout | log对象 | 模式 控制台输出布局 样式
# 可以直接复制

# Global logging configuration
log4j.rootLogger=INFO, stdout
# MyBatis logging configuration...
log4j.logger.com.hyh=INFO
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
#log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n

    =================================
    + .xml

    <?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>sshMaven</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <org.springframework-version>4.1.4.RELEASE</org.springframework-version>
        <org.strutsframework-version>2.3.20</org.strutsframework-version>
        <org.hibernateframework-version>4.3.8.Final</org.hibernateframework-version>
        <org.mysqlconnector-version>5.1.34</org.mysqlconnector-version>
    </properties>

    <dependencies>
        <!--SPRING-->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>${org.springframework-version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context-support</artifactId>
            <version>${org.springframework-version}</version>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-orm</artifactId>
            <version>${org.springframework-version}</version>
            <type>jar</type>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>${org.springframework-version}</version> <!-- Replace with your Spring version -->
        </dependency>

        <!--STRUCTS-->
        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-core</artifactId>
            <version>${org.strutsframework-version}</version>
        </dependency>

        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-spring-plugin</artifactId>
            <version>${org.strutsframework-version}</version>
        </dependency>

        <!--ORM-->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>${org.hibernateframework-version}</version>
        </dependency>

        <!--DRUID-->
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.4</version> <!-- 根据需要指定Druid的版本 -->
        </dependency>

        <!-- Oracle 19c JDBC驱动 -->
        <dependency>
            <groupId>com.oracle.database.jdbc</groupId>
            <artifactId>ojdbc8</artifactId>
            <version>19.11.0.0</version> <!-- 根据您的Oracle版本选择合适的版本 -->
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>compile</scope>
        </dependency>

        <!--log4j-->
        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-api</artifactId>
            <version>2.14.1</version> <!-- Use the latest version available -->
        </dependency>

        <dependency>
            <groupId>org.apache.logging.log4j</groupId>
            <artifactId>log4j-core</artifactId>
            <version>2.14.1</version> <!-- Use the same version as log4j-api -->
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version> <!-- Use a suitable version -->
        </dependency>

    </dependencies>

</project>
</textarea>
<div class="text">
    <br><h4>2. ss(h)m</h4><br>
<pre class="preText">
    SS(H)M不是一个广泛使用的术语，没有明确的定义。它可能是指Struts2 + Spring + Hibernate + MyBatis的组合，但这种组合通常不常见，因为MyBatis和Hibernate都是用于数据库访问的持久化框架，通常情况下不会同时使用。

    ** 关于aop cannot find method的报错：需要删除out里面的spring-dao 因为out里面的包都是我自己放进去的 【但是】还是不行，只能删除artifact重新构建就可了

    - 结合上面的内容可以搭建出添加了使用mybatis获取数据的类并结合的sshm
        + 使用到的文件有(上面都有)
            - DruidDataSource TransactionFactoryImpl
            - 需要注意Maven结构中的一下文件都在resources里面
                - db.properties
                - mybatis-config.xml *里面对Mapper的路径直接改为文件名，因为Mapper现在直接在resources文件夹内
                - TestInterfaceMapper.xml *涉及到的数据类型都改为了Product

    - ProductDao和ProductDaoImpl添加了以下内容
</pre>
</div>
<textarea class="code">
    + interface
    List<Product> mybatisList();

    + implementation
    @Override
    @Transactional
    public List<Product> mybatisList() {
        SqlSessionFactory factory = giveFactory();
        SqlSession sqlSession = factory.openSession();
        List<Product> productList = sqlSession.getMapper(ProductDAO.class).mybatisList();
        return productList;
    }

    public SqlSessionFactory giveFactory() { //启用mybatis配置文件
        SqlSessionFactory factory = null;
        try {
            InputStream inputStream = Resources.getResourceAsStream("mybatis-config.xml"); //使用
            factory = new SqlSessionFactoryBuilder().build(inputStream);
            inputStream.close();
        } catch (IOException exception) {
            exception.printStackTrace();
        }

        factory.getConfiguration().setDatabaseId("oracle"); //set database type
        System.out.println(factory.getConfiguration().getDatabaseId());

        return factory;
    }
</textarea>
<div class="text">
<pre>
    + 在structAction包里添加了以下ListProductMybatisAction类并在struts.xml里添加了以下dispatcher:
        <action name="mybatis" class="com.hyh.structAction.ListProductMybatisAction" method="execute">
            <result name="success">/WEB-INF/views/ProductListMybatis.jsp</result>
        </action>
</pre>
</div>
<textarea class="code">
    + ListProductMybatisAction
import com.hyh.dao.ProductDAO;
import com.hyh.pojo.Product;
import com.opensymphony.xwork2.ActionSupport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service("listProductMybatisActionBean")
public class ListProductMybatisAction extends ActionSupport {
    @Autowired
    private ProductDAO productDAO;
    private List<Product> productList;

    @Autowired
    public void setProductDAO(ProductDAO productDAO) { // spring通过setter注入
        this.productDAO = productDAO;
    }

    @Override
    public String execute() {
        productList = productDAO.mybatisList();
        return SUCCESS;
    }

    public List<Product> getProductList() { // JSP通过get获取
        return productList;
    }
}
</textarea>
<div class="text">views里面添加了ProductListMybatis.jsp页面</div>
<textarea class="code">
    <%@ taglib prefix="s" uri="/struts-tags" %>
<%--
  Created by IntelliJ IDEA.
  User: AJH41
  Date: 2023-10-09
  Time: 10:44 AM
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<div align="center">
    <table width="80%" border="1" style="border-collapse: collapse;">
        <tr>
            <th>No</th>
            <th>Product Name</th>
            <th>Description</th>
            <th>Price</th>
        </tr>
        <s:iterator value="productList" status="stat"> <!--struct-tags-->
            <tr>
                <td><s:property value="#stat.count" /></td>  <%--#stat.count是指当前行是第几个而不是id值--%>
                <td><s:property value="name" /></td>
                <td><s:property value="description" /></td>
                <td><s:property value="price" /></td>
            </tr>
        </s:iterator>
    </table>
</div></body>
</html>

</textarea>
<div class="text">
        <h3>事务</h3><br>
        ·在MyBatis中，Mapper.xml文件通常用于定义SQL映射和数据库操作。MyBatis不处理事务本身，而是依赖于外部的事务管理器来处理事务。<br>
        ·外部的事务管理器一般：为@Transactional注释，原因是sql语言对事务的处理无法单独调用，所以需要外部程序管理事务<br>
        @Transactional注解：这表示该方法应该在事务管理下运行，如果发生异常，则事务将被回滚。<br>
        <br>
        假设：每次执行事务，显示学生的名字和年龄，并且年龄+1。<br>
            -其它的都差不多，重点如下
    </div>
    <textarea class="code">
    @Override
    @Transactional
    public List<User> updateAge() {
        SqlSessionFactory factory = giveFactory();
        SqlSession sqlSession = factory.openSession();
        List<User> users = sqlSession.getMapper(ProductDAO.class).getAll();
        for (User u : users) {
            boolean re = sqlSession.getMapper(ProductDAO.class).update(u.getId(), u.getName(), u.getSex(), u.getAge() + 1);
            if (!re) {
                LOGGER.warn(() -> {
                    return "update fail UserId = " + u.getId();
                });
            }
        }
        sqlSession.commit();
        users = sqlSession.getMapper(ProductDAO.class).getAll();
        return users;
    }
    </textarea>
<div class="text">
    <h3>3.1.3 别名</h3><br>
<pre class="preText">
    翻译：我自己
    为了减少代码冗余，咱们添加了别名系统，你可以给你的类取个别名，是不是很厉害><

    当然你也可以让mybatis自己找别名，咱就是说，mybatis还是很智能的。
    啊啊，如果你的没有给它取别名也被关系，他会自动给孩子们取个别名，首字母小写开头。

    嗨，还有更多。我们给java的常用类都取了个默认别名，你看你看，但是大小写敏感，敏感也没办法嘛，名字太多了。
</pre>
    <img src="img/mybatis/listalias.png">
</div>
<textarea class="code">
    <configuration>
    <properties resource="db.properties"/>
    <settings> <!--settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定 活着就是恶心-->
        <setting name="logImpl" value="LOG4J"/>
        <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->
    </settings>
    <typeAliases>
        <typeAlias alias="MANAGER" type="com.hyh.transaction.impl.TransactionFactoryImpl"/>
        <package name="com.hyh.dataSourceFactoryImpl"/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="MANAGER">
                <property name="autoCommit" value="false"/>
            </transactionManager>
            <dataSource type="DRUID">
                <property name="driver" value="${oracle_driver}"/>
                <property name="url" value="${oracle_url}"/>
                <property name="username" value="${oracle_username}"/>
                <property name="password" value="${oracle_password}"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="TestInterfaceMapper.xml"/> <!--都只能在resources文件夹-->
    </mappers>
</configuration>

@Alias("DRUID")
// https://blog.csdn.net/m0_70031574/article/details/131947655
public class DruidDataSource implements DataSourceFactory { // java: illegal character: '\ufeff' remove BOM in File Editor and recreate file
</textarea>
<div class="text">
    <h3>3.1.4 类处理器</h3><br>
<pre class="preText">
    翻译：我自己
    每当你在preparedStatement设置参数或者结果集返回值的时候我们都会派出类处理器来处理数据类型：也就是说，哼哼，把它们变成java可以接受的数据类型。

    注意注意！3.4.5我们就可以默认支持JSR-310（一种时间与日期的接口）啦！
</pre>
    <br><h3>3.1.5 处理枚举</h3><br>
<pre class="preText">
    翻译总结：我自己
    你必须使用我们的org.apache.ibatis.type.EnumOrdinalTypeHandler or EnumTypeHandler来转换枚举类型。

    如果你用第一个的话就代表你想保留数字，就在mybatis-config.xml里添加啦，看：

        下方区域

    ww第二个就是保留值啦

    3.1.6 你可以修改返回数据的底层逻辑
    3.1.7 你可以在特定方法里使用插件
    3.1.9 你可以用id来初始化多个数据库
</pre>
</div>
<textarea class="code">
    <typeHandlers>
            <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler"
                         javaType="java.math.RoundingMode"/>
    </typeHandlers>
</textarea>










    <div class="text" style="color: white">
        <img src="img/mybatis/1.png">
        <img src="img/mybatis/2.png">
        <img src="img/mybatis/3.png">
        <img src="img/mybatis/4.png">
        <img src="img/mybatis/5.png">
        working on:<br>
        ssh/sshm
        属性大全做到dbcp removeAbandond还有c3p0
        关于1.中statementtype为prepared 还是 static 的设置区别<br>
        @的情况是否可以设置自增序列为id?<br>
        将log输出到文件<br>
        mapper对存储过程，视图，序列，触发器等的处理<br>
    </div>
    <script src="main.js"></script>
</body>
</html>