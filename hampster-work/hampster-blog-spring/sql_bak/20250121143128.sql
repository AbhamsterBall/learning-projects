/*
MySQL Backup
Database: hampster
Backup Time: 2025-01-21 14:31:36
*/

SET FOREIGN_KEY_CHECKS=0;
DROP TABLE IF EXISTS `hampster`.`blog`;
DROP TABLE IF EXISTS `hampster`.`blog_type`;
DROP TABLE IF EXISTS `hampster`.`user`;
CREATE TABLE `blog` (
  `b_id` int unsigned NOT NULL AUTO_INCREMENT,
  `b_type` int unsigned NOT NULL,
  `b_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `b_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `b_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`b_id`),
  KEY `b_type` (`b_type`),
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`b_type`) REFERENCES `blog_type` (`bt_id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `blog_type` (
  `bt_id` int unsigned NOT NULL AUTO_INCREMENT,
  `bt_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT '',
  PRIMARY KEY (`bt_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
CREATE TABLE `user` (
  `u_id` int unsigned NOT NULL AUTO_INCREMENT,
  `u_name` varchar(24) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `u_pass` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `u_mail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  `u_phone` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  `u_token` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`u_id`,`u_token`),
  UNIQUE KEY `uniq_token` (`u_token`),
  UNIQUE KEY `uniq_mail` (`u_mail`),
  UNIQUE KEY `uniq_phone` (`u_phone`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
BEGIN;
LOCK TABLES `hampster`.`blog` WRITE;
DELETE FROM `hampster`.`blog`;
INSERT INTO `hampster`.`blog` (`b_id`,`b_type`,`b_name`,`b_content`,`b_time`) VALUES (1, 1, 'Mybatis Generator', '## Mybatis Generator\r\n<pre class=\"preText\">\r\n    翻译与总结：HYH，只记录关键词，只有关键代码\r\n    MBG定义：\r\n        mybatis代码生成器 检测表来生成 减少设置对象和配置文件的工作量 生成简单的增删查改 join查询和存储对象还是要自己写\r\n    灵活性：根据不同的配置和语言生成不同风格的代码\r\n        配置：the \"targetRuntime\" attribute of a &lt;context&gt; element.\r\n        eg: Java or Kotlin code   MyBatis3 compatible XML\r\n                🔥 Java or Kotlin code可能生成4个类：\r\n                    PK + 除了BLOB以外的non-PK + BLOB + 增删查改的动态SQL\r\n                    = 它会自动生成相应的继承关系：层级关系可以设置 eg:一个表一个对象(domain object)\r\n                        domain object: represents a real-world entity or concept within a specific domain or problem space.\r\n                🔥 XML\r\n                    基础的增删查改语句包含：\r\n                        insert\r\n                        update by primary key\r\n                        update by example (using a dynamic where clause)\r\n                        delete by primary key\r\n                        delete by example (using a dynamic where clause)\r\n                        select by primary key\r\n                        select by example (using a dynamic where clause)\r\n                        count by example\r\n                    灵活可变：eg:如果没有主键，就没有根据主键更新的语句\r\n                🔥 可选：生成使用以上语句（对象）的类/接口\r\n        最新的配置不再需要xml\r\n    可用性：用于不同生产环境：an Ant task, or a Maven plugin, in a continuous build environment.\r\n        注意：\r\n        🔥 它会自动和旧文件合并，并且不覆盖原来的配置，所以你可以多次生成，只会覆盖之前自动生成的元素。\r\n        🔥 不会合并JAVA文件：可能覆盖旧的/用另外的名字生成新的，必须手动合并，除非是用了Eclipse插件\r\n        🔥 不会合并Kotlin文件：同上，但不支持Eclipse插件\r\n\r\n    Eclipse插件\r\n        可以自动合并并保存用户修改内容，需要要Eclipse编译器和AST walker\r\n            官方文档：<a href=\"https://marketplace.eclipse.org/content/mybatis-generator\"> https://marketplace.eclipse.org/content/mybatis-generator</a>\r\n\r\n    依赖：getColumns and getPrimaryKeys methods依赖于JDBC包\r\n    生成代码的依赖：\r\n        Mybatis / Mybatis dynamic sql\r\n    <table><tr class=\"thead\">\r\n\r\n        <th>Runtime</th>\r\n\r\n        <th>MyBatis Generator Version</th>\r\n\r\n        <th>MyBatis Version</th>\r\n\r\n        <th>MyBatis Dynamic SQL Version</th>\r\n    </tr>\r\n\r\n    <tr class=\"b\">\r\n\r\n        <td align=\"left\">MyBatis3, MyBatis3Simple</td>\r\n\r\n        <td>Any</td>\r\n\r\n        <td>3.0+</td>\r\n\r\n        <td>N/A</td>\r\n    </tr>\r\n\r\n    <tr class=\"a\">\r\n\r\n        <td align=\"left\">MyBatis3DynamicSQL</td>\r\n\r\n        <td>1.3.6 - 1.3.7</td>\r\n\r\n        <td>3.4.2+</td>\r\n\r\n        <td>1.1.0 - 1.2.1</td>\r\n    </tr>\r\n\r\n    <tr class=\"b\">\r\n\r\n        <td align=\"left\">MyBatis3DynamicSQL, MyBatis3Kotlin</td>\r\n\r\n        <td>1.4.0</td>\r\n\r\n        <td>3.4.2+</td>\r\n\r\n        <td>1.1.3+</td>\r\n    </tr>\r\n\r\n    <tr class=\"a\">\r\n\r\n        <td align=\"left\">MyBatis3DynamicSQL</td>\r\n\r\n        <td>1.4.1+</td>\r\n\r\n        <td>3.4.2+</td>\r\n\r\n        <td>1.3.1+</td>\r\n    </tr>\r\n\r\n    <tr class=\"b\">\r\n\r\n        <td align=\"left\">MyBatis3Kotlin</td>\r\n\r\n        <td>1.4.1+</td>\r\n\r\n        <td>3.4.2+</td>\r\n\r\n        <td>1.4.0+</td>\r\n    </tr>\r\n    </table>\r\n    支持与帮助：<a href=\"http://groups.google.com/group/mybatis-user\">http://groups.google.com/group/mybatis-user</a>\r\n    bug提交与需求上传：<a href=\"https://github.com/mybatis/generator/issues\">https://github.com/mybatis/generator/issues</a>\r\n</pre>\r\n ### 1.4.1更新\r\n- AliasableSqlTable将原本以对象为底层改为了以类为底层\r\n- AliasableSqlColumn从二级字段变为一级字段  \r\n        import foo.BarDynamicSqlSupport.Bar(对象).id -> import foo.BarDynamicSqlSupport.id(类)\r\n### 快速导航\r\n<pre class=\"preText\">\r\n    1.创建并generator配置文件\r\n    2.保存.xml文件\r\n    3.运行这样的cmd：\r\n         java -jar mybatis-generator-core-x.x.x.jar -configfile \\temp\\generatorConfig.xml -overwrite\r\n            = 如果你想要保存之前的文件，不要写-overwrite\r\n            = 没有该参数，新同名文件会生成独一无二的新名字\r\n    4.修改mybatis配置文件\r\n</pre>\r\n### MyBatis3DynamicSql: 以cmd方式启动 *里面有注意事项\r\n- 配置文件见 +myBatisGenerator/src/resources/MyBatis3DynamicSql.xml \r\n```\r\n<generatorConfiguration>\r\n    <context id=\"dsql\" targetRuntime=\"MyBatis3DynamicSql\">\r\n        <jdbcConnection driverClass=\"oracle.jdbc.driver.OracleDriver\"\r\n                        connectionURL=\"jdbc:oracle:thin:@localhost:1521:orcl\"\r\n                        userId=\"scott\"\r\n                        password=\"123456\"/>\r\n        <javaModelGenerator targetPackage=\"example.model\" targetProject=\"src/main/java\"/>\r\n        <javaClientGenerator targetPackage=\"example.mapper\" targetProject=\"src/main/java\"/>\r\n        <table schema=\"scott\" tableName=\"EMP\" /> <!--name the user(schema) for emp or it might match multiple tables-->\r\n    </context>\r\n</generatorConfiguration>\r\n```\r\n- 测试见Tests.testMyBatis3DynamicSQL() \r\n<textarea>\r\n```\r\nEmp emp = EmpDynamicSqlSupport.emp;\r\nSelectStatementProvider ssp = SqlBuilder.select(emp.allColumns()).from(emp).build().render(RenderingStrategies.MYBATIS3);\r\nList<example.model.Emp> emps = mapper.selectMany(ssp);\r\nemps.forEach(System.out::println);\r\n```\r\n</textarea>\r\n\r\n### MyBatis3DynamicSql: 以JAVA方式启动\r\n- 除了用JAVA启动外，MyBatis不仅可以使用XML配置，而且还可以使用全JAVA配置\r\n    - 内容模型结构：ModelType: 具有树状或者多层结构的为Hierarchical，没有层级叫Flat，自动识别叫Conditional\r\n        - 该模型来自于org.mybatis.generator.config.ModelType\r\n全JAVA配置(最简配置) + 具体Tests.configContextForMybatis3DynamicSQL\r\n<textarea>\r\n```\r\nContext c = new Context(ModelType.CONDITIONAL); //模型结构\r\n\r\nc.setId(\"configContextForMybatis3DynamicSQL\"); //必须设置ID否则报错\r\n\r\nc.setJdbcConnectionConfiguration(configJDBCConnection()); //可看github搜索，实际是创建需要的类并设置基础属性：driver url等\r\n\r\n...new JavaClientGeneratorConfiguration(): setPackage & Project\r\nc.setJavaClientGeneratorConfiguration(jcgc); //定义生成接口位置\r\n...new SqlMapGeneratorConfiguration(): Package\r\nc.setSqlMapGeneratorConfiguration(sqlMapper); //生成mapper\r\n...new JavaModelGeneratorConfiguration(): setPackage & Project\r\nc.setJavaModelGeneratorConfiguration(jmgc); //model\r\n\r\n...new TableConfiguration(c): setSchema & table\r\nc.addTableConfiguration(table);\r\n```\r\n</textarea>\r\n#### 以XML的方式配置如何启动\r\n<textarea>\r\n```\r\nConfiguration config = new ConfigurationParser(PROPERTIES, LIST).parseConfiguration(new File(\"FILE LOCATION\")); // 用解析器返回warning list\r\nDefaultShellCallback callback = new DefaultShellCallback(BOOLEAN); // 回调的时候是否覆盖旧文件\r\nMyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);\r\nmyBatisGenerator.generate([VERBOSE]PROGRESSCALLBACK); // 过程回调函数，VERBOSE回调函数可以返回调用过程\r\n```\r\n</textarea>\r\n\r\n· 执行的顺序为\r\n```：\r\n🔥 connect DB -> Introspect table -> generate record(table) class -> generate mapper interface -> save emp.java-empMapper.java-empDynamicSqlSupport.java\r\n```\r\n- ConfigurationParser可以加载属性文件，这些属性可以用在xml文件里，以${}的形式调用。\r\n    - 如果${}没有找到属性，就会以原样（包含${}）的方式传入值\r\n\r\n#### 以JAVA的方式配置如何启动\r\n```\r\nList<String> warnings = new ArrayList<String>();\r\nboolean overwrite = true;\r\nConfiguration config = new Configuration();\r\n\r\nconfig.addContext(configContextForMybatis3DynamicSQL()); //这里面的设置在前面全JAVA配置MBG\r\n\r\nDefaultShellCallback callback = new DefaultShellCallback(overwrite);\r\ngenerator = new MyBatisGenerator(config, callback, warnings);\r\ngenerator.generate(new VerboseProgressCallback());\r\n```\r\n\r\n### MyBatis3: 以JAVA方式启动\r\n- 配置文件与MyBatis3DynamicSql基本相同，特证句如下，完整代码在resources/MyBatis3.xml:\r\n```\r\n<javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"exampleM3.mapper\" targetProject=\"src/main/java\"/>\r\n```\r\n\r\n也就是说，它的特点是：生成的是xml mapper，而不是DynamicSqlSupport。\r\n\r\n- 使用该自动生成的例子如下：\r\n```\r\nEmpExampleM3 eem = new EmpExampleM3();\r\nEmpExampleM3.Criteria c = eem.createCriteria();\r\nc.andSalLessThan(new BigDecimal(10000));\r\n\r\nList<EmpM3> empM3s = mapperM3.selectByExample(eem);\r\n```\r\n\r\n** 唯一需要注意的是在maven结构下，使用xml构建只能使用mapper resources/url到文件的方式，其它方式maven根本不会动用resources下面的文件。\r\n\r\n### MyBatis3Simple: 以JAVA方式启动\r\n- 特点是：不生成接口实现，通过注解的方式实现功能，但是方法很少，但相对前面两种，它生成的方法使用起来也更简单。\r\n\r\n```\r\n<javaClientGenerator type=\"ANNOTATEDMAPPER\" targetPackage=\"exampleSimple.mapper\" targetProject=\"src/main/java\"/>\r\n```\r\n\r\n### MBG详细配置\r\n- table标签内部\r\n    - 属性domainObjectName是将表名转化为别的名字来生成类\r\n    - columnOverride标签用于覆盖原本的列名或者覆盖关闭了useActualColumnNames后被转换成JAVA式驼峰命名\r\n    - ignoreColumn标签用于忽略该列数据，不进行model及其它对象的生成\r\n    - [property属性]useActualColumnNames: 使用实际列名生成，如果为false，mybatis会尝试使用JAVA式驼峰命名法（例如将数据库式驼峰命名a_Column转化为aColumn），无论如何设置都可以被columnOverride覆盖\r\n    - generatedKey标签: DB2的特性，要求该列为主键且为自动生成列，帮助db2生成insert实现\r\n    - [columnOverride属性]jdbcType: 将该列成映射成JAVA里面的类型\r\n    - javaTypeResolver标签内部\r\n    - forceBigDecimals关闭：不再将例如mysql中decimal或numeric这种高精度类型的数据转换成BigDecimal，而是用Short, Integer, Long等整型替代，这样本来是decimal和numeric的数据更好处理。\r\n- java...Generator内部\r\n    - enableSubPackages: 他会将包名添加.schema，也就是添加该表所属的用户名\r\n    - trim: 它会将数据库返回的值进行trim，避免没有必要的空字符出现。\r\n    - 🔥 resources/MybatisDetailConfig.xml\r\n\r\n### MBG其它配置-context标签前\r\n- properties标签: 添加属性文件\r\n- classPathEntry标签：向目录里添加目录外文件，该文件会在以下条件加载\r\n    - 为了检查数据库而产生的JDBC驱动加载\r\n    - 为了检查被重写的方法是什么而在MBG的根目录下搜索时\r\n    - ☂️ 注意：当在加载继承MBG内部类或使用MBG内部接口的类的时候，这些外部文件不会加载，如果要在这两种类加载的时候使用外部文件，你必须将它们直接引入目录内，就像引入你的MBG文件一样（例如使用java -cp）\r\n- commentGenerator标签：自动注释，你也可以在里面实现自己的接口\r\n    - suppressAllComments: true不产生任何的注释\r\n    - suppressDate: true不产生任何日期\r\n    - addRemarkComments: true产生数据库自带的表或者列的注释\r\n    - dateFormat: 当suppressDate为false时，这里可以以DateFormat类规定的格式填入日期，例如MM-dd-yyyy mm:ss\r\n    - useLegacyGeneratedAnnotation: true则使用javax下的注解，否则使用jakarta下的注解\r\n- plugin:\r\n    - 和非MBGplugin(**需要在mybatis-config.xml里面声明**)的区别：生成MBG的时候执行（从接口的结构可以看出） | 执行SQL的时候执行\r\n    - 🔥 ProductListMybatis.jsp\r\n- 🔥 resources/MyBatisExtra.xml\r\n\r\n### 对于commentGenerator的额外说明\r\n1.addRemarkComments:\r\n    .首先需要在oracle里创建表或者列注释：\r\n```\r\ncomment on table emp is \'commentary\'; --表注释\r\ncomment on column emp.empno is \'eno comment\'; --列注释\r\n```\r\n> ..然后需要在jdbcConnection标签里打开remarksReporting\r\n\r\n2.仿照原生接口实现自己的接口，可以得知，原生接口的逻辑大概如下\r\n```\r\nif (!suppressAllComments) {\r\n    element.addJavaDocLine(\"/**\");\r\n    element.addJavaDocLine(suppressDate ? \"\" : (dateFormat != null ? dateFormat.format(new Date()) : new Date().toString()));\r\n    element.addJavaDocLine((element.getClass() == null ? \"NULL\" : element.getClass()) + \": \" + (table == null ? \"\" : table.getFullyQualifiedTable()) + \" \" +\r\n            (column == null ? \"\" : column.getActualColumnName()) + \" \" +\r\n            (b == null ? \"\" : \"deletable?\" + b.booleanValue())\r\n    ); //这里的三目运算符必须用括号括起来，否则还是会检查b.booleanValue()是否可执行，或者说没有成功识别到三目运算符\r\n    if (set != null)\r\n        set.forEach(i -> element.addJavaDocLine(i.getFullyQualifiedName()));\r\n    if (addRemarkComments) {\r\n        element.addJavaDocLine(\"tables: \" + (table == null ? \"none\" : table.getRemarks()) + \" cols: \" + (column == null ? \"none\" : column.getRemarks()));\r\n    }\r\n\r\n    element.addJavaDocLine(\"*/\");\r\n}\r\n\r\nif (element.getClass().getName().equals(Method.class.getName()) ||\r\n    element.getClass().getName().equals(Field.class.getName())) {\r\n    set.add(useLegacyGeneratedAnnotation ? new FullyQualifiedJavaType(\"javax.annotation.Generated\") : new FullyQualifiedJavaType(\"jakarta.annotation.Generated\"));\r\n    StringBuilder sb = new StringBuilder();\r\n    element.getJavaDocLines().forEach(i -> sb.append(i));\r\n    if (sb.length() > 5) element.addAnnotation(this.getGeneratedAnnotation(sb.substring(3, sb.toString().length() - 2)));\r\n}\r\n\r\n```\r\n+ CommentsImpl.java\r\n\r\nALTER TABLE partition_by_range ENABLE ROW MOVEMENT;\r\n\r\n### MBGDynamicSQL对数据的批处理: batchInsert\r\n```\r\nList<partition> records = Arrays.asList(new partition(...), new partition(...));\r\n\r\npartitionDynamicSqlSupport.partition par = partitionDynamicSqlSupport.partition;\r\nBatchInsert.Builder builder = new BatchInsert.Builder().withInsertStatement(SqlBuilder.insert(records).into(par).map(par.iiiddd).toProperty(\"iiiddd\").map(par.insertDate).toProperty(\"insertDate\").build().render(RenderingStrategies.MYBATIS3).getInsertStatement());\r\nbuilder = builder.withRecords(records);\r\nBatchInsert<partition> batchInsert = builder.build();\r\n\r\nbatchInsert.insertStatements().stream().forEach(mapperpartition::insert);\r\n\r\nsession.commit();\r\n```', '2024-05-22 21:58:24'),(2, 1, 'Mybatis Plus', '## Mybatis Plus\r\n### 所用包\r\n```\r\n- 搜索mybatis-plus in IDEA maven library 3.5.0\r\njsqlparser | mybatis | mybatis-plus | mybatis-plus-annotation | mybatis-plus-core | mybatis-plus-extension\r\n```\r\n- 版本号为：mybatis-plus 3.5.0 时才能解析BaseMapper\r\n    - 最新版本会一直让绑定Mapper，3.5.0版本不会让绑定mapper\r\n\r\n#### 消除笛卡尔积\r\n- \"消除笛卡尔积\" 是一种数据库查询和优化技术，用于减小数据库操作的开销，特别是在多表查询中。它有助于提高查询性能，减少不必要的数据传输和处理，同时减少数据库的负载。\r\n使用内连接（INNER JOIN）： 内连接只返回满足连接条件的行，而不是返回两个表的笛卡尔积。这样可以避免生成大量的中间数据。\r\n\r\n    - 使用索引： 确保您的数据库表上有适当的索引。索引可以加速连接操作，减小查询的执行时间。\r\n    - 限制结果集大小： 只检索您实际需要的数据，而不是所有行。可以使用WHERE子句来过滤结果集。\r\n    - 使用子查询： 使用子查询来限制每个表的数据，然后再连接它们。这可以减少连接的数据量。\r\n    - 使用分页和分块查询： 如果可能，只检索部分数据，以分批处理。\r\n\r\n### plus的注解\r\n\r\n- @Table(value=, scheme=, autoResultMap=, )\r\n- 如果生成类对字段名有直接修改，比如添加了前后缀\r\n    - @TableField(value=)\r\n    - @TableId(value=)\r\n        - byId必要注解\r\n\r\n### BaseMapper\r\n\r\n- BaseMapper包含的方法会和MGB生成的方法造成使用方法的冲突，必须要分开成两个类\r\n\r\n### IPage使用前提\r\n在@Configuration文件内加入\r\n\r\n```\r\n@PostConstruct //配置interceptor\r\npublic void addMyInterceptor() {\r\n    MybatisPlusInterceptor interceptor = mybatisPlusInterceptor();\r\n    sessionFactory.getConfiguration().addInterceptor(interceptor);\r\n}\r\n\r\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\r\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\r\n    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.ORACLE));\r\n    return interceptor;\r\n}\r\n```\r\n\r\n### MGB属性\r\n```\r\n<textarea>\r\n<table tableName=\"emp\" schema=\"scott\">\r\n    <columnRenamingRule searchString=\"^\" replaceString=\"emp_\"/> <!--^开头添加 会自动转换成emp后大写-->\r\n</table>\r\n</textarea>\r\n```\r\n- 取消bigdecimald的生成必须使用columnOverride，只设置JDBCTypeResolver forceBigDecimal是不够的\r\n- MGB里生成的insertMultiple方法返回的语句不符合ORACLE语法，试生成\r\n\r\n```\r\nString sql = empMultiRowInsertDSL.map(emp.empEmpno).toProperty(\"empEmpno\").\r\nmap(emp.empJob).toProperty(\"empJob\").\r\nmap(emp.empComm).toProperty(\"empComm\").\r\nmap(emp.empEname).toProperty(\"empEname\").\r\nmap(emp.empMgr).toProperty(\"empMgr\").\r\nmap(emp.empDeptno).toProperty(\"empDeptno\").\r\nmap(emp.empHiredate).toProperty(\"empHiredate\").\r\nmap(emp.empSal).toProperty(\"empSal\").build().render(RenderingStrategies.MYBATIS3).getInsertStatement();\r\n```\r\n\r\n*此时生成的语法为insert into xxx values (ROW), (ROW)..，但正确的语法应该为insert all into xxx values (ROW) into xxx values (ROW) select * from dual*\r\n    - 你可以认为oracle不显式地支持批量插入\r\n    - 如果一定要使用也不要使用同名的方法，自定义新的方法，不然可能冲突报错\r\n### 连接池补充\r\n关键配置\r\n_ | DBCP | C3P0 | DRUID\r\n-------|-------|-------|-------\r\n最小连接数|minldle(0)|miniPoolSize(3)|minldle(0)\r\n初始化连接数|innitialSize(0)|initialPoolSize(3)|initialSize\r\n最大连接数|maxTotal(8)|maxPoolSize(15)|maxActive(8)\r\n最大等待时间|maxWaitMillis(毫秒)|maxIdleTime(0秒)|maxWait(毫秒)\r\n\r\n<textarea>\r\n<https://blog.51cto.com/u_15553139/5205148>\r\n</textarea>\r\n- 基于上表重新总结：DBCP和C3P0属性上的最大区别在于C3P0没有maxIdle属性，也就是说不会手动设置最大空闲数，C3P0的空闲数是自动管理的。\r\n\r\n#### DRUID常用属性：initialSize maxActive maxIdle poolPreparedStatements maxOpenPreparedStatement\r\n    - poolPreparedStatements：经过实验发现，只有连接池有空闲（指current active < maxActive）时才会生成，否则没有机会生成\r\n\r\n### 遇到的问题于总结\r\n\r\n- autowired的数据在第一次类加载的时候拿不到，要等appContext加载完，下一次才可以拿到值\r\n- MBG生成的动态sql和mybatis xml可能造成冲突，也就说xml的内容最好自己写\r\n- @TableName(\"emp\") //com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: com.hyh.pojo.Emp Not Found TableInfoCache.\r\n- LambdaQueryWrapper只运行于com.baomidou.mybatisplus.spring.SqlSessionFactoryBean下\r\n- properties文件无法识别：修改文件类型为properties\r\n\r\n### 匿名函数的替代关系\r\n<textarea>\r\n```\r\nnew UnaryOperator<MultiRowInsertDSL<Emp>>() {\r\n    @Override\r\n    public MultiRowInsertDSL<Emp> apply(MultiRowInsertDSL<Emp> empMultiRowInsertDSL) {\r\n        return empMultiRowInsertDSL.map(emp.empEmpno).toProperty(\"empEmpno\").\r\n        map(emp.empJob).toProperty(\"empJob\").\r\n        map(emp.empComm).toProperty(\"empComm\").\r\n        map(emp.empEname).toProperty(\"empEname\").\r\n        map(emp.empMgr).toProperty(\"empMgr\").\r\n        map(emp.empDeptno).toProperty(\"empDeptno\").\r\n        map(emp.empHiredate).toProperty(\"empHiredate\").\r\n        map(emp.empSal).toProperty(\"empSal\");\r\n}\r\n```\r\n</textarea>\r\n\r\n=\r\n\r\n```\r\nc -> c.\r\nmap(emp.empEmpno).toProperty(\"empEmpno\").\r\nmap(emp.empJob).toProperty(\"empJob\").\r\nmap(emp.empComm).toProperty(\"empComm\").\r\nmap(emp.empEname).toProperty(\"empEname\").\r\nmap(emp.empMgr).toProperty(\"empMgr\").\r\nmap(emp.empDeptno).toProperty(\"empDeptno\").\r\nmap(emp.empHiredate).toProperty(\"empHiredate\").\r\nmap(emp.empSal).toProperty(\"empSal\")\r\n```\r\n\r\n### XML\r\n\r\n- 如果没有指定接口，collection里面可选项有collection, list\r\n\r\n### LOG4J\r\n\r\n```\r\n# Global logging configuration\r\nlog4j.rootLogger=INFO, file\r\n# MyBatis logging configuration...\r\nlog4j.logger.com.hyh=TRACE, file\r\nlog4j.log4j.Run=INFO, file\r\n# File output...\r\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\r\nlog4j.appender.file.DatePattern=\'.\'yyyy-MM-dd_hh-mm-ss\'.log\'\r\nlog4j.appender.file.File=logs/MBP\r\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.file.layout.ConversionPattern=%5p [%t] - %m%n\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n### SSM:(SPRING + MYBATIS + SPRING-SERVLET)\r\n- 扫包要在bean之后，否则会因为autowired不存在而失败', '2024-05-22 20:09:39'),(3, 1, 'Ajax | Vue', '## Ajax | Vue\r\nAjax（Asynchronous JavaScript and XML）是一种用于创建异步Web应用程序的技术，它允许在不刷新整个页面的情况下向服务器发送请求并接收响应。传递值或数据给服务器或从服务器接收数据的过程通常需要使用Ajax来实现。下面是使用Ajax传递值的一般步骤：\r\n\r\n1. 创建XMLHttpRequest对象：\r\n在JavaScript中，你可以创建一个XMLHttpRequest对象来与服务器通信。这是实现Ajax的基本步骤之一。\r\n\r\n```javascript\r\nvar xhr = new XMLHttpRequest();\r\n```\r\n\r\n2. 设置请求方法和URL：\r\n使用`xhr.open()`方法来指定HTTP请求的方法（例如，GET或POST）和要请求的URL。\r\n\r\n```javascript\r\nxhr.open(\"GET\", \"your_server_endpoint.php\", true);\r\n```\r\n\r\n3. 设置回调函数：\r\n你需要定义一个回调函数，以便在请求完成时处理服务器的响应数据。这个函数通常在`xhr.onload`事件中定义。\r\n\r\n```javascript\r\nxhr.onload = function() {\r\nif (xhr.status === 200) {\r\n// 在这里处理服务器响应数据\r\nvar response = xhr.responseText;\r\nconsole.log(response);\r\n}\r\n};\r\n```\r\n\r\n4. 发送请求：\r\n使用`xhr.send()`方法来发送请求。如果你需要向服务器传递数据，可以将数据作为参数传递给`send()`方法。\r\n\r\n```javascript\r\nxhr.send();\r\n```\r\n\r\n5. 传递值：\r\n如果你需要向服务器传递特定的值，可以在`xhr.send()`方法中传递数据，通常是作为查询字符串（GET请求）或请求体（POST请求）的一部分。例如：\r\n\r\n```javascript\r\nvar data = \"param1=value1&param2=value2\";\r\nxhr.send(data);\r\n```\r\n\r\n在服务器端，你需要处理这些传递的值并根据它们执行相应的操作。具体的服务器端处理方式取决于你使用的后端技术，如PHP、Node.js、Python等。\r\n\r\n这是使用Ajax传递值的基本步骤。根据你的具体需求和后端技术，你可能需要进行进一步的定制和处理。\r\n\r\n总的来说，如果使用jquery将会简单很多：\r\n```\r\n// function loadDoc() {\r\n//     var xhttp = new XMLHttpRequest();\r\n//     xhttp.onreadystatechange = function() {\r\n//         if (this.readyState == 4 && this.status == 200) {\r\n//             document.getElementById(\"demo\").innerHTML = this.responseText;\r\n//         }\r\n//     };\r\n//     xhttp.open(\"GET\", \"/values/text\", true);\r\n//     xhttp.send();\r\n// }\r\nfunction loadDoc() {\r\n    $.get(\"/values/text\", function(data) {\r\n        $(\"#demo\").html(data);\r\n    });\r\n}\r\n```\r\n### 注意\r\n- 内部application爆红：调整项目设置\r\n- session和request的地址永远不会变，变的是里面的数据\r\n\r\n### log4j\r\n- 无法set log file\r\n    - 添加改文件夹夹的写入权限\r\n    - 使用绝对路径\r\n- tomcat和测试文件同时执行可能让测试文件没有权限修改该文件，也就是文件被占用\r\n\r\n### 原子性\r\n这是因为 AtomicBoolean 使用了底层的 CPU 指令来实现这些操作，而不是简单的 Java 语言级别的同步。\r\n\r\nAtomicBoolean 的原子性基于 Java 中的 java.util.concurrent 包，该包提供了用于多线程编程的工具和类。它使用了底层的硬件支持，如 CAS（Compare and Swap）操作，以确保操作的原子性。\r\n\r\nCAS 是一种基本的原子操作，它可以用于更新一个变量的值，但仅在该变量的当前值等于一个期望值时才执行更新操作。如果当前值不等于期望值，CAS 操作会失败，并且不会执行更新。这确保了在多线程环境中，只有一个线程能够成功更新变量的值，其他线程会重试或等待。\r\n\r\n### VUE\r\n动态生成html似乎用vue比js和ajax快一万倍\r\n- vue中的箭头函数可用于捕获父域，忽略自己的域，从而保持变量的一致性，实现同步更新\r\n- :xxx语法为:xxx=\"\'expression\' + var + \'expression \'\"\r\n- html父标签要正确，否则无法映射相应关系\r\n- html form传值 必须要有name\r\n- $(() => {}) 页面加载后执行\r\n#### VUE数据定义\r\n- 如果处理列表或数组，可以定义为空数组\r\n- 如果处理单个对象，可以定义为空对象\r\n- html页面上输出的数据要检查是否为空，不为空才输出，这样可以等待数据拉取而不报错\r\n- 表单提交到VUE: @submit.prevent=\"updateRow\"\r\n```', '2024-05-22 20:09:53'),(4, 2, '继承', '## 继承\r\n### 遇到的问题与总结\r\n\r\n- 父子继承\r\n    - 对父类继承在super.__init__(参数)加参数\r\n    - *不能用逗号间隔来声明多个变量，用分号*\r\n- chatGPT代码排错\r\n    - 1.简化后帮改 2.查看原因', '2024-05-22 20:10:18'),(5, 1, 'Vue脚手架', '## Vue脚手架\r\n### RESTful风格\r\n- 资源（Resources）：在 REST 中，一切都被视为资源，例如文档、图像、视频、数据等。每个资源都有一个唯一的标识符（通常是URL）。\r\n- 表现层（Representation）：资源的状态可以以不同的表现形式呈现，如JSON、XML、HTML 等。客户端可以通过适当的表现形式来访问和操作资源。\r\n- 状态无关（Stateless）：每个请求客户端向服务器发出的请求都必须包含足够的信息，以便服务器能够理解该请求。服务器不应该依赖于客户端的上下文或状态信息。\r\n- 统一接口（Uniform Interface）：RESTful 系统应该具有一致的接口，以简化客户端的操作。这包括使用标准的HTTP方法（GET、POST、PUT、DELETE）来执行各种操作，并使用标准的状态码来表示操作结果。\r\n- 客户端-服务器分离（Client-Server Separation）：客户端和服务器应该是相互独立的，它们可以独立地进行演化和扩展，而不会相互影响。\r\n- 层次结构（Layered System）：RESTful 架构支持分层系统，其中每一层执行特定的功能。这种分层可以提高系统的可扩展性和性能。\r\n- 可缓存性（Caching）：RESTful 支持响应的缓存，从而减少对服务器的负载，提高性能。\r\n- 无状态（Stateless）：每个请求都应该包含足够的信息，服务器不应该保存客户端的上下文。这有助于简化服务器的实现，并提高可伸缩性。\r\n    - HTTP 方法中的 \"PUT\" 是一种用于更新或创建资源的方法。PUT 请求允许客户端指定要更新的资源的标识符，并提供新的资源表示，以替代现有资源或创建一个新资源。这是RESTful API中常见的操作之一。\r\n```\r\n~/.vuerc\r\n\r\n被保存的 preset 将会存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。\r\n```\r\n### cli的安装是分开的，包括vue add，如果要安装，要在特定目录下安装，且不选择权限限制多的C盘\r\n```\r\nPS F:\\> cd F:\\JAVA\\20231010\r\nPS F:\\JAVA\\20231010> vue create vue-hello\r\ndefault\r\nnpm\r\nPS F:\\JAVA\\20231010> cd vue-hello\r\nPS F:\\JAVA\\20231010\\vue-hello> npm run serve\r\n```\r\n- Polyfill: Polyfill（多数用法为复数形式：polyfills）是一种用于填补浏览器或JavaScript引擎中功能不支持或不完全支持的缺陷的代码。它的主要作用是在旧版本的浏览器或环境中模拟新的JavaScript特性、API或方法，以便使现代的JavaScript代码能够在这些环境中运行。\r\n### 一些特点\r\n- 通过~./vuerc管理配置，插件\r\n- 通过不同的更简便的语法使用html\r\n- 通过默认设置的方法加载CSS\r\n- webpack:\r\n    - Webpack 是一个开源的前端模块打包工具，它是现代前端开发中非常重要的工具之一。Webpack 的主要功能是将多个前端资源，如 JavaScript、CSS、图像等，打包成一个或多个静态文件，以便用于部署到生产环境。\r\n    - 链式的最大特点是使用方法构建，应用更加灵活\r\n- 变量：环境变量，客户端变量（只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到客户端侧的代码中。这是为了避免意外公开机器上可能具有相同名称的私钥）和本地变量（local）\r\n- 导出包使用\r\n- 组件注册\r\n- 异步 Web Components 组件：部分功能小入口组件\r\n- 根据不同的云平台进行部署\r\n- 保存preset配置，例如try，使用时\r\n- 添加插件 vue add xxxx\r\n```\r\nvue create my-new-project --preset try\r\n```\r\n* vue还可以使用vant创建\r\n#### 问题记录\r\n- ERROR Error loading vue.config.js: ERROR TypeError: defineConfig is not a function\r\n- 安装vue的url处理并导入包后项目报错无法打开\r\n    - npm install vue-file-upload --save  # 推测原因vue版本出现问题 -- 解决方式重新安装vue -- 因为vue的颜色不再改变\r\n- 无法上传文件\r\n    - 断点测试传来的文件为null: 原因之一：资料有问题 之二：查看F12Preview\r\n- 编译速度过慢\r\n    - 打开并行，增加heap size [ \"File\" > \"Settings\" > \"Build, Execution, Deployment\" > \"Compiler\" ]\r\n```\r\nnpm upgrade\r\n```\r\n- vue-cli无法正常打开：直接改自带的 hello\r\n- tomcat和vue-cli运行在不同端口上：tomcat支持跨域请求\r\n```\r\n<textarea>\r\n<filter>\r\n    <filter-name>CorsFilter</filter-name>\r\n    <filter-class>org.apache.catalina.filters.CorsFilter</filter-class>\r\n</filter>\r\n<filter-mapping>\r\n    <filter-name>CorsFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n</filter-mapping>\r\n</textarea>\r\n```\r\n- jquery引入：\r\n```\r\nnpm add jquery\r\n-----------------------\r\nimport $ from \'jquery\';\r\n```\r\n- 更换主页：框架Vue中的name属性需要和import中引用的名称一致，**否则不知道引入的是什么**\r\n- 测试**注意**：尝试清除浏览器缓存并重启开发服务器，以确保新的代码生效。\r\n```\r\nvue-cli-service build\r\n```\r\n会在 dist/ 目录产生一个可用于生产环境的包，带有 JS/CSS/HTML 的压缩，和为更好的缓存而做的自动的 vendor chunk splitting。它的 chunk manifest 会内联在 HTML 里。\r\n### 启动\r\n```\r\nnpx vue-cli-service serve\r\n```\r\n- 在生产环境下：运行 npm run build 命令，Vue CLI 将使用动态资源入口进行构建，并生成用于生产环境的文件。\r\n- 在开发环境下：运行 npm run serve 命令，Vue CLI 将使用静态资源入口，并启动开发服务器，以便你可以快速开发和调试静态资源。\r\n\r\n##### 跨域请求（Cross-Origin Request）\r\n指的是通过一个域名的网页去请求另一个域名下的资源的过程。当你的前端应用运行在一个域名（或端口）下，而需要从另一个域名的服务器上获取数据或资源时，浏览器会执行跨域请求。这是为了确保安全性，以防止潜在的恶意跨域请求。\r\n```\r\npublic class CorsFilterServlet extends HttpServlet {\r\n@Override\r\nprotected void doOptions(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n    ...\r\n}\r\n}\r\n```\r\n\r\n### 整合\r\n使用Tomcat和Spring作为后端，以及Vue.js作为前端，你可以实现后端数据提供、前端数据获取，并实现动态和静态资源分离的完整Web应用程序。这是一种常见的Web应用程序架构，通常被称为\"前后端分离\"。\r\n\r\n#### ajax库\r\nvue中常见的ajax库有：\r\n- axios (流行且广泛使用)\r\n- vue-resource\r\n- fetch API\r\n- jQuery\r\n\r\n<textarea><https://vuejsdevelopers.com/2017/08/28/vue-js-ajax-recipes/></textarea>\r\n\r\n### ROUTER\r\n<textarea><https://router.vuejs.org/installation.html></textarea>\r\n\r\n### 信息孤岛\r\n- 数据孤立：数据存储在不同的系统、应用程序或组织中，由于缺乏互操作性或数据标准，这些数据无法被整合或共享。\r\n- 技术障碍：技术限制或不适当的技术工具可能导致信息孤岛问题，使信息难以获取或共享。\r\n- 组织文化：某些组织内部的文化和结构问题可能导致信息孤岛问题，因为不同部门或团队之间不愿意共享信息。\r\n\r\n### 多文件上传下载\r\n- 添加包：\r\n    - commons-fileupload\r\n    - commons-io **该报错信息可以F12 -> Network -> RED PACKAGE -> Preview**\r\n<textarea>\r\n在Web应用程序中实现多文件上传和下载通常涉及到服务器端和客户端的代码。下面我将为你提供一个简单的示例，展示如何在一个典型的Vue.js前端应用和Node.js后端服务器中实现多文件上传和下载。\r\n\r\n**多文件上传（前端部分 - Vue.js）：**\r\n\r\n1. 在Vue组件中，添加一个HTML表单元素用于文件上传，通常包括一个`<input type=\"file\">`元素，可以处理多个文件：\r\n\r\n```\r\n<template>\r\n  <div>\r\n    <form method=\"post\" @submit.prevent=\"uploadFiles\" enctype=\"multipart/form-data\">\r\n      <input type=\"file\" ref=\"fileInput\" multiple>\r\n      <input type=\"submit\" value=\"提交\"/>\r\n    </form>\r\n\r\n    <span id=\"re\"></span>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n// import $ from \'jquery\';\r\nimport axios from \'axios\';\r\nexport default {\r\n  name: \"uploadComp\",\r\n  methods: {\r\n    async uploadFiles() {\r\n      const files = this.$refs.fileInput.files;\r\n      const formData = new FormData();\r\n\r\n      for (let i = 0; i < files.length; i++) {\r\n        formData.append(\"files\", files[i]);\r\n      }\r\n\r\n      try {\r\n        let response = await axios\r\n            .post(\"http://localhost:8080/return/upload\", formData, {\r\n              \"Content-Type\": \"multipart/form-data;charset=utf-8\",\r\n            })\r\n            .then((res) => {\r\n              return res.data.data;\r\n            })\r\n            .catch((error) => {\r\n              console.error(\"上传失败\", error);\r\n            });\r\n\r\n        // console.log(response);\r\n        // 处理服务器的响应\r\n      } catch (error) {\r\n        console.error(\"上传失败\", error);\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n2. 在`uploadFiles`方法中，我们获取文件的引用，并使用`FormData`对象创建一个包含所有文件的表单数据。然后，你可以使用HTTP库（如Axios）将FormData对象发送到服务器。\r\n\r\n**多文件上传（后端部分 - SSM）：**\r\n\r\n1. 在Node.js服务器端，你可以使用Express.js作为服务器框架，来处理文件上传请求：\r\n\r\n```java\r\nString s = \"上传成功\";\r\nfor (MultipartFile file : files) {\r\n    String classpath = \"F:\\\\JAVA\\\\20231010\\\\ssmAjax_vue\\\\test\";\r\n    File f = new File(classpath + \"\\\\uploaded\", file.getOriginalFilename());\r\n    System.out.println(f.getAbsolutePath());\r\n\r\n    try {\r\n        if (!f.getParentFile().exists()) f.getParentFile().mkdirs();\r\n        if (!f.exists()) f.createNewFile();\r\n\r\n        file.transferTo(f);\r\n    } catch (IOException e) {\r\n        s = \"上传失败\";\r\n        e.printStackTrace();\r\n    }\r\n}\r\n```\r\n\r\n**文件下载：**\r\n\r\nnpm install --save-dev copy-webpack-plugin\r\n- 文件下载的时候无法识别文件名，不能使用PathVariable要用RequestParam否则可能会忽略.之后的值\r\n- 多文件下载：要允许弹窗\r\n\r\n##### 前端\r\n```\r\nfor (let index in files) {\r\n        try {\r\n          window.open(\"http://localhost:8080/download?file=\" + files[index])\r\n\r\n          $(\"#re\").html(\"下载成功\")\r\n          setTimeout(() => {\r\n            $(\"#re\").html(\"\")\r\n          }, 3000)\r\n        } catch (error) {\r\n          $(\"#re\").html(error)\r\n          console.log(error)\r\n        }\r\n      }\r\n```\r\n##### 后端\r\n```\r\nString s = \"下载成功\";\r\nFile f = new File(currentPath + innerUploadPath + file);\r\n\r\ntry {\r\n    if (f.exists()) {\r\n        rs.setContentType(\"multipart/form-data\");\r\n        rs.setCharacterEncoding(\"utf-8\");\r\n        rs.setHeader(\"Content-Disposition\", \"attachment;filename=\" + f.getName());\r\n\r\n        // 读取文件内容并写入响应输出流\r\n        FileInputStream fileInputStream = new FileInputStream(f);\r\n        ServletOutputStream out = rs.getOutputStream();\r\n        rs.setCharacterEncoding(\"UTF-8\");\r\n        byte[] buffer = new byte[4096];\r\n        int bytesRead;\r\n        while ((bytesRead = fileInputStream.read(buffer)) != -1) {\r\n            out.write(buffer, 0, bytesRead);\r\n        }\r\n\r\n        fileInputStream.close();\r\n        out.flush();\r\n        out.close();\r\n    }\r\n} catch (Exception e) {\r\n    s = \"下载失败：\" + e.getCause().getMessage();\r\n    System.out.println(\"用户选择\");\r\n}\r\n```\r\n### Spring Boot\r\n- 自动配置：Spring Boot提供了许多自动配置类，可以根据项目的依赖和需求自动配置Spring应用程序的各个方面，如数据源、Web服务器、安全等。这些配置类通常在Spring Boot的启动类上使用@SpringBootApplication注解来启用。\r\n- 类路径扫描：Spring Boot会自动扫描应用程序的类路径，查找标有@Component、@Service、@Repository等注解的Bean，并将它们注册到Spring容器。\r\n- 外部化配置：Spring Boot支持将应用程序的配置从application.properties或application.yml文件中加载。你可以在这些配置文件中定义应用程序的属性，而不需要显式配置Bean。Spring Boot会自动加载这些属性并应用它们。\r\n- 注解驱动（**不使用**）：Spring Boot鼓励使用注解来配置Bean、依赖注入和其他Spring功能，而不需要XML配置文件。\r\n\r\n- **优势**：使用springBoot之后可以不再创建web，springboot会帮你创建\r\n\r\n- 所用包\r\n    - assertj-core\r\n    - commons-fileupload\r\n    - gson\r\n    - hamcrest\r\n    - jakarta.annotation\r\n    - jakarta.xml.bind-api\r\n    - junit-jupiter\r\n    - mockito-junit-jupiter-3.1.0.jar\r\n    - spring-boot-2.2.5.RELEASE.jar\r\n    spring-boot-autoconfigure-2.2.5.RELEASE.jar\r\n    spring-boot-starter-2.2.5.RELEASE.jar\r\n    spring-boot-starter-json-2.2.5.RELEASE.jar\r\n    spring-boot-starter-logging-2.2.5.RELEASE.jar\r\n    spring-boot-starter-test-2.2.5.RELEASE.jar\r\n    spring-boot-starter-tomcat-2.2.5.RELEASE.jar\r\n    spring-boot-starter-validation-2.2.5.RELEASE.jar\r\n    spring-boot-starter-web-2.2.5.RELEASE.jar\r\n    spring-boot-test-2.2.5.RELEASE.jar\r\n    tomcat-annotations-api-9.0.48.jar\r\n    tomcat-api-9.0.48.jar\r\n    tomcat-catalina-9.0.48.jar\r\n    tomcat-coyote-9.0.48.jar\r\n    tomcat-el-api-9.0.48.jar\r\n    tomcat-embed-core-9.0.31.jar\r\n    tomcat-embed-el-9.0.31.jar\r\n    tomcat-embed-websocket-9.0.31.jar\r\n    tomcat-jaspic-api-9.0.48.jar\r\n    tomcat-jni-9.0.48.jar\r\n    tomcat-jsp-api-9.0.48.jar\r\n    tomcat-juli-9.0.48.jar\r\n    tomcat-servlet-api-9.0.48.jar\r\n    tomcat-util-9.0.48.jar\r\n    tomcat-util-scan-9.0.48.jar\r\n    xmlunit-core-2.6.3.jar\r\n    spring-test-5.2.4.RELEASE.jar\r\n- maven\r\n    <dependency>\r\n            <groupId>org.apache.tomcat</groupId>\r\n            <artifactId>tomcat-catalina</artifactId>\r\n            <version>9.0.48</version> <!-- 使用你需要的 Tomcat 版本 -->\r\n<!--            <scope>provided</scope> &lt;!&ndash; provided 表示在运行时由容器提供 &ndash;&gt;-->\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>commons-fileupload</groupId>\r\n            <artifactId>commons-fileupload</artifactId>\r\n            <version>1.4</version> <!-- 使用你需要的版本 -->\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.google.code.gson</groupId>\r\n            <artifactId>gson</artifactId>\r\n            <version>2.8.6</version> <!-- Use the version that includes setLenient() -->\r\n        </dependency>\r\n    <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter</artifactId>\r\n            <version>2.2.5.RELEASE</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <version>2.2.5.RELEASE</version>\r\n<!--            <scope>test</scope>-->\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n            <version>2.2.5.RELEASE</version>\r\n        </dependency>\r\n\r\n#### Spring Boot启动示例\r\n```\r\n@SpringBootApplication\r\npublic class Boot {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(Config.class, args);\r\n    }\r\n}\r\n```\r\n- config dataSource等参数的平替\r\n```\r\n@Configuration\r\n@ComponentScan(\"com.hyh\")\r\npublic class Config extends WebMvcConfigurerAdapter {\r\n    @Bean(name = \"dataSource\")\r\n    @ConfigurationProperties(prefix = \"spring.datasource\")\r\n    public DataSource dataSource() {\r\n        DruidDataSource druidDataSource = new DruidDataSource();\r\n        druidDataSource.setUrl(\"jdbc:oracle:thin:@localhost:1521:orcl\");\r\n        druidDataSource.setDriverClassName(\"oracle.jdbc.driver.OracleDriver\");\r\n        druidDataSource.setUsername(\"scott\");\r\n        druidDataSource.setPassword(\"123456\");\r\n        return druidDataSource;\r\n    }\r\n\r\n    @Bean(name = \"sessionFactory\")\r\n    public MybatisSqlSessionFactoryBean sessionFactory(DataSource dataSource) {\r\n        MybatisSqlSessionFactoryBean sessionFactory = new MybatisSqlSessionFactoryBean();\r\n        sessionFactory.setDataSource(dataSource);\r\n        sessionFactory.setConfigLocation(new ClassPathResource(\"mybatis-config.xml\"));\r\n        sessionFactory.setTypeAliasesPackage(\"com.hyh.model\");\r\n        return sessionFactory;\r\n    }\r\n\r\n    @Bean(name = \"mapperScanner\")\r\n    public MapperScannerConfigurer mapperScanner(MybatisSqlSessionFactoryBean sessionFactory) {\r\n        MapperScannerConfigurer mapperScanner = new MapperScannerConfigurer();\r\n        mapperScanner.setSqlSessionFactoryBeanName(\"sessionFactory\");\r\n        mapperScanner.setBasePackage(\"com.hyh.mapper\");\r\n        return mapperScanner;\r\n    }\r\n\r\n    @Bean\r\n    public ServletWebServerFactory servletContainer() {\r\n        TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();\r\n        // 在这里可以进行额外的配置\r\n        // factory.setPort(8080);\r\n        return factory;\r\n    }\r\n\r\n    @Override\r\n    public void addCorsMappings(CorsRegistry registry) {\r\n        registry.addMapping(\"/**\")\r\n                .allowedOrigins(\"http://localhost:8081\")\r\n                .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\r\n                .allowCredentials(true)\r\n                .maxAge(3600);\r\n    }\r\n}\r\n```\r\n#### 拦截器\r\n- 为什么多文件的上传和下载要使用拦截器：\r\n多文件的上传下载要使用拦截器是因为拦截器可以拦截HTTP请求和响应，并在请求到达控制器之前或之后执行一些操作，例如身份验证、日志记录、响应缓存等。对于多文件上传下载，使用拦截器可以方便地添加额外的功能，例如检查文件类型、大小、权限等，或者在文件上传下载完成后进行清理、统计等操作。\r\n另外，拦截器还可以用于实现一些通用的功能，例如记录请求和响应的信息、处理异常等。通过使用拦截器，可以将这些通用的功能封装起来，避免在每个控制器方法中重复编写代码。\r\n总之，使用拦截器可以方便地添加额外的功能和实现一些通用的操作，提高代码的可维护性和可重用性。\r\n\r\n##### 简单示例：检测session不允许访问\r\n    @Around(\"this(com.hyh.controller.UploadController)\") //* class的通配符\r\n    public Object restrainBeforeUpload(ProceedingJoinPoint jp) throws Throwable {\r\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();\r\n        HttpSession session = request.getSession();\r\n\r\n        if (session.getAttribute(\"hello\") != null)\r\n            return jp.proceed();\r\n        else\r\n            return null;\r\n    }\r\n\r\n#### 静态对象\r\n    public static void main(String[] args) { // 这里面创建的对象是静态对象，也只有这里面的对象可以调用静态方法且地址不同\r\n        MyClass myObject1 = new MyClass();\r\n        MyClass myObject2 = new MyClass();\r\n    }\r\n\r\n#### tomcat快速重启\r\n    edit-configuration -> on update -> hot swap classes\r\n\r\n#### 获取本机ip\r\n```\r\n        String hostIp = \"\";\r\n\r\n        try {\r\n            Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\r\n            while (interfaces.hasMoreElements()) {\r\n                NetworkInterface iface = interfaces.nextElement();\r\n                if (iface.isLoopback() || !iface.isUp()) {\r\n                    continue;\r\n                }\r\n\r\n                Enumeration<InetAddress> addresses = iface.getInetAddresses();\r\n                while (addresses.hasMoreElements()) {\r\n                    InetAddress addr = addresses.nextElement();\r\n                    if (iface.getDisplayName().contains(\"Intel(R) Wireless-AC 9560 160MHz\")\r\n                    && addr.getHostAddress().split(\"\\\\.\").length == 4) {\r\n                        hostIp = addr.getHostAddress();\r\n                    }\r\n\r\n                }\r\n            }\r\n        } catch (SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n### 关键词\r\n> head, header', '2024-12-15 18:24:22'),(6, 1, 'Solr AliPay Xml Stream Vue3响应式', '## Solr AliPay Xml Stream Vue3响应式\r\n- 访问 Apache Solr 官网，下载\r\n- 进入bin，执行: `solr [re]start -p 8983`\r\n- 访问：<http://localhost:8983/solr/>\r\n- 创建核心：`solr create -c CDataCore`\r\n- <https://juejin.cn/post/6850418112488996871>\r\n- 导入mysql jar包\r\n\r\n##### 使用示例\r\n```\r\n        // Solr 服务器的地址，替换成你自己的 Solr 地址\r\n        String solrUrl = \"http://localhost:8983/solr/CDataCore\";\r\n\r\n        // 创建 SolrClient 对象\r\n        SolrClient solr = new HttpSolrClient.Builder(solrUrl).build();\r\n\r\n        // 构建 Solr 查询\r\n        SolrQuery query = new SolrQuery();\r\n        query.setQuery(\"*:*\"); // 查询所有文档，可以替换成你的具体查询条件\r\n        query.setRows(10); // 设置返回结果的行数\r\n\r\n        try {\r\n            // 执行查询\r\n            QueryResponse response = solr.query(query);\r\n\r\n            // 获取查询结果\r\n            SolrDocumentList results = response.getResults();\r\n\r\n            // 处理查询结果\r\n            for (SolrDocument document : results) {\r\n                // 可以根据需要获取字段值\r\n                String id = (String) document.getFieldValue(\"id\");\r\n                String title = \"\";\r\n\r\n                title = (String) document.getFieldValue(\"sname\");\r\n\r\n                // 在这里处理获取到的字段值\r\n                System.out.println(\"ID: \" + id + \", Title: \" + title);\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            // 关闭 SolrClient 连接\r\n            try {\r\n                solr.close();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n```\r\n\r\n### 支付宝\r\n<https://blog.csdn.net/weixin_45394086/article/details/121843483>\r\n<https://zhuanlan.zhihu.com/p/596771147>具体见git项目leetcode -> tries -> springboot模块\r\n\r\n#### xml文件处理\r\nxml\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<library>\r\n    <book id=\"001\">\r\n        <title>Java Programming</title>\r\n        <author>John Doe</author>\r\n        <genre>Programming</genre>\r\n    </book>\r\n    <book id=\"002\">\r\n        <title>Data Structures and Algorithms</title>\r\n        <author>Jane Smith</author>\r\n        <genre>Computer Science</genre>\r\n    </book>\r\n</library>\r\n```\r\n```\r\ntry {\r\n            // 指定要解析的 XML 文件路径\r\n            File inputFile = new File(\"src\\\\main\\\\java\\\\tries\\\\xml\\\\test.xml\");\r\n\r\n            // 创建一个 DocumentBuilderFactory 实例\r\n            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\r\n\r\n            // 创建一个 DocumentBuilder 实例，用于构建 Document 对象\r\n            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();\r\n\r\n            // 使用 DocumentBuilder 解析 XML 文件，得到一个表示整个 XML 文档的 Document 对象\r\n            Document doc = dBuilder.parse(inputFile);\r\n\r\n            // 对文档进行标准化，使其易于处理\r\n            doc.getDocumentElement().normalize();\r\n\r\n            // 打印根元素的名称\r\n            System.out.println(\"Root element: \" + doc.getDocumentElement().getNodeName());\r\n\r\n            // 获取文档中所有名为 \"book\" 的元素\r\n            NodeList bookList = doc.getElementsByTagName(\"book\");\r\n\r\n            // 循环遍历所有 \"book\" 元素\r\n            for (int temp = 0; temp < bookList.getLength(); temp++) {\r\n                // 获取当前遍历到的 \"book\" 元素\r\n                Node bookNode = bookList.item(temp);\r\n\r\n                // 确保当前节点是元素节点\r\n                if (bookNode.getNodeType() == Node.ELEMENT_NODE) {\r\n                    // 将当前节点转换为 Element 类型\r\n                    Element bookElement = (Element) bookNode;\r\n\r\n                    // 输出当前书籍的 ID\r\n                    System.out.println(\"\\nBook ID: \" + bookElement.getAttribute(\"id\"));\r\n\r\n                    // 输出当前书籍的标题\r\n                    System.out.println(\"Title: \" + bookElement.getElementsByTagName(\"title\").item(0).getTextContent());\r\n\r\n                    // 输出当前书籍的作者\r\n                    System.out.println(\"Author: \" + bookElement.getElementsByTagName(\"author\").item(0).getTextContent());\r\n\r\n                    // 输出当前书籍的流派\r\n                    System.out.println(\"Genre: \" + bookElement.getElementsByTagName(\"genre\").item(0).getTextContent());\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            // 捕获可能出现的异常并打印异常信息\r\n            e.printStackTrace();\r\n        }\r\n```\r\n\r\n#### 通过会话和消息对象发送邮件示例 tries leetcode 加载动画\r\n```\r\n public String sendMail(String mail) {\r\n        // 配置邮件服务器属性\r\n        Properties properties = new Properties();\r\n        properties.put(\"mail.smtp.host\", \"smtp.163.com\"); // 设置 SMTP 服务器\r\n        properties.put(\"mail.smtp.port\", \"465\"); // 设置 SMTP 端口（一般为 25 或 465）\r\n        properties.put(\"mail.smtp.auth\", \"true\"); // 启用身份验证\r\n        properties.put(\"mail.smtp.ssl.enable\", \"true\"); // 使用 SSL 加密\r\n\r\n        // 设置发送邮件的账户信息\r\n        final String username = \"yysxiaohao201802@163.com\";\r\n        final String password = \"TRRNKSJQSXZQOLAL\"; // 或者是授权码，根据你的邮箱提供商而定\r\n\r\n        // 创建会话对象\r\n        Session session = Session.getInstance(properties, new Authenticator() {\r\n            @Override\r\n            protected PasswordAuthentication getPasswordAuthentication() {\r\n                final PasswordAuthentication passwordAuthentication = new PasswordAuthentication(username,\r\n                        password);\r\n                return passwordAuthentication;\r\n            }\r\n        });\r\n\r\n        StringBuilder code = new StringBuilder();\r\n\r\n        try {\r\n            // 创建消息对象\r\n            Message message = new MimeMessage(session);\r\n\r\n            // 设置发件人\r\n            message.setFrom(new InternetAddress(username));\r\n\r\n            // 设置收件人\r\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(mail));\r\n\r\n            String characters = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n            int length = 6;\r\n\r\n            Random random = new Random();\r\n\r\n            for (int i = 0; i < length; i++) {\r\n                int index = random.nextInt(characters.length());\r\n                code.append(characters.charAt(index));\r\n            }\r\n\r\n            // 设置邮件主题\r\n            message.setSubject(\"这是您的验证码\");\r\n\r\n            // 设置邮件内容\r\n            message.setText(\"验证码：\" + code);\r\n\r\n            // 发送邮件\r\n            Transport.send(message);\r\n            System.out.println(\"邮件发送成功！\");\r\n        } catch (MessagingException e) {\r\n            e.printStackTrace();\r\n            System.out.println(\"邮件发送失败：\" + e.getMessage());\r\n        }\r\n\r\n        return code.toString();\r\n    }\r\n```\r\n\r\n#### Stream java 1.8\r\n<https://blog.csdn.net/m0_63364103/article/details/130136467>\r\n\r\n目的：用于计算，不保存数据\r\n\r\n- BaseStream：基础接口，声明了流管理的核心方法；\r\n\r\n- Stream：核心接口，声明了流操作的核心方法，其他接口为指定类型的适配\r\n\r\n1.普通使用\r\n\r\n2.中间操作符，懒惰式设计: 对于数据的计算只有需要的时候才执行\r\n\r\n示例：[stream对文件 集合的操作和stream基于数据处理的化简 以及stream对于线程的处理]\r\n```\r\npackage tries.stream;\r\n\r\nimport org.apache.solr.common.util.ContentStreamBase;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.*;\r\nimport java.util.function.BinaryOperator;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\npublic class TestStream {\r\n\r\n    @Test\r\n    public void streamFromList () {\r\n        Stream<Integer> stream1 = Stream.of(1, 2, 3, 4, 5);\r\n        stream1.forEach(System.out::println);\r\n\r\n        List<Integer> integerList = Arrays.asList(new Integer[]{1, 2, 3, 4, 5});\r\n        Stream<Integer> listStream = integerList.stream();\r\n        listStream.forEach(System.out::println);\r\n    }\r\n\r\n    @Test\r\n    public void streamFromArray() {\r\n        int[] intArr = {1, 2, 3, 4, 5};\r\n        IntStream arrayStream = Arrays.stream(intArr);\r\n        arrayStream.forEach(System.out::println);\r\n    }\r\n\r\n    @Test\r\n    public void readFileLines() {\r\n        try {\r\n            Stream<String> fileStream = Files.lines(\r\n                    Paths.get(\"F:\\\\JAVA\\\\20231010\\\\LeetCode\\\\src\\\\main\\\\java\\\\tries\\\\stream\\\\data.txt\"),\r\n                    Charset.defaultCharset());\r\n            fileStream.forEach(System.out::println);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void createFunction() {\r\n        Stream<Integer> iterateStream = Stream.iterate(0, n -> n + 2).limit(5);\r\n        iterateStream.forEach(System.out::println);\r\n\r\n        Stream<Double> generateStream = Stream.generate(Math::random).limit(5);\r\n        generateStream.forEach(System.out::println);\r\n    }\r\n\r\n    List strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\");\r\n    List repeated = Arrays.asList(\"abc\", \"abc\");\r\n    List disordered = Arrays.asList(\"f\", \"a\");\r\n    List<Integer> numbers = Arrays.asList(1, 99, 3, 30, -20);\r\n\r\n    //filter map distinct sorted flatMap peek limit skip\r\n    @Test\r\n    public void normalMethod() {\r\n        System.out.println(strings.stream().filter(string -> !string.equals(\"\")).collect(Collectors.toList()));\r\n        System.out.println(strings.stream().map(str -> str + \"-itcast\").collect(Collectors.toList()));\r\n        System.out.println(repeated.stream().distinct().collect(Collectors.toList()));\r\n        System.out.println(disordered.stream().sorted().collect(Collectors.toList()));\r\n        System.out.println(numbers.stream().peek(System.out::println));\r\n        System.out.println(strings.stream().limit(3).collect(Collectors.toList()));\r\n        System.out.println(strings.stream().skip(3).collect(Collectors.toList()));\r\n        int sum = numbers.stream().reduce(0, (a, b) -> a + b);\r\n        System.out.println(\"Sum of numbers: \" + sum);\r\n        System.out.println(numbers.stream().anyMatch(number -> number % 2 == 0));\r\n    }\r\n\r\n    @Test\r\n    public void streamCompareAndUse() {\r\n        String[] intArr = {\"1-1\", \"2-1\", \"3-1\", \"4-1\", \"5-1\"};\r\n        List arrayStream = Arrays.asList(intArr);\r\n        System.out.println(arrayStream.stream().map(number -> Stream.of(number.toString().split(\"-\")).collect(Collectors.toList())).collect(Collectors.toList()));\r\n        System.out.println(arrayStream.stream().flatMap(number -> Stream.of(number.toString().split(\"-\"))).collect(Collectors.toList()));\r\n\r\n        Stream<String> lines = null;\r\n        try {\r\n            lines = Files.lines(Paths.get(\"F:\\\\JAVA\\\\20231010\\\\LeetCode\\\\src\\\\main\\\\java\\\\tries\\\\stream\\\\passage.txt\"),\r\n                    StandardCharsets.UTF_8);\r\n            Stream<String> words = lines.flatMap(line -> Stream.of(line.split(\" +\")));\r\n            System.out.println(words.collect(Collectors.toList()));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    @Test\r\n    public void streamMultiThread() {\r\n        List<Integer> list = Arrays.asList(1, 2, 3, 99);\r\n        // 通过List 接口 直接获取并行流\r\n        Stream<Integer> integerStream = list.parallelStream();\r\n        // 将已有的串行流转换为并行流\r\n        Stream<Integer> parallel = Stream.of(1, 2, 3).parallel();\r\n        parallel = integerStream;\r\n\r\n        Object obj = new Object();\r\n        Vector v = new Vector();\r\n        List<Integer> syncronizedList = Collections.synchronizedList(new ArrayList<>(v)); //相当于线程安全地添加了\r\n        System.out.println(parallel // 将流转换为并发流，Stream处理的时候就会通过多线程处理\r\n                .filter(s -> {\r\n                    syncronizedList.add(s);\r\n                    synchronized (obj) {\r\n                        System.out.println(Thread.currentThread() + \" s=\" + s);\r\n                        v.add(s);\r\n                        return s > 2;\r\n                    }\r\n                }).count());\r\n        System.out.println(v);\r\n        System.out.println(syncronizedList);\r\n\r\n        System.out.println(IntStream.rangeClosed(1, 100)\r\n                .parallel()\r\n                .boxed()\r\n                .collect(Collectors.toList())); //这样并行流也是线程安全的\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n#### stream对数据库数据的处理\r\n\r\n```\r\npackage tries.stream;\r\n\r\nimport org.apache.solr.common.util.ContentStreamBase;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Paths;\r\nimport java.util.*;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.function.BinaryOperator;\r\nimport java.util.stream.Collectors;\r\nimport java.util.stream.IntStream;\r\nimport java.util.stream.Stream;\r\n\r\nimport static java.util.stream.Collectors.*;\r\n\r\npublic class TestStream {\r\n\r\n    @Test\r\n    public void streamFromList () {\r\n        Stream<Integer> stream1 = Stream.of(1, 2, 3, 4, 5);\r\n        stream1.forEach(System.out::println);\r\n\r\n        List<Integer> integerList = Arrays.asList(new Integer[]{1, 2, 3, 4, 5});\r\n        Stream<Integer> listStream = integerList.stream();\r\n        listStream.forEach(System.out::println);\r\n    }\r\n\r\n    @Test\r\n    public void streamFromArray() {\r\n        int[] intArr = {1, 2, 3, 4, 5};\r\n        IntStream arrayStream = Arrays.stream(intArr);\r\n        arrayStream.forEach(System.out::println);\r\n    }\r\n\r\n    @Test\r\n    public void readFileLines() {\r\n        try {\r\n            Stream<String> fileStream = Files.lines(\r\n                    Paths.get(\"F:\\\\JAVA\\\\20231010\\\\LeetCode\\\\src\\\\main\\\\java\\\\tries\\\\stream\\\\data.txt\"),\r\n                    Charset.defaultCharset());\r\n            fileStream.forEach(System.out::println);\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Test\r\n    public void createFunction() {\r\n        Stream<Integer> iterateStream = Stream.iterate(0, n -> n + 2).limit(5);\r\n        iterateStream.forEach(System.out::println);\r\n\r\n        Stream<Double> generateStream = Stream.generate(Math::random).limit(5);\r\n        generateStream.forEach(System.out::println);\r\n    }\r\n\r\n    List strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\");\r\n    List repeated = Arrays.asList(\"abc\", \"abc\");\r\n    List disordered = Arrays.asList(\"f\", \"a\");\r\n    List<Integer> numbers = Arrays.asList(1, 99, 3, 30, -20);\r\n\r\n    //filter map distinct sorted flatMap peek limit skip\r\n    @Test\r\n    public void normalMethod() {\r\n        System.out.println(strings.stream().filter(string -> !string.equals(\"\")).collect(Collectors.toList()));\r\n        System.out.println(strings.stream().map(str -> str + \"-itcast\").collect(Collectors.toList()));\r\n        System.out.println(repeated.stream().distinct().collect(Collectors.toList()));\r\n        System.out.println(disordered.stream().sorted().collect(Collectors.toList()));\r\n        System.out.println(numbers.stream().peek(System.out::println));\r\n        System.out.println(strings.stream().limit(3).collect(Collectors.toList()));\r\n        System.out.println(strings.stream().skip(3).collect(Collectors.toList()));\r\n        int sum = numbers.stream().reduce(0, (a, b) -> a + b);\r\n        System.out.println(\"Sum of numbers: \" + sum);\r\n        System.out.println(numbers.stream().anyMatch(number -> number % 2 == 0));\r\n    }\r\n\r\n    @Test\r\n    public void streamCompareAndUse() {\r\n        String[] intArr = {\"1-1\", \"2-1\", \"3-1\", \"4-1\", \"5-1\"};\r\n        List arrayStream = Arrays.asList(intArr);\r\n        System.out.println(arrayStream.stream().map(number -> Stream.of(number.toString().split(\"-\")).collect(Collectors.toList())).collect(Collectors.toList()));\r\n        System.out.println(arrayStream.stream().flatMap(number -> Stream.of(number.toString().split(\"-\"))).collect(Collectors.toList()));\r\n\r\n        Stream<String> lines = null;\r\n        try {\r\n            lines = Files.lines(Paths.get(\"F:\\\\JAVA\\\\20231010\\\\LeetCode\\\\src\\\\main\\\\java\\\\tries\\\\stream\\\\passage.txt\"),\r\n                    StandardCharsets.UTF_8);\r\n            Stream<String> words = lines.flatMap(line -> Stream.of(line.split(\" +\")));\r\n            System.out.println(words.collect(Collectors.toList()));\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n    @Test\r\n    public void streamMultiThread() {\r\n        List<Integer> list = Arrays.asList(1, 2, 3, 99);\r\n        // 通过List 接口 直接获取并行流\r\n        Stream<Integer> integerStream = list.parallelStream();\r\n        // 将已有的串行流转换为并行流\r\n        Stream<Integer> parallel = Stream.of(1, 2, 3).parallel();\r\n        parallel = integerStream;\r\n\r\n        Object obj = new Object();\r\n        Vector v = new Vector();\r\n        List<Integer> syncronizedList = Collections.synchronizedList(new ArrayList<>(v)); //相当于线程安全地添加了\r\n        System.out.println(parallel // 将流转换为并发流，Stream处理的时候就会通过多线程处理\r\n                .filter(s -> {\r\n                    syncronizedList.add(s);\r\n                    synchronized (obj) {\r\n                        System.out.println(Thread.currentThread() + \" s=\" + s);\r\n                        v.add(s);\r\n                        return s > 2;\r\n                    }\r\n                }).count());\r\n        System.out.println(v);\r\n        System.out.println(syncronizedList);\r\n\r\n        System.out.println(IntStream.rangeClosed(1, 100)\r\n                .parallel()\r\n                .boxed()\r\n                .collect(Collectors.toList())); //这样并行流也是线程安全的\r\n\r\n    }\r\n\r\n    @Test\r\n    public void collectorAndDBDataProcessing() {\r\n        User user = new User(1, \"name1\", \"description\", 20);\r\n        System.out.println(user.getAge());\r\n        User user0 = new User(1, \"name2\", \"description\", 16);\r\n\r\n        ArrayList<User> givenList = new ArrayList();\r\n        givenList.add(user);\r\n        givenList.add(user0);\r\n\r\n        System.out.println(givenList.stream().map(User::getName).collect(Collectors.toSet()));\r\n        System.out.println(givenList.stream().map(User::getDscrip).collect(Collectors.toList()));\r\n        System.out.println(givenList.stream().map(User::getNo).collect(toCollection(LinkedList::new)).toString());\r\n\r\n        System.out.println(givenList.stream().collect(toMap(User::getName, User::getDscrip)));\r\n        System.out.println(givenList.stream().collect(toMap(User::getNo, User::getDscrip, (item, identicalItem) -> item))); //避免碰撞\r\n\r\n        givenList.stream().map(User::getNo).collect(Collectors.collectingAndThen(\r\n                        Collectors.toList(), list -> {System.out.println(list); return null;}));\r\n\r\n        System.out.println(givenList.stream().map(User::getName).collect(joining(\" \", \"[ \", \" ]\")));\r\n\r\n        // data comparing\r\n        System.out.println(\"————————————————————————————————\");\r\n        System.out.println(givenList.stream().collect(summarizingDouble(User::getNo)));\r\n        System.out.println(givenList.stream().collect(averagingDouble(User::getNo)));\r\n        System.out.println(givenList.stream().collect(summingDouble(User::getNo)));\r\n        System.out.println(givenList.stream().map(User::getAge).collect(maxBy(Comparator.naturalOrder())));\r\n        System.out.println(givenList.stream().map(User::getAge).collect(minBy(Comparator.naturalOrder())));\r\n        System.out.println(givenList.stream().collect(groupingBy(User::getNo, Collectors.mapping(User::getName, Collectors.toSet()))));\r\n\r\n        System.out.println(givenList.stream().collect(partitioningBy(usr -> usr.getAge() > 18, Collectors.mapping(User::getAge, Collectors.toList()))));\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\n#### vue文档及响应式状态变量\r\n- <https://vuejs.org/guide/quick-start.html#local>\r\n```\r\n<script setup>\r\nimport { ref,reactive } from \'vue\'\r\n\r\ndefineProps({\r\n  msg: String,\r\n})\r\n//数组\r\nconst tableList = ref([])\r\n//变量\r\nconst state = reactive({\r\n    form:{\r\n        id: undefined,\r\n        name: undefined\r\n    }\r\n})\r\nconsole.log(state)\r\nfunction addInfo() { //列表渲染\r\n    //1.使用 对象克隆    浅克隆 和 深克隆\r\n    //浅克隆\r\n    // Object.clone() //js Object clone\r\n    const newObj = Object.assign({}, state.form) //重新分配空间 target , origin\r\n    //深克隆 序列化和反序列化\r\n    const str=JSON.stringify(state.form) //序列化\r\n    const newObject1=JSON.parse(str) //反序列化\r\n\r\n    tableList.value.push(newObj) //数组追加值  添加的是引用对象 后面会影响\r\n\r\n    // 清空\r\n    state.form.id = undefined\r\n    state.form.name = undefined\r\n}\r\nconst addInfo0 = () => {\r\n    console.log(\"loading\")\r\n}\r\nfunction removeInfo(index) {\r\n    console.log(index)\r\n    tableList.value.splice(index, 1)\r\n}\r\nconst count = ref(0)\r\n</script>\r\n\r\n<template>\r\n    <!--<div>{{ msg }}</div>-->\r\n    <div class = \"left\">\r\n        <table width=100% border=\"1\">\r\n            <tr>\r\n                <td>学号</td>\r\n                <td>姓名</td>\r\n                <td>操作</td>\r\n            </tr>\r\n            <tr v-for=\"(item, index) in tableList\">\r\n                <td>{{item.id}}</td>\r\n                <td>{{item.name}}</td>\r\n                <td><input type=\"button\" value=\"删除\" @click=\"removeInfo(index)\"></td>\r\n            </tr>\r\n        </table>\r\n    </div>\r\n\r\n    <div class=\"right\">\r\n        学号：<input type=\"text\" v-model = \'state.form.id\'>\r\n        姓名：<input type=\"text\" v-model = \'state.form.name\'>\r\n        <input type=\"button\" value=\"保存\" @click=\"addInfo\">\r\n    </div>\r\n</template>\r\n\r\n<style scoped>\r\n.left {\r\n    width: 480px;\r\n    border: 1px solid red float;\r\n    float:left;\r\n}\r\n.right {\r\n    width: 480px;\r\n    border: 1px solid red float;\r\n    float:right;\r\n}\r\n</style>\r\n```', '2024-05-22 20:11:11'),(7, 1, 'Elasticsearch', '## Elasticsearch\r\n### 下载\r\n<https://www.elastic.co/downloads/elasticsearch>\r\n\r\n### 文档\r\n<https://www.elastic.co/guide/en/elasticsearch/reference/8.11/setup.html>\r\n    \r\n### 启动\r\n1. 将bin目录加入环境变量\r\n2. 执行 `elasticsearch.bat`\r\n> 如果遇到jdk找不到\r\n```\r\nhjava.nio.file.NoSuchFileException: F:\\jdk1.8.0_201\\lib\\tools.jar\r\n```\r\n> 将jdk复制到所显示目录\r\n\r\n> The system environment variable ES_JAVA_HOME should be set to the path of the JDK installation that you want the service to use. \r\n\r\n### windows安装服务并启动\r\n```\r\nC:\\Users\\AJH41>elasticsearch-service.bat install\r\nC:\\Users\\AJH41>elasticsearch-service.bat start\r\nUsage: elasticsearch-service.bat install|remove|start|stop|manager\r\n```\r\n\r\n### 默认访问网址\r\n<https://192.168.17.2:9200>  或者\r\n<https://localhost:9200>  \r\n- 具体查看[logs目录下的]日志\r\n\r\n### 添加用户及权限\r\n```\r\nC:\\Users\\AJH41>elasticsearch-users useradd admin\r\n```\r\nconfig/roles.yum  \r\n```\r\nadmin_role:\r\n  cluster: [\"monitor\", \"manage\"]\r\n  indices:\r\n    - names: [\"*\"]\r\n      privileges: [\"all\"]\r\n```\r\nconfig/users_roles  \r\n```\r\nadmin_role:admin\r\n```\r\n\r\n### 导入数据\r\n- 使用Logstash\r\n<https://www.elastic.co/downloads/logstash>\r\n\r\n- 关闭elasticsearch ssl 及 用户名，密码验证\r\n/config/elasticsearch.yml\r\n修改以下条目\r\n```\r\nxpack.security.enabled: false\r\nxpack.security.enrollment.enabled: false\r\nxpack.security.http.ssl.enabled: false\r\nxpack.security.transport.ssl.enabled: false\r\n```\r\n<https://blog.csdn.net/qq_43080270/article/details/105970462> # 安装ElasticSearch-Head插件  \r\n- 启动elasticsearch的磁盘需要留有足够的空间，否则cluster的健康度会爆红\r\n  - 启动命令：npm run start\r\n  - 健康度错误详情【分片故障分析原因】可以通过插件9100端口页面的Any query: GET _cluster/allocation/explain查看  \r\n- 从elasticsearch->logstash->kabana(通过nsmn的windows服务搭建)[备用]:<https://community.spiceworks.com/how_to/164166-installing-elk-7-elasticsearch-logstash-and-kibana-windows-server-2016-part-1>  \r\n- 磁盘健康阈值设置：<https://blog.csdn.net/gxb2260/article/details/129108795>   \r\n\r\nlogstash根目录/logstash.conf\r\n```\r\ninput {\r\n  jdbc {\r\n    jdbc_driver_library => \"G:\\\\Downloads\\\\mysql-connector-java-8.0.30.jar\"\r\n    jdbc_driver_class => \"com.mysql.jdbc.Driver\"\r\n    jdbc_connection_string => \"jdbc:mysql://localhost:3306/manage\"\r\n    jdbc_user => \"root\"\r\n    jdbc_password => \"123456\"\r\n    schedule => \"* * * * *\"\r\n    statement => \"SELECT * FROM product#\"\r\n  }\r\n}\r\n\r\noutput {\r\n  elasticsearch {\r\n    hosts => [\"http://127.0.0.1:9200\"]\r\n    index => \"myindex\"\r\n    user => \"admin\"\r\n    password => \"123456\"\r\n  }\r\n}\r\n```\r\nwindows shell:[bin目录下执行或设置环境变量]\r\n```\r\nlogstash -f logstash.conf\r\n```\r\n验证是否导入成功\r\n> elastic-head插件<http://localhost:9100/> -> structed query -> 选择[myindex] [json]查看结果  \r\n\r\n### 通过java读取数据\r\nmaven\r\n```\r\n<dependency>\r\n  <groupId>org.elasticsearch.client</groupId>\r\n  <artifactId>elasticsearch-rest-client</artifactId>\r\n  <version>8.11.1</version>\r\n</dependency>\r\n```\r\n读取数据\r\n```\r\n@Test\r\n    public void test() {\r\n        // 创建 Elasticsearch REST 客户端连接\r\n        RestClient restClient = RestClient.builder(\r\n                        new HttpHost(\"localhost\", 9200, \"http\"))\r\n                .build();\r\n\r\n// 发送 GET 请求查询数据\r\n        try {\r\n            // 构建查询请求\r\n            Request request = new Request(\"GET\", \"/myindex/_search\");\r\n            // 替换 \"your_index\" 为你要查询的索引名称\r\n\r\n            // 添加请求体（如果有的话）\r\n            // request.setJsonEntity(\"{ \\\"query\\\": { \\\"match_all\\\": {} } }\");\r\n\r\n            // 发送请求并获取响应\r\n            Response response = restClient.performRequest(request);\r\n\r\n            // 处理响应结果\r\n            // 输出响应内容\r\n//            System.out.println(\"Response Status: \" + response.getStatusLine());\r\n            System.out.println(\"Response Body: \" + EntityUtils.toString(response.getEntity()));\r\n\r\n            // 关闭 REST 客户端连接\r\n            restClient.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n```', '2024-05-22 20:11:25'),(8, 1, 'Flowable流程引擎', '## Flowable流程引擎\r\n### 快速开始\r\n<https://www.flowable.com/open-source/docs/bpmn/ch02-GettingStarted>\r\n```\r\nProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration()\r\n.setJdbcUrl(\"jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1\")\r\n.setJdbcUsername(\"sa\")\r\n.setJdbcPassword(\"\")\r\n.setJdbcDriver(\"org.h2.Driver\")\r\n.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);\r\n\r\nProcessEngine processEngine = cfg.buildProcessEngine();\r\n```\r\n\r\n### 对xml的应用\r\n<https://paulhh.wordpress.com/2017/01/31/flowable-6-instant-gratification/>\r\n- modeler可以导入xml文件\r\n> 例如\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<definitions xmlns=\"http://www.omg.org/spec/BPMN/20100524/MODEL\"\r\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n             xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\r\n             xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\"\r\n             xmlns:omgdc=\"http://www.omg.org/spec/DD/20100524/DC\"\r\n             xmlns:omgdi=\"http://www.omg.org/spec/DD/20100524/DI\"\r\n             xmlns:flowable=\"http://flowable.org/bpmn\"\r\n             typeLanguage=\"http://www.w3.org/2001/XMLSchema\"\r\n             expressionLanguage=\"http://www.w3.org/1999/XPath\"\r\n             targetNamespace=\"http://www.flowable.org/processdef\">\r\n\r\n    <process id=\"holidayRequest\" name=\"Holiday Request\" isExecutable=\"true\">\r\n\r\n        <startEvent id=\"startEvent\"/>\r\n        <sequenceFlow sourceRef=\"startEvent\" targetRef=\"approveTask\"/>\r\n\r\n        <userTask id=\"approveTask\" name=\"Approve or reject request\"/>\r\n        <sequenceFlow sourceRef=\"approveTask\" targetRef=\"decision\"/>\r\n\r\n        <exclusiveGateway id=\"decision\"/>\r\n        <sequenceFlow sourceRef=\"decision\" targetRef=\"externalSystemCall\">\r\n            <conditionExpression xsi:type=\"tFormalExpression\">\r\n                <![CDATA[\r\n          ${approved}\r\n        ]]>\r\n            </conditionExpression>\r\n        </sequenceFlow>\r\n        <sequenceFlow  sourceRef=\"decision\" targetRef=\"sendRejectionMail\">\r\n            <conditionExpression xsi:type=\"tFormalExpression\">\r\n                <![CDATA[\r\n          ${!approved}\r\n        ]]>\r\n            </conditionExpression>\r\n        </sequenceFlow>\r\n\r\n        <serviceTask id=\"externalSystemCall\" name=\"Enter holidays in external system\"\r\n                     flowable:class=\"org.flowable.CallExternalSystemDelegate\"/>\r\n        <sequenceFlow sourceRef=\"externalSystemCall\" targetRef=\"holidayApprovedTask\"/>\r\n\r\n        <userTask id=\"holidayApprovedTask\" name=\"Holiday approved\"/>\r\n        <sequenceFlow sourceRef=\"holidayApprovedTask\" targetRef=\"approveEnd\"/>\r\n\r\n        <serviceTask id=\"sendRejectionMail\" name=\"Send out rejection email\"\r\n                     flowable:class=\"org.flowable.SendRejectionMail\"/>\r\n        <sequenceFlow sourceRef=\"sendRejectionMail\" targetRef=\"rejectEnd\"/>\r\n\r\n        <endEvent id=\"approveEnd\"/>\r\n\r\n        <endEvent id=\"rejectEnd\"/>\r\n\r\n    </process>\r\n\r\n</definitions>\r\n```\r\n可以转化为：\r\n<img alt=\"flowable转换\" src=\"http://mail.hampster.work:9000/online/hampster/java/flowable/image.png\" width=\"100%\"/>\r\n', '2025-01-10 11:58:31'),(9, 1, 'Mybatis-pool', '\r\n## MYBATIS-POOL\r\n> 参考：文心一言 讯飞星火 chatGPT MYBATIS白皮书 gamma.app(bilibili)\r\n\r\n[https://www.tutorialspoint.com/mybatis/mybatis_annotations.htm](https://www.tutorialspoint.com/mybatis/mybatis_annotations.htm)<br/>\r\n<a href=\"https://blog.csdn.net/weixin_51725434/article/details/128396111\">https://blog.csdn.net/weixin_51725434/article/details/128396111</a><br/>\r\n<a href=\"https://howtodoinjava.com/log4j2/log4j2-properties-example/\">https://howtodoinjava.com/log4j2/log4j2-properties-example/</a><br/>\r\nspring transaction:<br/>\r\n <a href=\"https://www.digitalocean.com/community/tutorials/spring-transaction-management-jdbc-example\">https://www.digitalocean.com/community/tutorials/spring-transaction-management-jdbc-example</a><br/>\r\n<a href=\"https://blog.csdn.net/xcnaabb/article/details/130102571\">https://blog.csdn.net/xcnaabb/article/details/130102571</a><br/>\r\nmapper SQL process: <br/>\r\n<a href=\"https://blog.csdn.net/weixin_44451022/article/details/128641020\">https://blog.csdn.net/weixin_44451022/article/details/128641020</a><br/>\r\nsource Code: <br/>\r\n<a href=\"https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java\">https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java</a><br/>\r\n德鲁伊：<br/>\r\n<a href=\"https://blog.csdn.net/qq_15204179/article/details/83050229\">https://blog.csdn.net/qq_15204179/article/details/83050229</a><br/>\r\n\r\n</a>\r\n\r\n</span>\r\n\r\n<h3>数据库操作：mybatis中实现数据库增删查改的mapper一共有三种方式</h3>\r\n\r\n1.通过xml方式\r\n这是最常见的方式，其中 Mapper 接口的 SQL 映射规则被定义在 XML 文件中，这个 XML 文件通常以 \".xml\" 为后缀名。您可以通过 `&lt;mapper&gt;` 元素的 `resource` 属性来引入 XML Mapper 文件。<br/>\r\n\r\n2.通过注解的方式\r\n可以使用注解方式来定义 SQL 映射规则。在这种方式中，您在 Mapper 接口的方法上使用注解来指定 SQL 查询。这种方式通常比较简洁，但不如 XML 配置文件灵活。<br/>\r\n\r\n3.通过实现接口结合xml的方式\r\n该接口，用于定义与数据库交互的 SQL 方法。这些接口通常没有实现类，但是 MyBatis 在运行时会生成代理类来实现这些接口的方法。Mapper 接口的方法名和参数与 SQL 查询的配置相关联，这种方式称为 \"Mapper 接口方式\"。<br/>\r\n\r\n<h4>1. mybatis增删查改:通过xml方式</h4>\r\n\r\n</div>\r\n\r\n##### Mapper.xml文件\r\n\r\n```\r\n\r\n<!DOCTYPE mapper\r\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.hyh.dao.TestDao\">\r\n    <!--查询-->\r\n    <resultMap type=\"com.hyh.pojo.User\" id=\"userSet\">\r\n        <id column=\"id\" property=\"id\"/>\r\n        <result column=\"name\" property=\"name\"/>\r\n        <result column=\"sex\" property=\"sex\"/>\r\n        <result column=\"age\" property=\"age\"/>\r\n    </resultMap>\r\n    <!--通过id查询-->\r\n    <select id=\"selectUser\" parameterType = \"int\" resultType=\"com.hyh.pojo.User\">\r\n        select * from mybatis_user where id = #{id}\r\n    </select>\r\n    <!--查询所有-->\r\n    <select id = \"getAll\" resultMap = \"userSet\">\r\n        SELECT * FROM mybatis_user\r\n    </select>\r\n\r\n    <!--插入-->\r\n    <insert id=\"insert\"> <!--可能是databaseId没有检测到-->\r\n        <selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\">\r\n            <if test=\"_databaseId == \'oracle\'\"> <!--可以针对不同的数据库做出不同响应-->\r\n                select mybatis_seq.nextVal from dual\r\n            </if>\r\n        </selectKey>\r\n        insert into mybatis_user values (#{id}, #{name}, #{sex}, #{age})\r\n    </insert>\r\n\r\n    <!--更新-->\r\n    <update id=\"update\">\r\n        update mybatis_user\r\n        <set>\r\n            <if test=\"name != null\">name=#{name},</if>\r\n            <if test=\"sex != null\">sex=#{sex},</if>\r\n            <if test=\"age != null\">age=#{age}</if>\r\n        </set>\r\n        where id=#{id}\r\n    </update>\r\n\r\n    <!--删除-->\r\n    <delete id=\"delete\"\r\n            parameterType=\"com.hyh.pojo.User\"\r\n            flushCache=\"true\"\r\n            statementType=\"PREPARED\"\r\n            timeout=\"20\">\r\n    <!--以上参数均为可选参数，可以不写，参数为：id, 返回类型，是否清空缓存，prepared statement/static statement, 超时时限-->\r\n        delete from mybatis_user where id = #{id}\r\n    </delete>\r\n\r\n</mapper>\r\n\r\n\r\n```\r\n\r\n#### mybatis配置文件\r\n\r\n##### property文件设置\r\n\r\n- 利用resource属性添加文件名\r\n\r\n- 利用property name=\"\" value=\'\'子项，添加属性</pre>\r\n\r\n```\r\n\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n    <properties resource=\"db.properties\">\r\n        <property name=\"username\" value=\"dev_user\"/>\r\n        <property name=\"password\" value=\"F2Fa3!33TYyg\"/>\r\n    </properties>\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <transactionManager type=\"JDBC\"/>\r\n            <dataSource type=\"POOLED\">\r\n                <property name=\"driver\" value=\"${oracle_driver}\"/>\r\n                <property name=\"url\" value=\"${oracle_url}\"/>\r\n                <property name=\"username\" value=\"${oracle_username}\"/>\r\n                <property name=\"password\" value=\"${oracle_password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n    <mappers>\r\n        <mapper resource=\"com\\hyh\\mapper\\TestMapper.xml\"/> <!--根据不同的mapper有不同的编写和结构-->\r\n    </mappers>\r\n</configuration>\r\n```\r\n\r\n##### 测试文件\r\n\r\n```\r\n   public SqlSessionFactory giveFactory() { //启用mybatis配置文件\r\n        SqlSessionFactory factory = null;\r\n        try { // 2.1.2 Building SqlSessionFactory from XML\r\n            InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");\r\n            factory = new SqlSessionFactoryBuilder().build(inputStream);\r\n            inputStream.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n        System.out.println(factory.getConfiguration().getDatabaseId());\r\n\r\n        return factory;\r\n    }\r\n\r\n    public void XMLSelect(SqlSession sqlSession) { //查找\r\n        System.out.println(\"XMLSelect\");\r\n        List<User> users = sqlSession.selectList(\"com.hyh.dao.TestDao.getAll\");\r\n        User user = sqlSession.selectOne(\"com.hyh.dao.TestDao.selectUser\", 1);\r\n\r\n        System.out.println(users);\r\n        System.out.println(user);\r\n    }\r\n\r\n    @Test\r\n    public void buildForXML() {\r\n        System.out.println(\"============Test buildForXML==============\");\r\n\r\n        SqlSessionFactory factory = giveFactory();\r\n\r\n        try (SqlSession sqlSession = factory.openSession()) {\r\n            factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n            System.out.println(factory.getConfiguration().getDatabaseId());\r\n\r\n            XMLSelect(sqlSession);\r\n\r\n            User userInserted = new User(2, \"WWW\", \"W\", 10); //添加\r\n            int bo = sqlSession.insert(\"com.hyh.dao.TestDao.insert\", userInserted);\r\n\r\n            User userUpdated = new User(3, \"xxxpoipioip\", \"op\", 9); //修改\r\n            int boo = sqlSession.update(\"com.hyh.dao.TestDao.update\", userUpdated);\r\n\r\n            int fii = sqlSession.delete(\"com.hyh.dao.TestDao.delete\", 1); //删除\r\n            User userDeleted = new User(3, \"WWW\", \"W\", 10);\r\n            int fiii = sqlSession.delete(\"com.hyh.dao.TestDao.deleteObject\", userDeleted);\r\n\r\n            System.out.println(\"others\");\r\n            System.out.println(bo);\r\n            System.out.println(boo);\r\n            System.out.println(fii);\r\n            System.out.println(fiii);\r\n\r\n            sqlSession.commit(); //!!!!!!提交\r\n        }\r\n```\r\n\r\n#### 2. mybatis增删查改:通过注解方式\r\n\r\n使用包：<br>\r\n\r\n因为之前已经载入了很多其它的包，所以没有采用maven，包的搜索网址为：<a href=\"https://search.maven.org/search\">https://search.maven.org/search</a>\r\n<!--  spring-dao<br>-->\r\n\r\nspring-orm: 用于将对象模型与关系数据库之间的数据进行映射和转换，解决它们之间数据表示不匹配的问题，具有sql语言对象化，自动化数据访问，多数据库支持，简化代码提高效率的特点<br>\r\n\r\n> mybatis-spring<br>\r\n> mybatis<br>\r\n> ojdbc8\r\n\r\n\r\n##### annotation Interface\r\n\r\n```\r\n@Mapper\r\npublic interface TestMapperAnnotation {\r\n\r\n    @Select(\"select * from mybatis_user where id = #{id}\")\r\n    User getUserById(int id);\r\n\r\n    @Delete(\"delete from mybatis_user where id = #{id}\")\r\n    int deleteUserById(int id);\r\n\r\n    @Insert(\"insert into mybatis_user values (#{id}, #{name}, #{sex}, #{age})\") //多个参数要用@Param来区分\r\n    int insertUserByObject(@Param(\"id\") int id, @Param(\"name\") String name, @Param(\"sex\") String sex, @Param(\"age\") int age);\r\n\r\n    @Update(\"update mybatis_user set name=#{name}, sex=#{sex}, age=#{age} where id=#{id}\")\r\n    int updateByObject(@Param(\"id\") int id, @Param(\"name\") String name, @Param(\"sex\") String sex, @Param(\"age\") int age);\r\n}\r\n```\r\n\r\n##### 测试\r\n\r\n```\r\n    @Test\r\n    public void buildForAnnotation() {\r\n        System.out.println(\"============Test buildForAnnotation=============\");\r\n        SqlSessionFactory factory = giveFactory();\r\n\r\n        try (SqlSession session = factory.openSession()) {\r\n            session.getConfiguration().addMapper(TestMapperAnnotation.class);\r\n\r\n            TestMapperAnnotation mapper = session.getMapper(TestMapperAnnotation.class);\r\n            System.out.println(mapper.getUserById(51));\r\n            System.out.println(mapper.deleteUserById(51));\r\n            System.out.println(mapper.insertUserByObject(1000, \"asdf\", \"ew\", 0));\r\n            System.out.println(mapper.updateByObject(1000, \"mmm\", \"ooo\", 999));\r\n\r\n            session.commit();\r\n        }\r\n    }\r\n```\r\n\r\n#### 3. mybatis增删查改：通过接口结合xml文件的方式</h4>\r\n\r\n- mapper接口的全类名和映射文件的命名空间(namespace)保持一致\r\n\r\n- mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致\r\n\r\n中途遇到的问题：out文件夹的内容没有跟着更新需要手动复制进去/out文件夹没有.class文件，删除out重新生成 ---编译器IDEA<br>\r\n\r\n没有设置数据库名称(测试方法效率不高)<br>\r\n\r\n接口文件\r\n\r\n```\r\nimport com.hyh.pojo.User;\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\nimport java.util.List;\r\n\r\npublic interface TestMapperInterface {\r\n    User selectUser(@Param(\"id\") int id); //一接口方式实现的哪怕只有一个变量也要声明@Param\r\n    List<User> getAll();\r\n    boolean insert(@Param(\"id\") int id, @Param(\"name\") String name, @Param(\"sex\") String sex, @Param(\"age\") int age);\r\n    boolean update(@Param(\"id\") int id, @Param(\"name\") String name, @Param(\"sex\") String sex, @Param(\"age\") int age);\r\n    boolean delete(@Param(\"id\") int id);\r\n}\r\n```\r\n\r\n<div >mapper.xml文件与上一个mapper的差别</div>\r\n\r\n```\r\n<mapper namespace=\"com.hyh.dao.TestMapperInterface\">\r\n```\r\n\r\n<div >输出文件</div>\r\n\r\n```\r\n    @Test\r\n    public void testForInterfacePlusXML() {\r\n        System.out.println(\"============Test testForInterfacePlusXML=============\");\r\n\r\n        SqlSessionFactory factory = giveFactory();\r\n\r\n        try (SqlSession session = factory.openSession()) {\r\n            factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n            System.out.println(factory.getConfiguration().getDatabaseId());\r\n            //在xml里面添加了接口\r\n\r\n            TestMapperInterface tmi = session.getMapper(TestMapperInterface.class);\r\n            System.out.println(\"\" +\r\n            tmi.delete(51) + \" \" +\r\n            tmi.update(45, \"asdf\", \"wee\", 90) + \" \" +\r\n            tmi.insert(23, \"sd\", \"sd\", 88) + \" \" +\r\n                    tmi.getAll() + \" \\n\" +\r\n                    tmi.selectUser(45)\r\n            ); //这里查找的数据想要改变中途需要commit\r\n\r\n            session.commit();\r\n\r\n        }\r\n    }\r\n```\r\n\r\n<div >\r\n\r\n<h3>对mybatis-config.XML文件的解释之TransactionManager</h3>\r\n\r\n白皮书翻译（CHATGPT + HYH）P24\r\n\r\n\r\n事务管理器\r\nMyBatis包含两种事务管理器类型（即type=\"[JDBC|MANAGED]\"）：\r\n\r\n- JDBC - 这个配置简单地直接使用JDBC的提交（commit）和回滚（rollback）功能。它依赖于从dataSource获取的连接来管理事务的范围。\r\n- MANAGED - 这个配置几乎什么都不做。它不会提交或回滚连接。相反，它会让容器管理事务的完整生命周期（例如，在JEE应用服务器上的上下文）。默认情况下，它会关闭连接。但是，有些容器不希望这样做，因此如果您需要阻止它关闭连接，请将\"closeConnection\"属性设置为false。例如：\r\n	- JEE应用服务器上是JNDI(Java Naming and Directory Interface）上下文(context))，通俗地理解，Spring Web应用程序是部署在JEE应用服务器上的。\r\n\r\n>【注意】如果您计划在Spring中使用MyBatis，就不需要配置任何TransactionManager，因为Spring模块会设置自己的TransactionManager，覆盖任何之前设置的配置。\r\n\r\n- 这两种TransactionManager类型都不需要任何属性配置。然而，它们都是类型别名（Type Aliases）。换句话说，您可以使用自己的完全限定类名或类型别名来引用您自己实现的TransactionFactory接口。\r\n\r\n\r\n<h4>TransactionFactory接口</h4>\r\n\r\nsource Code: <a href=\"https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java\">\r\n\r\n[https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java](https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/transaction/SpringManagedTransactionFactory.java)\r\n\r\n</a>\r\n\r\n<pre class=\"preText\">\r\n> 如果设置失败，检查可能是mybatis-config.xml路径问题，可能迁移了项目但是没有修改参数，可以输出文件流查看\r\n\r\n+ 以下为自定义接口实现：\r\n- mybatis-config.xml文件\r\n</pre>\r\n\r\n</div>\r\n\r\n```\r\n<transactionManager type=\"com.hyh.transaction.impl.TransactionFactoryImpl\">\r\n    <property name=\"autoCommit\" value=\"false\"/>\r\n</transactionManager>\r\n```\r\n\r\n<div >\r\n\r\n<pre class=\"preText\">\r\n- TransactionFactory接口实现\r\n</pre>\r\n\r\n</div>\r\n\r\n```\r\nimport org.apache.ibatis.session.TransactionIsolationLevel;\r\nimport org.apache.ibatis.transaction.Transaction;\r\nimport org.apache.ibatis.transaction.TransactionFactory;\r\nimport javax.sql.DataSource;\r\nimport java.sql.Connection;\r\nimport java.util.Properties;\r\n\r\npublic class TransactionFactoryImpl implements TransactionFactory {\r\n\r\n    public boolean autoCommit;\r\n\r\n    public boolean isAutoCommit() {\r\n        return autoCommit;\r\n    }\r\n\r\n    public void setAutoCommit(boolean autoCommit) {\r\n        this.autoCommit = autoCommit;\r\n    }\r\n\r\n    @Override\r\n    public void setProperties(Properties props) {\r\n        TransactionFactory.super.setProperties(props); //当前版本3.5.8, 3.5.2之后变为默认方法\r\n    }\r\n\r\n    @Override\r\n    public Transaction newTransaction(Connection connection) {\r\n        return new TransactionImpl(connection, autoCommit);\r\n    }\r\n\r\n    @Override\r\n    public Transaction newTransaction(DataSource dataSource, TransactionIsolationLevel transactionIsolationLevel, boolean b) {\r\n        return new TransactionImpl(dataSource, autoCommit);\r\n    }\r\n}\r\n```\r\n\r\n<div >- Transaction接口实现</div>\r\n\r\n```\r\nimport com.hyh.dbUtil.DBUtils;\r\nimport org.apache.ibatis.transaction.Transaction;\r\nimport org.mybatis.logging.Logger;\r\nimport org.mybatis.logging.LoggerFactory;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport org.mybatis.spring.transaction.SpringManagedTransaction;\r\n\r\n/**\r\n * 参考：org.mybatis.spring.transaction.SpringManagedTransaction\r\n */\r\npublic class TransactionImpl implements Transaction {\r\n\r\n    private static final Logger LOGGER = LoggerFactory.getLogger(TransactionImpl.class); //通过mybatis获取日志\r\n    private DataSource dataSource;\r\n\r\n    private Connection connection;\r\n    public Boolean autoCommit; //connection.setAutoCommit  包装类才可以设置为空(默认为null)\r\n\r\n    private int commitCount = 0;\r\n    private int rollbackCount = 0;\r\n\r\n    public TransactionImpl(Connection connection, boolean autoCommit) {\r\n        this.connection = connection;\r\n        this.autoCommit = autoCommit;\r\n        LOGGER.debug(() -> {\r\n            return \"initialize HAMSTER Connection through connection AUTOCOMMIT \" + this.autoCommit;\r\n        });\r\n    }\r\n\r\n    public TransactionImpl(DataSource dataSource, boolean autoCommit) {\r\n        this.dataSource = dataSource;\r\n        this.autoCommit = autoCommit;\r\n        LOGGER.debug(() -> {\r\n            return \"initialize HAMSTER Connection through datasource AUTOCOMMIT \" + this.autoCommit;\r\n        });\r\n    }\r\n\r\n    @Override\r\n    public Connection getConnection() throws SQLException {\r\n\r\n        if (this.connection == null) {\r\n            this.openConnection();\r\n        }\r\n\r\n        return this.connection;\r\n    }\r\n\r\n    @Override\r\n    public void commit() throws SQLException {\r\n        if (this.connection != null &&  !this.autoCommit) {\r\n            LOGGER.debug(() -> {\r\n                return ++commitCount + \"Committing HAMSTER Connection [\" + this.connection + \"]\";\r\n            });\r\n            this.connection.commit();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void rollback() throws SQLException {\r\n        if (this.connection != null && !this.autoCommit) {\r\n            LOGGER.debug(() -> {\r\n                return ++rollbackCount + \"Rolling back HAMSTER Connection [\" + this.connection + \"]\";\r\n            });\r\n            this.connection.rollback();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void close() throws SQLException {\r\n        LOGGER.debug(() -> {\r\n            return \"HAMSTER Connection [\" + this.connection + \"] is closing\";\r\n        });\r\n        this.connection.close();\r\n    }\r\n\r\n    @Override\r\n    public Integer getTimeout() throws SQLException {\r\n        LOGGER.debug(() -> {\r\n            return \"HAMSTER Connection [\" + this.connection + \"] is checking timeout\";\r\n        });\r\n        return this.connection.getNetworkTimeout();\r\n    }\r\n\r\n    /**\r\n     * Sets this connection\'s auto-commit mode to the given state.\r\n     * If a connection is in auto-commit mode, then all its SQL statements will be executed and committed as individual\r\n     * transactions. Otherwise, its SQL statements are grouped into transactions that are terminated by a call to either\r\n     * the method commit or the method rollback. By default, new connections are in auto-commit mode.\r\n     * 大概是说：自动提交为真，那么就单个sql每次都提交，自动提交为假，那么就手动提交，并将本次提交前的所有sql称为一个事务，这个事务会被提交方法或者回滚方法终止。\r\n     * @throws SQLException\r\n     */\r\n    private void openConnection() {\r\n        try {\r\n            this.connection = dataSource != null ? dataSource.getConnection() : new DBUtils().getConnection();\r\n            this.autoCommit = this.autoCommit == null? this.connection.getAutoCommit() : this.autoCommit;\r\n            this.connection.setAutoCommit(this.autoCommit); // 设置/传入值\r\n        } catch (SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        LOGGER.debug(() -> {\r\n            return \"HAMSTER Connection [\" + this.connection + \"] will be managed by Hamster\";\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n<div >DBUtil类</div>\r\n\r\n```\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\n\r\npublic class DBUtils {\r\n\r\n    private String driver = \"oracle.jdbc.driver.OracleDriver\";\r\n    private String url = \"jdbc:oracle:thin:@localhost:1521:orcl\";\r\n    private String username = \"hyh\";\r\n    private String password = \"123456\";\r\n\r\n    public Connection getConnection() {\r\n        System.out.println(\"get Connection\");\r\n\r\n        Connection conn = null;\r\n        try {\r\n            Class.forName(driver);\r\n            conn = DriverManager.getConnection(url, username, password);\r\n        } catch (ClassNotFoundException | SQLException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return conn;\r\n    }\r\n\r\n}\r\n```\r\n\r\n- 测试\r\n\r\n```\r\n@Test\r\npublic void testTransaction() {\r\n    System.out.println(\"====================test testTransaction===============\");\r\n\r\n    // 获取 MyBatis SqlSessionFactory（假设你已经初始化了它）\r\n    SqlSessionFactory factory = giveFactory(); //!!!set Oracle Factory in this method\r\n\r\n    LogFactory.useStdOutLogging(); //开启日志打印到控制台\r\n\r\n    // 创建一个 SqlSession\r\n    try (SqlSession sqlSession = factory.openSession()) {\r\n        // 获取你的 Mapper\r\n        TestMapperInterface yourMapper = sqlSession.getMapper(TestMapperInterface.class);\r\n\r\n        // 开始事务\r\n        sqlSession.getConnection().setAutoCommit(false);\r\n\r\n        try {\r\n            // 执行数据库操作，例如插入或更新数据\r\n            yourMapper.insert(5000, \"sss\", \"sdf\", 80); // 替换成你的实际操作\r\n\r\n            // 手动提交事务\r\n            sqlSession.getConnection().commit();\r\n\r\n            // 如果一切顺利，事务将被提交\r\n        } catch (Exception e) {\r\n            // 如果发生异常，回滚事务\r\n            sqlSession.getConnection().rollback();\r\n\r\n            // 处理异常，例如记录错误信息或抛出异常\r\n            e.printStackTrace();\r\n        }\r\n    } catch (SQLException throwables) {\r\n        throwables.printStackTrace();\r\n    }\r\n}\r\n```\r\n<div >- 输出</div>\r\n\r\n```\r\noracle\r\nLogging initialized using \'class org.apache.ibatis.logging.stdout.StdOutImpl\' adapter.\r\ninitialize HAMSTER Connection through datasource AUTOCOMMIT false\r\nHAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] will be managed by Hamster\r\nHAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is checking timeout\r\nDEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual\r\nDEBUG [main] - ==> Parameters:\r\nDEBUG [main] - <==      Total: 1\r\nHAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is checking timeout\r\nDEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)\r\nDEBUG [main] - ==> Parameters: 398(Integer), sss(String), sdf(String), 80(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\n1Rolling back HAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67]\r\nHAMSTER Connection [oracle.jdbc.driver.T4CConnection@67a20f67] is closing\r\n\r\nProcess finished with exit code 0\r\n```\r\n<div >\r\n<pre class=\"preText\" id=\"dataSource\">\r\n    可以得出sql事务的加载顺序为：\r\n</pre>\r\n\r\n> <h5>getConnection ---> check timeout ---> roll back / commit ---> close</h5>\r\n<pre>\r\n    XML 中配置的任何属性都会在实例化后传递给 setProperties() 方法。你的实现还需要创建一个 Transaction 实现，这也是一个非常简单的接口：getConnection() commit() rollback() close() getTimeout() + 上面有实现\r\n    使用上面两种接口，你可以完全自定义mybatis处理事务的方式。\r\n</pre>\r\n\r\n<h3>对mybatis-config.XML文件的解释之dataSource</h3>\r\n\r\n> dataSource 元素配置了使用标准 JDBC DataSource 接口的 JDBC 连接对象的源头。\r\n- 大多数 MyBatis 应用程序将配置一个如示例中的 dataSource。然而，这不是必需的。请注意，如果要支持延迟加载，则必须配置dataSource。\r\n- 内置了三种 dataSource 类型（即 type=\"[UNPOOLED|POOLED|JNDI]\"）：\r\n##### 总结部分\r\n\r\nUNPOOLED: 每次请求时都会打开和关闭连接，适用于不需要高可用连接（随用随连）的简单应用程序以及对性能要求不高的数据库。\r\n- UNPOOLED DataSource 具有以下属性：driver[class of JDBC driver] url username password\r\n	- defaultTransactionIsolationLevel – 连接的默认事务隔离级别。\r\n	    - NONE 数据库默认隔离级别\r\n	    - READ_UNCOMMITED 可以读取未提交数据的更改，可能导致脏读/不可重复读/幻读。\r\n	    - READ_COMMITTED 只能读取已提交数据的更改，可能不可重复读/幻读。\r\n	    - REPEATABLE_READ 在同一事务中多次读取相同数据时，数据保持一致，可能幻读。\r\n	    - SERIALIZABLE 事务会锁定访问的数据，什么都不可能发生，但是会导致性能下降，并发受到限制。\r\n             - 脏读：主要是因为没有提交。\r\n             - 不可重复读：行内容对不上。不可重复读发生在一个事务在多次读取同一行数据时，得到了不同的结果。这是因为在事务执行期间，另一个事务修改了同一行数据。\r\n             - 幻读：行数量对不上。幻读发生在一个事务在同一个查询中多次执行时，发现了不同数量的行。这是因为在事务执行期间，另一个事务插入或删除了符合查询条件的行。\r\n	- defaultNetworkTimeout – 默认等待数据库操作完成的时间（以毫秒为单位）。\r\n    > 您还可以将属性传递给数据库驱动程序。要做到这一点，请使用 driver. 前缀，例如：\r\n    \r\n	- driver.encoding=UTF8\r\n            这将通过 DriverManager.getConnection(url, driverProperties) 方法将属性 encoding 的值设置为 UTF8，传递给您的数据库驱动程序。\r\n\r\nPOOLED - 此实现的 DataSource 使用连接池来避免创建新的 Connection 实例所需的初始连接和身份验证时间。这是用于并发Web应用程序以实现最快响应的常见方法。\r\n    属性：\r\n- poolMaximumActiveConnections - 此属性表示在任何给定时间可以存在的活动（即正在使用的）连接数。默认值：10\r\n- poolMaximumIdleConnections - 可以在任何给定时间存在的空闲连接数。\r\n- poolMaximumCheckoutTime - 这是在被强制结束之前，连接可以自行登出的最大时间。默认值：20000毫秒（即20秒）\r\n- poolTimeToWait - 这是一个低级别设置，设置后，如果获得连接的时间过长，连接池才有机会打印日志状态并进行重试。（以免配置不正确导致启动失败却无报错无重试）。默认值：20000毫秒（即20秒）\r\n- poolMaximumLocalBadConnectionTolerance - 这是有关线程获得坏连接的容忍度的低级别设置。如果线程获得了坏连接，它仍然可以有另一次尝试获取另一个有效连接的机会。但是，重试次数不应超过 poolMaximumIdleConnections 和 poolMaximumLocalBadConnectionTolerance 的总和。默认值：3（自3.4.5版本以来）\r\n- poolPingQuery - Ping查询用于验证连接是否正常工作并准备接受请求。默认值为 \"NO PING QUERY SET\"，这将使大多数数据库驱动不正常工作的时候显示合理的错误消息，所以非必要不要更改。\r\n- poolPingEnabled - 这启用或禁用ping查询。如果启用，您还必须将 poolPingQuery 的值设置为有效的SQL语句（最好是执行快速的）。默认值：false。\r\n- poolPingConnectionsNotUsedFor - 这配置了池将使用 poolPingQuery 的频率。可以与数据库连接的最大超时时间相同，以避免不必要的ping。默认值：0（即每次都会ping所有连接 - 但前提是 poolPingEnabled 为true）。\r\n\r\nJNDI - 此 DataSource 实现适用于容器，如EJB或应用程序服务器，它们可以在JNDI上下文中配置DataSource并放置对它的引用，用于告诉 MyBatis 使用 JNDI 来查找和获取数据源。此DataSource配置仅需要两个属性：\r\n- initial_context - 用于从 InitialContext 里查找上下文([Context])（即 initialContext.lookup(initial_context)）。此属性是可选的，如果省略，则将直接从 InitialContext 里直接查找 data_source 属性。\r\n- data_source - 数据源实例的引用所在的上下文路径。它将针对由 initial_context 找到的上下文[Context]进行查找，如果没有提供 initial_context 属性，则将直接从 InitialContext 里查找。\r\n> 与其他DataSource配置类似，可以通过在属性前缀 env. 来将属性直接发送到 InitialContext，例如：\r\n- env.encoding=UTF8\r\n        这将把属性 encoding 的值作为 UTF8 直接发送到 InitialContext 构造函数。\r\n\r\nNOTE: 您可以通过实现 org.apache.ibatis.datasource.DataSourceFactory 接口来插入任何第三方DataSource。\r\n\r\n> 添加包：c3p0-0.9.5.5.jar mchange-commons-java-0.2.20.jar\r\n\r\n- 自定义接口 dataSourceFactoryImpl/DataSourceFactoryImpl\r\n```\r\nimport com.mchange.v2.c3p0.*;\r\nimport org.apache.ibatis.datasource.DataSourceFactory;\r\nimport org.apache.ibatis.reflection.MetaObject;\r\nimport org.apache.ibatis.reflection.SystemMetaObject;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.util.Properties;\r\n\r\npublic class DataSourceFactoryImpl implements DataSourceFactory {\r\n\r\n    private DataSource dataSource;\r\n\r\n    public DataSourceFactoryImpl() {\r\n        this.dataSource = new ComboPooledDataSource(); //只有它有driver, url, user, pass属性\r\n    }\r\n\r\n    // 参考：https://github.com/fuzhengwei/CodeGuide/blob/e9ff44b894ba2033bee782573b3f0fb33ad1f097/docs/md/spring/develop-mybatis/2022-05-03-%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E6%8A%8A%E5%8F%8D%E5%B0%84%E7%94%A8%E5%88%B0%E5%87%BA%E7%A5%9E%E5%85%A5%E5%8C%96.md?plain=1#L465\r\n    @Override\r\n    public void setProperties(Properties props) { // 通过 反射 的方式控制数据源的属性\r\n        System.out.println(\"setting\");\r\n        MetaObject metaObject = SystemMetaObject.forObject(dataSource);\r\n\r\n        if (metaObject.hasSetter(\"dmds\")) {\r\n            DriverManagerDataSource dmds = (DriverManagerDataSource) metaObject.getValue(\"dmds\"); // 上一层为dmds\r\n            MetaObject metaObjectDMDS = SystemMetaObject.forObject(dmds);\r\n            for (Object key : props.keySet()) {\r\n                String propertyName = (String) key;\r\n                String str[] = metaObjectDMDS.getSetterNames();\r\n                if (metaObjectDMDS.hasSetter(propertyName)) { // 查看数据源是否有该类型\r\n                    String value = (String) props.get(propertyName);\r\n                    Object convertedValue = convertValue(metaObject, propertyName, value);\r\n                    metaObjectDMDS.setValue(propertyName, convertedValue);\r\n                }\r\n            }\r\n            metaObject.setValue(\"dmds\", dmds);\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public DataSource getDataSource() {\r\n        return this.dataSource;\r\n    }\r\n\r\n    // https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/datasource/unpooled/UnpooledDataSourceFactory.java\r\n    private Object convertValue(MetaObject metaDataSource, String propertyName, String value) {\r\n        Object convertedValue = value;\r\n        Class<?> targetType = metaDataSource.getSetterType(propertyName); // 获取元数据中设定的类型\r\n        if (targetType == Integer.class || targetType == int.class) {\r\n            convertedValue = Integer.valueOf(value);\r\n        } else if (targetType == Long.class || targetType == long.class) {\r\n            convertedValue = Long.valueOf(value);\r\n        } else if (targetType == Boolean.class || targetType == boolean.class) {\r\n            convertedValue = Boolean.valueOf(value);\r\n        }\r\n        return convertedValue; // 返回设置好类型的对象\r\n    }\r\n}\r\n</textarea>\r\n<div >mybatis-config.xml不同的部分</div>\r\n<textarea class=\"code\">\r\n    <dataSource type=\"com.hyh.dataSourceFactoryImpl.DataSourceFactoryImpl\"> <!--它的属性名与POOLED的完全不同-->\r\n        <property name=\"driverClass\" value=\"${oracle_driver}\"/>\r\n        <property name=\"jdbcUrl\" value=\"${oracle_url}\"/>\r\n        <property name=\"user\" value=\"${oracle_username}\"/>\r\n        <property name=\"password\" value=\"${oracle_password}\"/>\r\n    </dataSource>\r\n</textarea>\r\n<div >mybatis-config.xml对UNPOOLED，POOLED和JNDI的属性应用</div>\r\n<textarea class=\"code\">\r\n            <!--unpooled只支持READ_COMMITED和SERIALIZABLE，主要因为每次创建新的连接。不可能同连接同时访问-->\r\n            <dataSource type=\"UNPOOLED\"> <!--org.apache.ibatis.datasource.unpooled.UnpooledDataSource 中可以找到Connection.READ_COMMITTED是里面的常量-->\r\n                <property name=\"driver\" value=\"${oracle_driver}\"/>\r\n                <property name=\"url\" value=\"${oracle_url}\"/>\r\n                <property name=\"username\" value=\"${oracle_username}\"/>\r\n                <property name=\"password\" value=\"${oracle_password}\"/>\r\n                <property name=\"defaultTransactionIsolationLevel\" value=\"2\"/>\r\n                <!-- * 接口名：Connection\r\n                int TRANSACTION_NONE             = 0;\r\n                int TRANSACTION_READ_UNCOMMITTED = 1;\r\n                int TRANSACTION_READ_COMMITTED   = 2;\r\n                int TRANSACTION_REPEATABLE_READ  = 4;\r\n                int TRANSACTION_SERIALIZABLE     = 8;-->\r\n                <property name=\"defaultNetworkTimeout\" value=\"1000\"/>\r\n            </dataSource>\r\n\r\n            <!--新文件-->\r\n            <dataSource type=\"POOLED\"> <!--org.apache.ibatis.datasource.pooled.pooledDataSource-->\r\n                <property name=\"driver\" value=\"${oracle_driver}\"/>\r\n                <property name=\"url\" value=\"${oracle_url}\"/>\r\n                <property name=\"username\" value=\"${oracle_username}\"/>\r\n                <property name=\"password\" value=\"${oracle_password}\"/>\r\n                <property name=\"poolMaximumActiveConnections\" value=\"20\"/>\r\n                <property name=\"poolMaximumIdleConnections\" value=\"5\"/>\r\n                <property name=\"poolMaximumCheckoutTime\" value=\"30000\"/>\r\n                <property name=\"poolTimeToWait\" value=\"25000\"/>\r\n                <property name=\"poolMaximumLocalBadConnectionTolerance\" value=\"5\"/>\r\n                <property name=\"poolPingQuery\" value=\"select * from mybatis_user where id = 1\"/>\r\n                <property name=\"poolPingEnabled\" value=\"true\"/>\r\n                <property name=\"poolPingConnectionsNotUsedFor\" value=\"30000\"/>\r\n            </dataSource>\r\n</textarea>\r\n<div >\r\n<pre>\r\n    org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory 可以作为构建新的数据源适配器的父类使用。\r\n\r\n    - C3P0DataSourceFactory类\r\n    * mybatis-config.xml和上面的一样\r\n</pre>\r\n</div>\r\n<textarea class=\"code\">\r\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\r\nimport org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;\r\n\r\npublic class C3P0DataSourceFactory extends UnpooledDataSourceFactory {\r\n\r\n    public C3P0DataSourceFactory() {\r\n        this.dataSource = new ComboPooledDataSource();\r\n    }\r\n}\r\n```\r\n<div >\r\n    <h4>JNDI的应用(spring + mybatis)：是对容器设置的应用</h4>\r\n    JNDI在mybatis中底层连接池就是DBCP(2)，详情看 <a href=\"#dbcp\">这里</a>  <br>\r\n<pre>\r\n* context.xml！！！！！！这个文件一定在tomcat安装路径下的conf里contex.xml添加，也就是是tomcat容器本身的环境配置\r\n    - 对web.xml的修改也是在tomcat目录下修改\r\n    - 需要在目录下lib文件夹添加jdbc的包 eg:ojdbc8.jar\r\n</pre>\r\n\r\n- tomcat路径下context.xml\r\n</div>\r\n\r\n```\r\n<!--！！！！！！这个文件一定在tomcat安装路径下的conf里contex.xml添加-->\r\n<Resource name=\"jdbc/test\" auth=\"Container\"\r\n      type=\"javax.sql.DataSource\"\r\n      driverClassName=\"com.mysql.jdbc.Driver\"\r\n      url=\"jdbc:oracle:thin:@localhost:1521:orcl\"\r\n      username=\"hyh\"\r\n      password=\"123456\"\r\n      maxActive=\"100\" maxIdle=\"30\" maxWait=\"10000\"\r\n      removeAbandoned=\"true\"\r\n      removeAbandonedTimeout=\"60\"\r\n      logAbandoned=\"true\"\r\n/>\r\n```\r\n<div >tomcat路径下web.xml添加</div>\r\n\r\n```\r\n<resource-ref>\r\n    <description>Oracle Datasource example</description>\r\n    <res-ref-name>jdbc/test</res-ref-name>\r\n    <res-type>javax.sql.DataSource</res-type>\r\n    <res-auth>Container</res-auth>\r\n</resource-ref>\r\n```\r\n<div >spring基本设置</div>\r\n\r\n```\r\n    ++ applicationContext.xml\r\n    <context:component-scan base-package=\"web.hyh\"/>\r\n\r\n    ++ dispatcher-servlet.xml\r\n    <context:component-scan base-package=\"web.hyh.controller\"/>\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\">\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n        <property name=\"suffix\" value=\".jsp\"/>\r\n    </bean>\r\n\r\n    ++ web.xml\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>\r\n            /WEB-INF/applicationContext.xml\r\n        </param-value>\r\n    </context-param>\r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n    <servlet>\r\n        <servlet-name>dispatcher</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n    <servlet-mapping>\r\n        <servlet-name>dispatcher</servlet-name>\r\n        <url-pattern>/</url-pattern>\r\n    </servlet-mapping>\r\n\r\n    ++ index.jsp\r\n    <body>\r\n        <% response.sendRedirect( \"/index\" ); %>\r\n    </body>\r\n```\r\n<div >web.hyh.controller.IndexController类</div>\r\n\r\n```\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport web.hyh.service.DataProcess;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\n@Controller\r\npublic class IndexController {\r\n\r\n    @Autowired\r\n    DataProcess dataProcess;\r\n\r\n    @RequestMapping(\"/index\")\r\n    public String handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) {\r\n\r\n        dataProcess.index(httpServletRequest, httpServletResponse);\r\n\r\n        return \"index\";\r\n    }\r\n\r\n}\r\n```\r\n<div >\r\n    web.hyh.service包内内容\r\n</div>\r\n\r\n```\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\n\r\npublic interface DataProcess {\r\n    void index(HttpServletRequest request, HttpServletResponse response);\r\n    void setDataProcess(HttpServletRequest request, HttpServletResponse response);\r\n\r\n    int StaticExample = 1;\r\n}\r\n-----------------------------------------------\r\npackage web.hyh.service.impl;\r\n\r\nimport com.hyh.dao.TestMapperInterface;\r\nimport com.hyh.pojo.User;\r\nimport com.sun.deploy.net.HttpResponse;\r\nimport org.apache.ibatis.io.Resources;\r\nimport org.apache.ibatis.session.SqlSession;\r\nimport org.apache.ibatis.session.SqlSessionFactory;\r\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\r\nimport org.springframework.stereotype.Service;\r\nimport web.hyh.service.DataProcess;\r\n\r\nimport javax.naming.Context;\r\nimport javax.naming.InitialContext;\r\nimport javax.naming.NamingException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.HttpSession;\r\nimport javax.sql.DataSource;\r\nimport java.io.*;\r\nimport java.sql.Connection;\r\nimport java.sql.SQLException;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\n@Service\r\npublic class DataProcessImpl implements DataProcess {\r\n\r\n    protected HttpServletRequest request;\r\n    protected HttpServletResponse response;\r\n\r\n    private HttpSession session;\r\n    private PrintWriter out;\r\n\r\n    public DataProcessImpl() {\r\n    }\r\n\r\n    public void setDataProcess(HttpServletRequest request, HttpServletResponse response) {\r\n        this.request = request;\r\n        this.response = response;\r\n\r\n        try {\r\n            response.setContentType(\"text/html\");\r\n            response.setCharacterEncoding(\"UTF-8\");\r\n            out = response.getWriter();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n        session = request.getSession();\r\n    }\r\n\r\n    @Override\r\n    public void index(HttpServletRequest request, HttpServletResponse response) {\r\n        setDataProcess(request, response);\r\n\r\n        SqlSessionFactory factory = giveFactory();\r\n        SqlSession sqlSession = factory.openSession();\r\n        out.print(sqlSession.getMapper(TestMapperInterface.class).getAll());\r\n        out.flush();\r\n        System.out.println(sqlSession.getMapper(TestMapperInterface.class).getAll());\r\n    }\r\n\r\n    public SqlSessionFactory giveFactory() { //启用mybatis配置文件\r\n        SqlSessionFactory factory = null;\r\n        try {\r\n            InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); //使用\r\n            factory = new SqlSessionFactoryBuilder().build(inputStream);\r\n            inputStream.close();\r\n        } catch (IOException exception) {\r\n            exception.printStackTrace();\r\n        }\r\n\r\n        factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n        System.out.println(factory.getConfiguration().getDatabaseId());\r\n\r\n        return factory;\r\n    }\r\n\r\n}\r\n```\r\n\r\n<div >mybatis-config.xml修改部分</div>\r\n\r\n```\r\n    <dataSource type=\"JNDI\">\r\n        <property name=\"initial_context\" value=\"java:/comp/env\"/> <!--在java:/comp/env这个上下文里查找 https://github.com/yeecode/MyBatisCN/blob/489e130b318d4e46f0b2e70a5ed71b25914bda20/src/main/java/org/apache/ibatis/datasource/jndi/JndiDataSourceFactory.java#L40-->\r\n        <property name=\"data_source\" value=\"/jdbc/test\"/>\r\n    <dataSource/>\r\n```\r\n<div >\r\n       <h3>mybatis-config.xml settings属性大全</h3>\r\n    </div>\r\n    \r\n```\r\n<settings>\r\n\r\n    <!--settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定-->\r\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n    <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->\r\n\r\n    <!-- 使全局的映射器启用或禁用缓存。 -->\r\n    <setting name=\"cacheEnabled\" value=\"true\"/>\r\n\r\n    <!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 -->\r\n    <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n\r\n    <!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 -->\r\n    <setting name=\"aggressiveLazyLoading\" value=\"true\"/>\r\n\r\n    <!-- 是否允许单条sql 返回多个数据集  (取决于驱动的兼容性) default:true -->\r\n    <setting name=\"multipleResultSetsEnabled\" value=\"true\"/>\r\n\r\n    <!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true -->\r\n    <setting name=\"useColumnLabel\" value=\"true\"/>\r\n\r\n    <!-- 允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。  default:false  -->\r\n    <setting name=\"useGeneratedKeys\" value=\"false\"/>\r\n\r\n    <!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不隐射　PARTIAL:部分  FULL:全部  -->\r\n    <setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/>\r\n\r\n    <!-- 这是默认的执行类型  （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新）  -->\r\n    <setting name=\"defaultExecutorType\" value=\"SIMPLE\"/>\r\n\r\n    <!-- 使用驼峰命名法转换字段。 -->\r\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/>\r\n\r\n    <!-- 设置本地缓存范围 session:就会有数据的共享  statement:语句范围 (这样就不会有数据的共享 ) defalut:session -->\r\n    <setting name=\"localCacheScope\" value=\"SESSION\"/>\r\n\r\n    <!-- 当参数没有设置(JDBC)数据类型的时候，设定该参数的null值的数据类型。某些数据库驱动要指定数据类型，某些不需要指定类型，可以直接使用通用值比如null, varchar 或者 other-->\r\n    <setting name=\"jdbcTypeForNull\" value=\"NULL\"/>\r\n\r\n</settings>\r\n```\r\n <div >\r\n     <h3>mybatis日志</h3>\r\n     \r\n1. `日志的配置`：MyBatis 允许您配置日志记录器（Logger），这些日志记录器用于捕获 MyBatis 执行的详细信息。通常，您可以选择不同的日志记录器实现，例如 Log4j、Logback、Slf4j、Java Util Logging 等。<br>\r\n2. `MyBatis 的日志级别`：MyBatis 通常支持不同的日志级别，如 DEBUG、INFO、WARN 和 ERROR。您可以根据需要配置所需的日志级别。通常情况下，在开发和调试阶段，将日志级别设置为 DEBUG 可以显示详细的 SQL 执行信息。<br>\r\n3. `日志的输出位置`：您可以配置日志输出的位置，通常可以将日志输出到控制台、文件或其他自定义位置。这可以通过配置日志框架的 appender 或 MyBatis 的配置文件来完成。<br>\r\n4. `MyBatis 内置的日志实现`：MyBatis 通常包括一个内置的日志实现，它可以用于快速设置和查看日志。但在生产环境中，通常会使用更强大的日志框架。<br>\r\n5. `使用 SLF4J 适配器`：SLF4J（Simple Logging Facade for Java）是一个常用的日志门面，它可以与不同的日志实现（如 Log4j、Logback）一起使用。MyBatis 提供了 SLF4J 的适配器，以便您可以将 MyBatis 的日志输出集成到您的 SLF4J 日志系统中。<br>\r\n6. `示例配置`：官方文档通常提供示例配置，以帮助用户配置适当的日志记录器和级别。<br>\r\n7. `生产环境的最佳实践`：文档通常会提供关于在生产环境中如何配置和使用日志的最佳实践建议，以确保日志记录不会对性能产生不利影响。<br>\r\n\r\nNOTE: chatGPT同一对话保存信息太多会变卡，记得新开一个。<br>\r\n<h4>mybatis日志官方文档（翻译润色自chatGPT）</h4>\r\n<pre>\r\nmybatis使用内部日志工厂来生成日志，内部日志工厂会将日志信息委派给下列日志实现中的一个：\r\n    SLF4J\r\n    Apache Commons Logging\r\n    Log4j 2\r\n    Log4j\r\n    JDK logging\r\n具体选择的实现由mybatis内部的日志工厂在运行时审查决定。MyBatis日志工厂将使用它找到的第一个日志实现（按上述顺序搜索实现）。如果MyBatis找不到上述任何实现，则日志记录将被禁用。\r\n\r\n许多环境将Commons Logging装载为应用内路径的一部分（例如Tomcat和WebSphere），在这种环境中，MyBatis将使用Commons Logging作为日志实现，这意味着您的Log4J配置将被忽略，但如果您更愿意使用其他日志实现，您可以通过在mybatis-config.xml文件中添加以下设置来选择不同的日志实现：\r\n</pre>\r\n- mybatis-config.xml\r\n\r\n```\r\n<settings> <!-- settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定 -->\r\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n    <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->\r\n</settings>\r\n```\r\n<div >你也可以使用以下方法设定LogFactory的类型：(前提是你的路径里面有该日志实现，否则mybatis就会忽略它)</div>\r\n\r\n```\r\n@Test\r\npublic void testForInterfacePlusXMLWithLog() {\r\n    System.out.println(\"============Test testForInterfacePlusXMLWithLog=============\");\r\n\r\n    SqlSessionFactory factory = giveFactory();\r\n    LogFactory.useSlf4jLogging(); //选择org.apache.ibatis.logging.LogFactory\r\n    //        报错没找到路径，可能mybatis虽然忽略没有路径的配置，但它下面的LoggerFactory不会，仍然会报错\r\n    //        甚至底层可以看见它是抛出了异常的 可以用try catch跳过  <好想死>\r\n    //        添加包：slf4j-api-1.7.32.jar\r\n    org.apache.ibatis.logging.LogFactory.useLog4JLogging();\r\n    //log4j-1.2.17.jar log4j-slf4j-impl-3.0.0-alpha1.jar log4j-api-2.17.2.jar log4j-core-2.11.2.jar\r\n    System.setProperty(\"myproperty\", \"F:\\\\JAVA\\\\20230925\\\\mybitis\\\\src\\\\resources\\\\log4j2.properties\");\r\n    org.apache.ibatis.logging.LogFactory.useLog4J2Logging();\r\n    //提示需要设置配置文件 注意非class文件out和实际文件可能不同步，需要手动复制 卡了好几小时...\r\n    //分析原因：可能是曾经修改项目到maven结构导致的idea识别问题，重新建一个项目就可以解决了。\r\n    org.apache.ibatis.logging.LogFactory.useJdkLogging();\r\n    org.apache.ibatis.logging.LogFactory.useCommonsLogging();\r\n    org.apache.ibatis.logging.LogFactory.useStdOutLogging();\r\n\r\n    try (SqlSession session = factory.openSession()) {\r\n        factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n        System.out.println(factory.getConfiguration().getDatabaseId());\r\n        //在xml里面添加了接口\r\n\r\n        TestMapperInterface tmi = session.getMapper(TestMapperInterface.class);\r\n        System.out.println(\"\" +\r\n                tmi.delete(51) + \" \" +\r\n                tmi.update(45, \"asdf\", \"wee\", 90) + \" \" +\r\n                tmi.insert(23, \"sd\", \"sd\", 88) + \" \" +\r\n                tmi.getAll() + \" \\n\" +\r\n                tmi.selectUser(45)\r\n        ); //这里查找的数据想要改变中途需要commit\r\n\r\n        session.commit();\r\n\r\n    }\r\n}\r\n```\r\n<div >输出（包含StdOutLogging日志内容）</div>\r\n\r\n```\r\n2023-09-30 20:06:36 DEBUG LogFactory:105 - Logging initialized using \'class org.apache.ibatis.logging.log4j2.Log4j2Impl\' adapter.\r\nLogging initialized using \'class org.apache.ibatis.logging.stdout.StdOutImpl\' adapter.\r\noracle\r\nOpening JDBC Connection\r\nSetting autocommit to false on JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]\r\ntrue true true [User{id=175, name=\'sd\', sex=\'sd\', age=88}, User{id=45, name=\'asdf\', sex=\'wee\', age=90}, User{id=42, name=\'WWW\', sex=\'W\', age=10}, User{id=43, name=\'WWW\', sex=\'W\', age=10}, User{id=44, name=\'WWW\', sex=\'W\', age=10}, User{id=46, name=\'WWW\', sex=\'W\', age=10}, User{id=47, name=\'WWW\', sex=\'W\', age=10}, User{id=48, name=\'WWW\', sex=\'W\', age=10}, User{id=49, name=\'WWW\', sex=\'W\', age=10}, User{id=50, name=\'WWW\', sex=\'W\', age=10}]\r\nUser{id=45, name=\'asdf\', sex=\'wee\', age=90}\r\nRolling back JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]\r\nResetting autocommit to true on JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]\r\nClosing JDBC Connection [oracle.jdbc.driver.T4CConnection@f1da57d]\r\n```\r\n要查看MyBatis的日志记录语句，您可以针对一些对象启用日志，其中包含一个包，一个mapper指向的类或其中的namespace或一个合法的sql语句id名。\r\n\r\n> 如何实现这一点取决于所使用的日志记录实现方式。我们将展示如何使用Log4J来实现它。配置日志服务只是简单地包含一个或多个额外的配置文件（例如log4j.properties）和有时一个新的JAR文件（例如log4j.jar）。以下示例配置将使用Log4J作为提供者配置完整的日志记录服务。共有2个步骤。\r\n\r\n- 第一步：添加包\r\n\r\n- 第二步：配置\r\n    log4j.properties文件\r\n```\r\n# Global logging configuration\r\nlog4j.rootLogger=ERROR, stdout\r\n# MyBatis logging configuration...\r\nlog4j.logger.com.hyh.dao.TestDao=TRACE\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n    </textarea>\r\n    <div >打印出如下所示的日志</div>\r\n    <textarea class=\"code\">\r\nXMLSelect\r\nOpening JDBC Connection\r\nSetting autocommit to false on JDBC Connection [oracle.jdbc.driver.T4CConnection@5c3b6c6e]\r\nDEBUG [main] - ==>  Preparing: SELECT * FROM mybatis_user\r\nDEBUG [main] - ==> Parameters:\r\nTRACE [main] - <==    Columns: ID, NAME, SEX, AGE\r\nTRACE [main] - <==        Row: 51, WWW, W, 10\r\nTRACE [main] - <==        Row: 45, WWW, W, 10\r\nTRACE [main] - <==        Row: 42, WWW, W, 10\r\n...\r\nDEBUG [main] - <==      Total: 10\r\nDEBUG [main] - ==>  Preparing: select * from mybatis_user where id = ?\r\nDEBUG [main] - ==> Parameters: 51(Integer)\r\nTRACE [main] - <==    Columns: ID, NAME, SEX, AGE\r\nTRACE [main] - <==        Row: 51, WWW, W, 10\r\nDEBUG [main] - <==      Total: 1\r\n[User{id=51, name=\'WWW\', sex=\'W\', age=10}, User{id=45, name=\'WWW\', sex=\'W\', age=10}, User{id=42, name=\'WWW\', sex=\'W\', age=10}, User{id=43, name=\'WWW\', sex=\'W\', age=10}, User{id=44, name=\'WWW\', sex=\'W\', age=10}, User{id=46, name=\'WWW\', sex=\'W\', age=10}, User{id=47, name=\'WWW\', sex=\'W\', age=10}, User{id=48, name=\'WWW\', sex=\'W\', age=10}, User{id=49, name=\'WWW\', sex=\'W\', age=10}, User{id=50, name=\'WWW\', sex=\'W\', age=10}]\r\nUser{id=51, name=\'WWW\', sex=\'W\', age=10}\r\nDEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual\r\nDEBUG [main] - ==> Parameters:\r\nTRACE [main] - <==    Columns: NEXTVAL\r\nTRACE [main] - <==        Row: 179\r\nDEBUG [main] - <==      Total: 1\r\nDEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)\r\nDEBUG [main] - ==> Parameters: 179(Integer), WWW(String), W(String), 10(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - ==>  Preparing: update mybatis_user SET name=?, sex=?, age=? where id=?\r\nDEBUG [main] - ==> Parameters: xxxpoipioip(String), op(String), 9(Integer), 51(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?\r\nDEBUG [main] - ==> Parameters: 51(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?\r\nDEBUG [main] - ==> Parameters: 45(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\n```\r\n\r\n<div >\r\n\r\n上面的文件将导致log4J对org.mybatis.example.BlogMapper报告详细的日志，而对您应用程序的其余类只报告错误日志。\r\n\r\n如果您想更精细地调整日志记录级别，可以为特定语句打开日志记录，而不是整个映射器文件。例如下面语句只对更新操作报告日志：\r\n\r\n> log4j.logger.com.hyh.mapper.TestDao.update=TRACE\r\n\r\n如果想对多个mappers打印日志，你可以将以上条目修改为其包所在的根目录\r\n\r\n> log4j.logger.com.hyh.dao=TRACE\r\n\r\n有一些查询可能会返回大量的结果集。在这种情况下，您可能希望查看SQL语句，但不需要看到结果。出于这个目的，SQL语句被记录在DEBUG级别（在JDK日志中是FINE级别），而结果则在TRACE级别（在JDK日志中是FINER级别）记录。因此，如果您想查看语句但不需要查看结果，将日志级别设置为DEBUG。\r\n\r\n> log4j.logger.com.hyh.dao=DEBUG\r\n\r\n\r\n- debug输出内容\r\n </div>\r\n \r\n```\r\nDEBUG [main] - ==>  Preparing: select * from mybatis_user where id = ?\r\nDEBUG [main] - ==> Parameters: 51(Integer)\r\nDEBUG [main] - <==      Total: 1\r\n[User{id=51, name=\'WWW\', sex=\'W\', age=10}, User{id=45, name=\'WWW\', sex=\'W\', age=10}, User{id=42, name=\'WWW\', sex=\'W\', age=10}, User{id=43, name=\'WWW\', sex=\'W\', age=10}, User{id=44, name=\'WWW\', sex=\'W\', age=10}, User{id=46, name=\'WWW\', sex=\'W\', age=10}, User{id=47, name=\'WWW\', sex=\'W\', age=10}, User{id=48, name=\'WWW\', sex=\'W\', age=10}, User{id=49, name=\'WWW\', sex=\'W\', age=10}, User{id=50, name=\'WWW\', sex=\'W\', age=10}]\r\nUser{id=51, name=\'WWW\', sex=\'W\', age=10}\r\nDEBUG [main] - ==>  Preparing: select mybatis_seq.nextVal from dual\r\nDEBUG [main] - ==> Parameters:\r\nDEBUG [main] - <==      Total: 1\r\nDEBUG [main] - ==>  Preparing: insert into mybatis_user values (?, ?, ?, ?)\r\nDEBUG [main] - ==> Parameters: 188(Integer), WWW(String), W(String), 10(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - ==>  Preparing: update mybatis_user SET name=?, sex=?, age=? where id=?\r\nDEBUG [main] - ==> Parameters: xxxpoipioip(String), op(String), 9(Integer), 51(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\nDEBUG [main] - ==>  Preparing: delete from mybatis_user where id = ?\r\nDEBUG [main] - ==> Parameters: 51(Integer)\r\nDEBUG [main] - <==    Updates: 1\r\n```\r\n<div >\r\n<pre>\r\n在对日志记录对象的设置中如果增删查改使用的是接口那么设置的就是包名，如果使用的是xml那么设置的是namespace和sql语句的id值。也就是说两者的设置差别不大。\r\n</pre>\r\n<h3>连接池：它是一种多用户释放资源的策略</h3>\r\n<a href=\"https://blog.csdn.net/qq_30257081/article/details/86554585\">\r\n    https://blog.csdn.net/qq_30257081/article/details/86554585\r\n</a>\r\n<pre>\r\n连接池的优点\r\n    1.资源重用\r\n    2.提升系统响应速度\r\n    3.避免数据库连接遗漏\r\n它定义的工作原理\r\n    S1. 当服务器启动时，创建一些连接放在连接池中，等待客户端请求。\r\n    S2. 当客户端发来请求需要连接数据库时，容器首先查看连接池中是否有可用的连接，如果有，则返回将连接返回；如果没有则查看当前的连接数是否超过了最大的可用连接数。如果没有超过，则创建新的链接返回；如果超过了，则抛出无可用连接的异常。\r\n    S3. 当连接使用完毕后，连接再次被放回到连接池中，从而实现连接的重用。\r\n</pre>\r\n\r\n1. dbcp<br>\r\n2. c3p0:基于dbcp<br>\r\n3. DBUtils:基于dbcp和dbutil<br>\r\n4. druid:它是一个独立的国有连接池，中文名德鲁伊<br>\r\n\r\n如果您需要一个轻量级的连接池，可以考虑使用DBCP。对于更高级的连接池管理功能，C3P0和Druid是更好的选择。DBUtils则适用于需要简化JDBC操作的场景，通常与其它连接池库(如DBCP或C3PO)一起使用。\r\n- 性能比较：\r\n> druid > DBUtil > dbcp > c3p0\r\n<h4 id=\"dbcp\">1.dbcp</h4>\r\n        Apache DBCP（Database Connection Pool）是一个开源的Java连接池库，用于管理和维护数据库连接。它的底层工作原理涉及以下几个关键组件和步骤：<br>\r\n\r\n1.`数据源（DataSource）`：DBCP使用数据源来创建和管理数据库连接。数据源通常是数据库驱动程序提供的实现。数据源包含有关如何创建和配置连接的信息。<br>\r\n\r\n2.`连接池（Connection Pool）`：连接池是连接的缓存，它维护一组可供应用程序使用的数据库连接。连接池的大小可以配置，以确定可以同时支持的最大连接数。它的主要作用是为了避免反复开启/结束对数据库的连接，具有即用性。<br>\r\n\r\n3.`连接池管理器（Pool Manager）`：连接池管理器负责维护连接池的状态，包括创建、释放、回收和管理连接。它确保连接的可用性，并防止连接泄漏和资源浪费。<br>\r\n\r\n4.`连接工厂（Connection Factory）`：连接工厂是负责创建数据库连接的组件。它使用数据源配置信息来创建连接，并将这些连接添加到连接池中。<br>\r\n\r\n5.`连接状态跟踪（Connection State Tracking）`：DBCP可以跟踪连接的状态，以检测闲置连接、失效连接和超时连接。这有助于回收和重新利用连接，以减少连接的创建和销毁开销。<br>\r\n- 连接池配置：连接池的配置参数包括最小连接数、最大连接数、连接超时时间、闲置连接检测等。这些参数可以根据应用程序的需求进行调整。<br>\r\n- 连接的获取和释放：应用程序通过请求连接来从连接池中获取连接，使用完后，将连接释放回池中。连接池管理器会确保连接的有效性，并在需要时重新创建连接或回收不再使用的连接。<br>\r\n<br>\r\n\r\n> 总的来说，DBCP通过维护连接池、跟踪连接状态和提供连接管理功能，使得应用程序可以高效地使用数据库连接，并在需要时动态创建和销毁连接，从而降低了数据库连接的开销，提高了应用程序的性能和可伸缩性。<br>\r\n\r\n dbcp实现添加包:\r\n- commons-dbcp:commons-dbcp\r\n- commons-pool:commons-pool\r\n- commons-collections:commons-collections\r\n\r\n > DBCPDataSourceFactory类\r\n\r\n```\r\nimport org.apache.ibatis.datasource.pooled.PooledDataSourceFactory;\r\nimport org.apache.commons.dbcp.BasicDataSource;\r\n\r\npublic class DBCPDataSourceFactory extends PooledDataSourceFactory {\r\n\r\n    public DBCPDataSourceFactory() {\r\n        this.dataSource = new BasicDataSource();\r\n    }\r\n}\r\n```\r\n<div >\r\n    TransactionImpl自定义类的修改\r\n</div>\r\n\r\n```\r\n@Override\r\npublic Integer getTimeout() throws SQLException {\r\n    LOGGER.debug(() -> {\r\n        return \"HAMSTER Connection [\" + this.connection + \"] is checking timeout\";\r\n    });\r\n    return this.connection.createStatement().getQueryTimeout(); // 因为DBCP没有实现获取网络超时时间，就只能获取sql语句执行超时时间\r\n}\r\n```\r\n<div ><h4>dbcp config-mybatis.xml文件及属性大全</h4></div>\r\n\r\n```\r\n<dataSource type=\"com.hyh.dataSourceFactoryImpl.DBCPDataSourceFactory\">\r\n    <property name=\"driverClassName\" value=\"${oracle_driver}\"/>\r\n    <property name=\"url\" value=\"${oracle_url}\"/>\r\n    <property name=\"username\" value=\"${oracle_username}\"/>\r\n    <property name=\"password\" value=\"${oracle_password}\"/>\r\n\r\n    <!--初始化连接:连接池启动时创建的初始化连接数量-->\r\n    <property name=\"initialSize\" value=\"3\"/>\r\n\r\n    <!--最大活跃数-->\r\n    <property name=\"maxActive\" value=\"20\"/>\r\n\r\n    <!--最大空闲连接:连接池中容许保持空闲状态的最大连接数量,超过的空闲连接将被释放,如果设置为负数表示不限制-->\r\n    <property name=\"maxIdle\" value=\"10\"/>\r\n\r\n    <!--最小空闲连接:连接池中容许保持空闲状态的最小连接数量,负数表示没有现在-->\r\n    <!--如果空闲连接的数量设置的太少且系统负载高，有可能导致实际的空闲连接超过最大空闲连接的限制，因为关闭连接的速度比打开连接的速度快，所以有许多被关闭的连接保持空闲等待被打开的连接，这就导致了实际空闲连接会大于最大空闲连接-->\r\n    <property name=\"minIdle\" value=\"2\"/>\r\n\r\n    <!--最大等待时间:当没有可用连接时,连接池等待连接被归还的最大时间(以毫秒计数),超过时间则抛出异常,如果设置为-1表示无限等待-->\r\n    <property name=\"maxWait\" value=\"10000\"/>\r\n\r\n    <!--在将连接返回给调用者之前，一个用来验证从连接池取出连接的可用性的SQL查询，如果指定,则查询必须是一个SELECT语句并且必须返回至少一行记录-->\r\n    <property name=\"validationQuery\" value=\"select * from mybatis_user where id = 1\"/>\r\n\r\n    <!--指明是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个.注意:设置为true后如果要生效,validationQuery参数必须设置为非空字符串-->\r\n    <property name=\"testOnBorrow\" value=\"true\"/>\r\n\r\n    <!--指明是否在归还到池中前进行检验-->\r\n    <property name=\"testOnReturn\" value=\"true\"/>\r\n\r\n    <!--指明连接是否被空闲连接排错器(如果有)进行检验.如果检测失败,则连接将被从池中去除.注意:设置为true后如果要生效,validationQuery参数必须设置为非空字符串-->\r\n    <property name=\"testWhileIdle\" value=\"true\"/>\r\n\r\n    <!--在每次空闲连接排错器线程(如果有)运行时检查的连接数量-->\r\n    <property name=\"numTestsPerEvictionRun\" value=\"3\"/>\r\n\r\n    <!--开启prepared statement池 开启需要添加包：commons-pool-1.6.jar-->\r\n    <property name=\"poolPreparedStatements\" value=\"true\"/>\r\n\r\n    <!--statement池在同一时间能够分配的活跃prepared statements的最大数量,如果设置为0表示不限制\r\n            为了避免最大活跃prepared statements超过最大开启游标数而导致的游标耗尽，请保证最大活跃数小于最大开启游标数-->\r\n    <property name=\"maxOpenPreparedStatements\" value=\"1000\"/>\r\n\r\n    <!--控制PoolGuard是否容许获取底层连接 默认false不开启, 这是一个有潜在危险的功能, 不适当的编码会造成危险.(可能关闭底层连接或者在守护连接已经关闭的情况下继续使用连接).请谨慎使用,并且仅当需要直接访问驱动的扩展功能时使用.注意:不要直接关闭底层连接,只能关闭原本的连接.-->\r\n    <property name=\"accessToUnderlyingConnectionAllowed\" value=\"true\"/>\r\n\r\n    <!--标记是否删除超过removeAbandonedTimout时长连接，如果连接超过时长就会被视作被抛弃的连接。设置该项可以让服务器有空闲去恢复配置糟糕的应用连接-->\r\n        <!--如果开启则连接在被抛弃时可能被回收，当空闲数<2，活跃数>最大活跃数 - 3时且空闲时间大于removeAbandonedTimeout，就会被回收，但如果一旦创建了动态或者静态的statement或者执行了任何一个查询，空闲时间就会清空。-->\r\n    <property name=\"removeAbandoned\" value=\"true\"/>\r\n\r\n    <!--定义为被抛弃并删除的连接前的最大时长-->\r\n    <property name=\"removeAbandonedTimeout\" value=\"500\"/>\r\n\r\n    <!--是否为被抛弃的连接或者Statement生成日志，该日志会在每个连接或者Statement开启的时候不断叠加，因为日志的生成依赖于堆栈信息的生成。-->\r\n    <property name=\"logAbandoned\" value=\"true\"/>\r\n\r\n</dataSource>\r\n```\r\n<div >\r\n      <h4>2. c3p0</h4>\r\n      在 <a href=\"#dataSource\">之前</a> 使用过的类的图表<br>\r\n<!--        <img src=\"c0p3diagram.png\"/>-->\r\n<img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/c3p02.png\" width=\"100%\"/>\r\n\r\n ##### C3PO与DBCP的区别\r\n + C3P0有自动回收空闲连接功能，DBCP没有。\r\n     - maxIdleTime：定义连接在池中保持空闲的最长时间（以毫秒为单位）。默认值为0，表示不启用空闲连接的回收。\r\n     - maxIdleTimeExcessConnections：定义在连接池中保持空闲的超出最小连接数的连接的最长时间。默认值为0。\r\n     - maxConnectionAge：定义连接在池中的最长生命周期，包括使用和空闲时间。默认值为0，表示不限制连接寿命。\r\n - C3P0提供最大空闲时间，DBCP提供最大连接数。\r\n 也就是说C3P0在连接回收方便更复杂，所以在性能表现：DBCP > C3P0\r\n\r\n> 连接代理类：\r\n\r\n```\r\n    com.mchange.v2.c3p0.impl.NewProxyConnection@d554c5f [wrapping: oracle.jdbc.driver.T4CConnection@48fd1fe4]\r\n```\r\n<div >\r\n    <h4>3. DBUtil</h4>\r\n<pre class=\"preText\">\r\nDBUtil的定义：DBUtil 连接池是一个通用的数据库连接池管理工具，用于管理数据库连接的创建、使用和释放，管理它的生命周期。连接池的主要目标是提高数据库连接的重复利用率和性能，减少每次数据库操作都重新创建和关闭连接的开销。\r\n本质：基于DBCP | C3P0 | 德鲁伊连接池，对数据库存取的方法经行了简单封装，它对连接池中连接的操作不需要依靠mybatis\r\n    ————————————————\r\n    比较一下 JDBC, dbutils, Mybatis 和 Hibernate\r\n    JDBC: 原生访问数据库的方式, 其它三个都是对 JDBC 不同程度的包装 访问数据库比较麻烦, 代码重复度极高\r\n    dbutils: 是对jdbc进行了相对简单的包装, 主要就是能自动封装查询结构 集, 需要在代码中写 sql 语句\r\n    Mybatis: 进一步封装 jdbc, Sql 语句写在配置文件中, 面向对象操作, 有一 二级缓存功能\r\n    Hibernate: 对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL\r\n        ———————\r\n        版权声明：本文为CSDN博主「jkljkil」的原创文章。\r\n        原文链接：https://blog.csdn.net/jkljkil/article/details/110723911\r\n    ———————————————\r\n生命周期：\r\n    初始化 -> 获取 -> 操作 -> 释放\r\n    连接池管理：超时处理 -> 连接验证 -> 连接自动回收\r\n    销毁：释放连接 -> 销毁连接池\r\nDBUtil和 (DBCP | C3P0) 相比\r\n    1. dbutil更轻量，比另外两个小。\r\n    2. DBCP和C3P0都相对成熟，有较丰富的社区支持和活跃度，更容易获得更新修复BUG。\r\n    3. 它的性能更好。\r\n</pre>\r\n- 添加包：\r\n	- commons-dbutils-1.7.jar\r\n	- log4j-api的版本需要为2.17.1及以下，否则找不到java.util.Stack org.apache.logging.log4j.util.StackLocatorUtil.getCurrentStackTrace()\r\n\r\n> 注意：IDEA里面properties文件容易乱码，要及时调整在：Settings -> Editor -> File encoding\r\n- 测试文件(使用了之前提到过的DataSourceFactoryImpl类)：\r\n</div>\r\n\r\n```\r\n@Test\r\npublic void testDBUtil() { //RUN UNDER JAVA 11!! --ADD MODULE JAVA-BASE --Add java-module... == all resolved by alt + enter >><<   ---> close by Settings > Build > Execution, Deployment > Compiler > Java Compiler 删除定义的那一条\r\n    DataSourceFactoryImpl dsfi = new DataSourceFactoryImpl(); //为DBUtil封装的工具提供DataSource\r\n    Properties properties = new Properties();\r\n    try {\r\n        FileInputStream fis = new FileInputStream(\"F:\\\\JAVA\\\\20230925\\\\testMybatis\\\\src\\\\c3p0config.properties\");\r\n        properties.load(fis);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    dsfi.setProperties(properties);\r\n    QueryRunner qr = new QueryRunner(dsfi.getDataSource());\r\n\r\n    try {\r\n        List<User> li = (List<User>) qr.query(\"select * from mybatis_user\", new BeanListHandler(User.class));\r\n        System.out.println(li);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n\r\n}\r\n```\r\n<div >c3p0config.properties文件</div>\r\n\r\n```\r\n#<!-- oracle以及反射类的属性 -->\r\ndriverClass=oracle.jdbc.driver.OracleDriver\r\njdbcUrl=jdbc:oracle:thin:@localhost:1521:orcl\r\nuser=hyh\r\npassword=123456\r\n```\r\n<div >输出日志为DBUtil特有的，如下：</div>\r\n\r\n```\r\nC:\\Users\\AJH41\\.jdks\\corretto-11.0.20.1\\bin\\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 \"-javaagent:F:\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar=7457:F:\\IntelliJ IDEA 2021.2.3\\bin\" -Dfile.encoding=UTF-8 -classpath \"F:\\IntelliJ IDEA 2021.2.3\\lib\\idea_rt.jar;F:\\IntelliJ IDEA 2021.2.3\\plugins\\junit\\lib\\junit5-rt.jar;F:\\IntelliJ IDEA 2021.2.3\\plugins\\junit\\lib\\junit-rt.jar;F:\\JAVA\\20230925\\testMybatis\\out\\production\\testMybatis;F:\\JAVA\\20230925\\testMybatis\\lib\\ojdbc8.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\c3p0-0.9.5.5.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\log4j-1.2.17.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\mybatis-3.5.8.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\aopalliance-1.0.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\commons-dbcp-1.4.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\log4j-api-2.17.1.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\slf4j-api-1.7.32.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-dao-2.0.1.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\log4j-core-2.11.2.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\commons-dbutils-1.7.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\commons-logging-1.2.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\mybatis-spring-2.0.1.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-tx-5.2.3.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-aop-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-orm-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-web-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-core-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-beans-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\mchange-commons-java-0.2.20.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-webmvc-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\commons-collections-20040616.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\commons-pool-20030825.183949.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-context-5.2.5.RELEASE.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\log4j-slf4j-impl-3.0.0-alpha1.jar;F:\\JAVA\\20230925\\testMybatis\\lib\\spring-expression-5.2.5.RELEASE.jar;C:\\Users\\AJH41\\.m2\\repository\\junit\\junit\\4.13.1\\junit-4.13.1.jar;C:\\Users\\AJH41\\.m2\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar;C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\lib\\jsp-api.jar;C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\lib\\servlet-api.jar\" com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit4 com.hyh.test.TestUnderJava11,testDBUtil\r\n2023-10-07 13:12:23 INFO  MLog:212 - MLog clients using slf4j logging.\r\n2023-10-07 13:12:23 DEBUG MLog:207 - Reading VM config for path list /com/mchange/v2/log/default-mchange-log.properties, /mchange-commons.properties, /c3p0.properties, hocon:/reference,/application,/c3p0,/, /mchange-log.properties, /\r\n2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier \'/mchange-commons.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier \'/c3p0.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier \'hocon:/reference,/application,/c3p0,/\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier \'/mchange-commons.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MLog:207 - The configuration file for resource identifier \'/mchange-log.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier \'/mchange-log.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier \'hocon:/reference,/application,/c3p0,/\' could not be found. Skipping.\r\n2023-10-07 13:12:23 DEBUG MConfig:207 - The configuration file for resource identifier \'/c3p0.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:24 INFO  C3P0Registry:212 - Initializing c3p0-0.9.5.5 [built 11-December-2019 22:18:33 -0800; debug? true; trace: 10]\r\n2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 registered.\r\n2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 unregistered, in order to be reregistered after update.\r\n2023-10-07 13:12:24 DEBUG DynamicPooledDataSourceManagerMBean:204 - MBean: com.mchange.v2.c3p0:type=PooledDataSource,identityToken=1hgeby9az2devs5yqoxvu|386f0da3,name=1hgeby9az2devs5yqoxvu|386f0da3 registered.\r\nsetting\r\n2023-10-07 13:12:24 INFO  AbstractPoolBackedDataSource:212 - Initializing c3p0 pool... com.mchange.v2.c3p0.ComboPooledDataSource [ acquireIncrement -> 3, acquireRetryAttempts -> 30, acquireRetryDelay -> 1000, autoCommitOnClose -> false, automaticTestTable -> null, breakAfterAcquireFailure -> false, checkoutTimeout -> 0, connectionCustomizerClassName -> null, connectionTesterClassName -> com.mchange.v2.c3p0.impl.DefaultConnectionTester, contextClassLoaderSource -> caller, dataSourceName -> 1hgeby9az2devs5yqoxvu|386f0da3, debugUnreturnedConnectionStackTraces -> false, description -> null, driverClass -> oracle.jdbc.driver.OracleDriver, extensions -> {}, factoryClassLocation -> null, forceIgnoreUnresolvedTransactions -> false, forceSynchronousCheckins -> false, forceUseNamedDriverClass -> false, identityToken -> 1hgeby9az2devs5yqoxvu|386f0da3, idleConnectionTestPeriod -> 0, initialPoolSize -> 3, jdbcUrl -> jdbc:oracle:thin:@localhost:1521:orcl, maxAdministrativeTaskTime -> 0, maxConnectionAge -> 0, maxIdleTime -> 0, maxIdleTimeExcessConnections -> 0, maxPoolSize -> 15, maxStatements -> 0, maxStatementsPerConnection -> 0, minPoolSize -> 3, numHelperThreads -> 3, preferredTestQuery -> null, privilegeSpawnedThreads -> false, properties -> {password=******, user=******}, propertyCycle -> 0, statementCacheNumDeferredCloseThreads -> 0, testConnectionOnCheckin -> false, testConnectionOnCheckout -> false, unreturnedConnectionTimeout -> 0, userOverrides -> {}, usesTraditionalReflectiveProxies -> false ]\r\n2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier \'/mchange-commons.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier \'/mchange-log.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier \'/c3p0.properties\' could not be found. Skipping.\r\n2023-10-07 13:12:24 DEBUG MConfig:207 - The configuration file for resource identifier \'hocon:/reference,/application,/c3p0,/\' could not be found. Skipping.\r\n2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - com.mchange.v2.resourcepool.BasicResourcePool@74a6a609 config: [start -> 3; min -> 3; max -> 15; inc -> 3; num_acq_attempts -> 30; acq_attempt_delay -> 1000; check_idle_resources_delay -> 0; max_resource_age -> 0; max_idle_time -> 0; excess_max_idle_time -> 0; destroy_unreturned_resc_time -> 0; expiration_enforcement_delay -> 0; break_on_acquisition_failure -> false; debug_store_checkout_exceptions -> false; force_synchronous_checkins -> false]\r\n2023-10-07 13:12:24 DEBUG C3P0PooledConnectionPoolManager:204 - Created new pool for auth, username (masked): \'hy******\'.\r\n2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - acquire test -- pool size: 0; target_pool_size: 3; desired target? 1\r\n2023-10-07 13:12:24 DEBUG BasicResourcePool:204 - awaitAvailable(): [unknown]\r\n[User{id=387, name=\'sss\', sex=\'sdf\', age=80}, User{id=391, name=\'sss\', sex=\'sdf\', age=80}, User{id=395, name=\'sss\', sex=\'sdf\', age=80}, User{id=379, name=\'sss\', sex=\'sdf\', age=80}, User{id=383, name=\'sss\', sex=\'sdf\', age=80}, User{id=2, name=\'xx\', sex=\'pp\', age=100}, User{id=1, name=\'xx\', sex=\'pp\', age=100}, User{id=403, name=\'sss\', sex=\'sdf\', age=80}, User{id=407, name=\'sss\', sex=\'sdf\', age=80}, User{id=411, name=\'sss\', sex=\'sdf\', age=80}, User{id=415, name=\'sss\', sex=\'sdf\', age=80}, User{id=436, name=\'sss\', sex=\'sdf\', age=80}, User{id=399, name=\'sss\', sex=\'sdf\', age=80}, User{id=419, name=\'sss\', sex=\'sdf\', age=80}, User{id=423, name=\'sss\', sex=\'sdf\', age=80}, User{id=397, name=\'sss\', sex=\'sdf\', age=80}, User{id=398, name=\'sss\', sex=\'sdf\', age=80}, User{id=443, name=\'sss\', sex=\'sdf\', age=80}, User{id=447, name=\'sss\', sex=\'sdf\', age=80}, User{id=400, name=\'sss\', sex=\'sdf\', age=80}, User{id=427, name=\'sss\', sex=\'sdf\', age=80}, User{id=431, name=\'sss\', sex=\'sdf\', age=80}, User{id=433, name=\'sss\', sex=\'sdf\', age=80}]\r\n\r\nProcess finished with exit code 0\r\n```\r\n<div >\r\n    <h4>4. druid</h4>\r\n<pre class=\"preText\">\r\n定义：Druid是阿里巴巴的开源连接池组件，是世界上最好的连接池之一。Druid能对数据库连接进行有效管理和重用，最大化程序执行的效率。连接池负责创建和管理连接，程序只负责取用与归还。\r\n优势：它是Java语言中功能强大、性能优秀的数据库连接池之一。Druid连接池结合了C3P0、DBCP等数据库连接池的优点。\r\n    druid和前两个连接池的对比：druid功能强大，性能最强，具有极强的扩展性\r\n        参考数据：https://blog.51cto.com/u_15553139/5205148\r\n        总结如下：\r\n        在获取连接的时间方面：druid > c3p0 > dbcp\r\n        在功能拓展方便：druid > dbcp > c3p0 也就是说druid可以扩展很多插件\r\n获取数据源：\r\n    使用com.alibaba.druid.pool.DruidDataSource类来创建新的数据源，具体属性可以在类里面查看到\r\n        类里面使用的变量\r\n            protected volatile String username; ---volatile 的修改和读取都是直接针对主存，且操作不会被重新排序优化，对所有线程都具有可见性\r\n            protected volatile String password;\r\n            protected volatile String jdbcUrl;\r\n            protected volatile String driverClass;\r\n        类变量使用的接口\r\n            void setDriverClassName(String driverClass)\r\n            void setUrl(String jdbcUrl)\r\n            void setUsername(String username)\r\n            void setPassword(String password)\r\n        实验结论：对这些属性的操作要基于它的接口名称\r\n添加包：\r\n    - druid-1.2.18.jar\r\n</pre>\r\n\r\n- DruidDataSource类\r\n</div>\r\n\r\n```\r\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\r\nimport org.apache.ibatis.datasource.DataSourceFactory;\r\n\r\nimport javax.sql.DataSource;\r\nimport java.util.Properties;\r\n\r\n// https://blog.csdn.net/m0_70031574/article/details/131947655\r\npublic class DruidDataSource implements DataSourceFactory { // java: illegal character: \'\\ufeff\' remove BOM in File Editor and recreate file\r\n\r\n    private DataSource dataSource;\r\n    private Properties properties;\r\n\r\n    public DruidDataSource() {\r\n    }\r\n\r\n    @Override\r\n    public void setProperties(Properties properties) {\r\n        this.properties = properties;\r\n        try {\r\n            this.dataSource = DruidDataSourceFactory.createDataSource(properties);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public DataSource getDataSource() {\r\n        return this.dataSource;\r\n    }\r\n}\r\n```\r\n- mybatis-config.xml文件\r\n\r\n```\r\n<dataSource type=\"com.hyh.dataSourceFactoryImpl.DruidDataSource\">\r\n            <property name=\"driver\" value=\"${oracle_driver}\"/>\r\n            <property name=\"url\" value=\"${oracle_url}\"/>\r\n            <property name=\"username\" value=\"${oracle_username}\"/>\r\n            <property name=\"password\" value=\"${oracle_password}\"/>\r\n</dataSource>\r\n```\r\n\r\n<div >\r\n    <h3>ssh/ss(h)m：ssh/ss(h)m/spring对数据库事务的处理</h3>\r\n<h4>1. ssh</h4>\r\n<pre class=\"preText\">\r\nssh的定义：Struts + Spring + Hibernate\r\n    Structs：流程控制\r\n    Spring：业务流转\r\n    Hibernate：数据库操作的封装\r\n        这里介绍一下Hibernate:\r\n            首先，它是对 jdbc 封装得最彻底的框架, 纯面向对象, 可以不用写 SQL。\r\n            其次，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JavaEE架构中取代CMP，完成数据持久化的重任。\r\n                EJB: Enterprise JavaBeans\r\n                    分布式企业级应用程序的Java组件模型，包含Session Bean，Entity(实体) Bean等组件\r\n                CMP: Container-Managed Persistence(被容器管理的持久性[模型])\r\n                    例如，Entity Bean就具有持久性\r\n                JavaEE: Java Platform, [Enterprise Edition]\r\n                    它的规范包含各种持久性和通信API\r\n                        通信API例如TCP/UDP\r\n类别：属于MVC软件开发模式\r\n>> 翻译（基于CHATGPT）https://www.codejava.net/frameworks/struts/struts-2-spring-4-hibernate-4-integration-tutorial-part-1-xml-configuration\r\n</pre>\r\n\r\n#### SSH教学 第一部分（XML配置）\r\n\r\n该教学项目的目的为从数据库里打印一张表里的所有产品到JSP页面，它会帮助我们理解在这种高集成的环境下究竟发生了什么。\r\n\r\n为什么要集成Struts、Spring和Hibernate？\r\n    Struts是一个Web应用程序框架，Spring是一个企业应用程序框架，Hibernate是一个ORM（对象和数据库的数据映射和转换）框架。Hibernate在数据库层工作，而Struts和Spring都可以在Web层工作。Spring比Struts更强大，它可以替代Struts。因此，如果你正在使用Spring和Hibernate开始一个新项目，就不需要再使用Struts了！\r\n    这种集成只对以Struts构建的旧项目才是必要的，现在你必须将它们升级为Spring和Hibernate，同时保留Struts。因此，在实际中很少有Struts-Spring-Hibernate应用程序。\r\n\r\nStruts、Spring和Hibernate的集成是如何工作的？\r\n    在这种集成中，Struts应该充当调度过滤器的角色，拦截所有进入应用程序的请求。Spring应该作为依赖注入容器，还管理Hibernate会话并提供事务管理服务。\r\n    有趣的一点是，Struts的Action类由Spring管理。因此，Struts中映射的操作可以绑定一个Spring bean。这只能通过使用Struts提供的Spring插件来实现。\r\n\r\n首先让我们创建一个maven项目。\r\n\r\noracle表结构：\r\n```\r\n1 create table product(\r\n2  id number(11) primary key,\r\n3  name varchar2(128) not null,\r\n4  description varchar2(512) not null,\r\n5  price number(10,2) not null);\r\n```\r\n\r\n> 注意strut的名字念 /strʌt/ 而不是 /strʌkt/ ，它的构词和structure这些没有绝对关系，所以配置文件叫strut.xml，这个BUG我排查了将近半天，最近怎么老打错而且还半天找不到，看来该回炉重造了。\r\n\r\n下面为项目结构：\r\n\r\n<img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/sshProjectStructure.png\" style=\"width: 35%\">\r\n<img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/sshProjectStructure2.png\" style=\"width: 35% ; position : absolute ; margin-left : 2%\">\r\n<pre class=\"preText\">\r\nNOTE: 项目中的log4j.properties只有在resources内部的生效了。我修改后忘记删除了。\r\n\r\n文件分类：strut相关(pom.xml or maven依赖 在最后)\r\n    - struts.xml  web.xml  ListProductAction.java  ProductList.jsp\r\n</pre>\r\n\r\n```\r\n    + struts.xml\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE struts PUBLIC\r\n        \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"\r\n        \"http://struts.apache.org/dtds/struts-2.0.dtd\">\r\n\r\n<struts>\r\n    <package name=\"demo\" extends=\"struts-default\" namespace=\"/\">\r\n\r\n        <default-action-ref name=\"listProduct\"/> <!--strut设置首页-->\r\n\r\n<!--        <action name=\"*\">-->  <!--该项目没有使用但该设置可以使view下面的jsp通过文件名访问，相当于servlet-dispatcher-->\r\n<!--            <result>/WEB-INF/views/{1}.jsp</result>-->\r\n<!--        </action>-->\r\n\r\n        <action name=\"listProduct\" class=\"com.hyh.structAction.ListProductAction\" method=\"execute\">\r\n            <result name=\"success\">/WEB-INF/views/ProductList.jsp</result>\r\n        </action>\r\n\r\n    </package>\r\n</struts>\r\n\r\n    ______________________________________________\r\n\r\n    + web.xml\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\r\n         version=\"4.0\">\r\n\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>/WEB-INF/spring/appContext.xml</param-value>\r\n    </context-param>\r\n\r\n    <listener> <!--artifact -> WEB-INF -> <CREATE> file called lib -> <right click> -> add a copy of -> library files-->\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n\r\n    <filter> <!--它取代了servlet-->\r\n        <filter-name>DispatcherFilter</filter-name>\r\n        <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>\r\n    </filter>\r\n\r\n    <filter-mapping>\r\n        <filter-name>DispatcherFilter</filter-name>\r\n        <url-pattern>/*</url-pattern>\r\n    </filter-mapping>\r\n</web-app>\r\n\r\n    ----------------------------------------------\r\n\r\n    + ListProductAction.java\r\n\r\n    package com.hyh.structAction;\r\n\r\nimport com.hyh.dao.ProductDAO;\r\nimport com.hyh.pojo.Product;\r\nimport com.opensymphony.xwork2.ActionSupport;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.List;\r\n\r\n@Service(\"listProductActionBean\")\r\npublic class ListProductAction extends ActionSupport {\r\n    @Autowired\r\n    private ProductDAO productDAO;\r\n    private List<Product> listProduct;\r\n\r\n    @Autowired\r\n    public void setProductDAO(ProductDAO productDAO) { // spring通过setter注入\r\n        this.productDAO = productDAO;\r\n    }\r\n\r\n    @Override\r\n    public String execute() {\r\n        listProduct = productDAO.list();\r\n        return SUCCESS;\r\n    }\r\n\r\n    public List<Product> getListProduct() { // JSP通过get获取\r\n        return listProduct;\r\n    }\r\n}\r\n\r\n    -----------------------------------\r\n\r\n    + ProductList.jsp\r\n\r\n    <%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\r\n<%--\r\n  Created by IntelliJ IDEA.\r\n  User: AJH41\r\n  Date: 2023-10-08\r\n  Time: 3:29 PM\r\n  To change this template use File | Settings | File Templates.\r\n--%>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<div align=\"center\">\r\n    <table width=\"80%\" border=\"1\" style=\"border-collapse: collapse;\">\r\n        <tr>\r\n            <th>No</th>\r\n            <th>Product Name</th>\r\n            <th>Description</th>\r\n            <th>Price</th>\r\n        </tr>\r\n        <s:iterator value=\"listProduct\" status=\"stat\"> <!--struct-tags-->\r\n            <tr>\r\n                <td><s:property value=\"#stat.count\" /></td>  <%--#stat.count是指当前行是第几个而不是id值--%>\r\n                <td><s:property value=\"name\" /></td>\r\n                <td><s:property value=\"description\" /></td>\r\n                <td><s:property value=\"price\" /></td>\r\n            </tr>\r\n        </s:iterator>\r\n    </table>\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n<div >\r\n<pre class=\"preText\">\r\nspring\r\n    - appContext.xml dao包下\r\n</pre>\r\n\r\n</div>\r\n\r\n```\r\n    + appContext.xml\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\">\r\n\r\n    <bean id=\"sessionFactory\"\r\n          class=\"org.springframework.orm.hibernate4.LocalSessionFactoryBean\">\r\n        <property name=\"dataSource\" ref=\"dataSource\" />\r\n        <property name=\"configLocation\" value=\"file:F:\\JAVA\\20230925\\sshMaven\\src\\main\\java\\hibernate.cfg.xml\" /> <!---->\r\n    </bean>\r\n\r\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\r\n          destroy-method=\"close\">\r\n        <property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\" />\r\n        <property name=\"url\" value=\"jdbc:oracle:thin:@localhost:1521:orcl\" />\r\n        <property name=\"username\" value=\"hyh\" />\r\n        <property name=\"password\" value=\"123456\" />\r\n    </bean>\r\n\r\n    <tx:annotation-driven /> <!--利用@Transactional注解来处理事务-->\r\n\r\n    <bean id=\"transactionManager\"\r\n          class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\">\r\n        <property name=\"sessionFactory\" ref=\"sessionFactory\" />\r\n    </bean>\r\n\r\n    <context:component-scan base-package=\"com.hyh\"/>\r\n\r\n</beans>\r\n\r\n    ----------------------------------------------\r\n\r\n    + dao包\r\n        + 1\r\n    public interface ProductDAO {\r\n        List<Product> list();\r\n    }\r\n\r\n        + 2\r\n    import com.hyh.dao.ProductDAO;\r\nimport com.hyh.pojo.Product;\r\nimport org.hibernate.Criteria;\r\nimport org.hibernate.SessionFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Repository;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.util.List;\r\n\r\n@Repository(\"productDAO\")\r\npublic class ProductDAOImpl implements ProductDAO {\r\n    @Autowired\r\n    private SessionFactory sessionFactory;\r\n\r\n    @Autowired\r\n    public ProductDAOImpl(SessionFactory sessionFactory) {\r\n        this.sessionFactory = sessionFactory;\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public List<Product> list() {\r\n        @SuppressWarnings(\"unchecked\") //unchecked是对编译器来说不可预知的错误 checked对编译器来说可以预知所以会强制捕获\r\n        List<Product> listProduct = (List<Product>)\r\n                sessionFactory.getCurrentSession().createCriteria(Product.class) // hibernate数据库操作会话通过元数据了解表结构后生成相应SQL\r\n                        .setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY) // DISTINCT_ROOT_ENTITY代表了数据库中的DISTINCT\r\n                        .list(); // 返回类型\r\n        System.out.println(listProduct);\r\n        return listProduct;\r\n    }\r\n\r\n}\r\n```\r\n\r\n<div >\r\n<pre class=\"preText\">\r\nhibernate\r\n    - hibernate.cfg.xml  Product.hbm.xml\r\n</pre>\r\n</div>\r\n\r\n```\r\n    + .cfg.xml\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE hibernate-mapping PUBLIC\r\n        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\r\n        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\r\n<hibernate-mapping package=\"com.hyh.pojo\">\r\n    <class name=\"Product\" table=\"product\"> <!--hibernate是面向对象的-->\r\n        <id name=\"id\" column=\"id\"/>\r\n        <property name=\"name\" />\r\n        <property name=\"description\" />\r\n        <property name=\"price\" />\r\n    </class>\r\n</hibernate-mapping>\r\n\r\n    ====================================\r\n\r\n    + hbm.xml\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE hibernate-mapping PUBLIC\r\n        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\r\n        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\r\n<hibernate-mapping package=\"com.hyh.pojo\">\r\n    <class name=\"Product\" table=\"product\"> <!--hibernate是面向对象的-->\r\n        <id name=\"id\" column=\"id\"/>\r\n        <property name=\"name\" />\r\n        <property name=\"description\" />\r\n        <property name=\"price\" />\r\n    </class>\r\n</hibernate-mapping>\r\n```\r\n<div >其它文件：log4j.properties  pom.xml</div>\r\n\r\n```\r\n    + properties\r\n# stdout | log对象 | 模式 控制台输出布局 样式\r\n# 可以直接复制\r\n\r\n# Global logging configuration\r\nlog4j.rootLogger=INFO, stdout\r\n# MyBatis logging configuration...\r\nlog4j.logger.com.hyh=INFO\r\n# Console output...\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\n#log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n\r\n    =================================\r\n    + .xml\r\n\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>org.example</groupId>\r\n    <artifactId>sshMaven</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n\r\n    <properties>\r\n        <maven.compiler.source>8</maven.compiler.source>\r\n        <maven.compiler.target>8</maven.compiler.target>\r\n        <org.springframework-version>4.1.4.RELEASE</org.springframework-version>\r\n        <org.strutsframework-version>2.3.20</org.strutsframework-version>\r\n        <org.hibernateframework-version>4.3.8.Final</org.hibernateframework-version>\r\n        <org.mysqlconnector-version>5.1.34</org.mysqlconnector-version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <!--SPRING-->\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-context</artifactId>\r\n            <version>${org.springframework-version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-context-support</artifactId>\r\n            <version>${org.springframework-version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-orm</artifactId>\r\n            <version>${org.springframework-version}</version>\r\n            <type>jar</type>\r\n            <scope>compile</scope>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework</groupId>\r\n            <artifactId>spring-web</artifactId>\r\n            <version>${org.springframework-version}</version> <!-- Replace with your Spring version -->\r\n        </dependency>\r\n\r\n        <!--STRUCTS-->\r\n        <dependency>\r\n            <groupId>org.apache.struts</groupId>\r\n            <artifactId>struts2-core</artifactId>\r\n            <version>${org.strutsframework-version}</version>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.apache.struts</groupId>\r\n            <artifactId>struts2-spring-plugin</artifactId>\r\n            <version>${org.strutsframework-version}</version>\r\n        </dependency>\r\n\r\n        <!--ORM-->\r\n        <dependency>\r\n            <groupId>org.hibernate</groupId>\r\n            <artifactId>hibernate-core</artifactId>\r\n            <version>${org.hibernateframework-version}</version>\r\n        </dependency>\r\n\r\n        <!--DRUID-->\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid</artifactId>\r\n            <version>1.2.4</version> <!-- 根据需要指定Druid的版本 -->\r\n        </dependency>\r\n\r\n        <!-- Oracle 19c JDBC驱动 -->\r\n        <dependency>\r\n            <groupId>com.oracle.database.jdbc</groupId>\r\n            <artifactId>ojdbc8</artifactId>\r\n            <version>19.11.0.0</version> <!-- 根据您的Oracle版本选择合适的版本 -->\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.12</version>\r\n            <scope>compile</scope>\r\n        </dependency>\r\n\r\n        <!--log4j-->\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-api</artifactId>\r\n            <version>2.14.1</version> <!-- Use the latest version available -->\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-core</artifactId>\r\n            <version>2.14.1</version> <!-- Use the same version as log4j-api -->\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>log4j</groupId>\r\n            <artifactId>log4j</artifactId>\r\n            <version>1.2.17</version> <!-- Use a suitable version -->\r\n        </dependency>\r\n\r\n    </dependencies>\r\n\r\n</project>\r\n```\r\n<div >\r\n   <h4>2. ss(h)m</h4>\r\n   \r\n> SS(H)M不是一个广泛使用的术语，没有明确的定义。它可能是指Struts2 + Spring + Hibernate + MyBatis的组合，但这种组合通常不常见，因为MyBatis和Hibernate都是用于数据库访问的持久化框架，通常情况下不会同时使用。\r\n\r\n- 关于aop cannot find method的报错：需要删除out里面的spring-dao 因为out里面的包都是我自己放进去的 【但是】还是不行，只能删除artifact重新构建就可了\r\n\r\n- 结合上面的内容可以搭建出添加了使用mybatis获取数据的类并结合的sshm\r\n    + 使用到的文件有(上面都有)\r\n        - DruidDataSource TransactionFactoryImpl\r\n        - 需要注意Maven结构中的一下文件都在resources里面\r\n            - db.properties\r\n            - mybatis-config.xml *里面对Mapper的路径直接改为文件名，因为Mapper现在直接在resources文件夹内\r\n            - TestInterfaceMapper.xml *涉及到的数据类型都改为了Product\r\n\r\n- ProductDao和ProductDaoImpl添加了以下内容\r\n</div>\r\n\r\n```\r\n+ interface\r\nList<Product> mybatisList();\r\n\r\n+ implementation\r\n@Override\r\n@Transactional\r\npublic List<Product> mybatisList() {\r\n    SqlSessionFactory factory = giveFactory();\r\n    SqlSession sqlSession = factory.openSession();\r\n    List<Product> productList = sqlSession.getMapper(ProductDAO.class).mybatisList();\r\n    return productList;\r\n}\r\n\r\npublic SqlSessionFactory giveFactory() { //启用mybatis配置文件\r\n    SqlSessionFactory factory = null;\r\n    try {\r\n        InputStream inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); //使用\r\n        factory = new SqlSessionFactoryBuilder().build(inputStream);\r\n        inputStream.close();\r\n    } catch (IOException exception) {\r\n        exception.printStackTrace();\r\n    }\r\n\r\n    factory.getConfiguration().setDatabaseId(\"oracle\"); //set database type\r\n    System.out.println(factory.getConfiguration().getDatabaseId());\r\n\r\n    return factory;\r\n}\r\n```\r\n<div >\r\n\r\n+ 在structAction包里添加了以下ListProductMybatisAction类并在struts.xml里添加了以下dispatcher:\r\n```\r\n<action name=\"mybatis\" class=\"com.hyh.structAction.ListProductMybatisAction\" method=\"execute\">\r\n    <result name=\"success\">/WEB-INF/views/ProductListMybatis.jsp</result>\r\n</action>\r\n```\r\n\r\n</div>\r\n\r\n+ ListProductMybatisAction\r\n```\r\nimport com.hyh.dao.ProductDAO;\r\nimport com.hyh.pojo.Product;\r\nimport com.opensymphony.xwork2.ActionSupport;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.List;\r\n\r\n@Service(\"listProductMybatisActionBean\")\r\npublic class ListProductMybatisAction extends ActionSupport {\r\n    @Autowired\r\n    private ProductDAO productDAO;\r\n    private List<Product> productList;\r\n\r\n    @Autowired\r\n    public void setProductDAO(ProductDAO productDAO) { // spring通过setter注入\r\n        this.productDAO = productDAO;\r\n    }\r\n\r\n    @Override\r\n    public String execute() {\r\n        productList = productDAO.mybatisList();\r\n        return SUCCESS;\r\n    }\r\n\r\n    public List<Product> getProductList() { // JSP通过get获取\r\n        return productList;\r\n    }\r\n}\r\n</textarea>\r\n<div >views里面添加了ProductListMybatis.jsp页面</div>\r\n<textarea class=\"code\">\r\n    <%@ taglib prefix=\"s\" uri=\"/struts-tags\" %>\r\n<%--\r\n  Created by IntelliJ IDEA.\r\n  User: AJH41\r\n  Date: 2023-10-09\r\n  Time: 10:44 AM\r\n  To change this template use File | Settings | File Templates.\r\n--%>\r\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\r\n<html>\r\n<head>\r\n    <title>Title</title>\r\n</head>\r\n<body>\r\n<div align=\"center\">\r\n    <table width=\"80%\" border=\"1\" style=\"border-collapse: collapse;\">\r\n        <tr>\r\n            <th>No</th>\r\n            <th>Product Name</th>\r\n            <th>Description</th>\r\n            <th>Price</th>\r\n        </tr>\r\n        <s:iterator value=\"productList\" status=\"stat\"> <!--struct-tags-->\r\n            <tr>\r\n                <td><s:property value=\"#stat.count\" /></td>  <%--#stat.count是指当前行是第几个而不是id值--%>\r\n                <td><s:property value=\"name\" /></td>\r\n                <td><s:property value=\"description\" /></td>\r\n                <td><s:property value=\"price\" /></td>\r\n            </tr>\r\n        </s:iterator>\r\n    </table>\r\n</div></body>\r\n</html>\r\n```\r\n<div >\r\n        <h3>事务</h3>\r\n        \r\n- 在MyBatis中，Mapper.xml文件通常用于定义SQL映射和数据库操作。MyBatis不处理事务本身，而是依赖于外部的事务管理器来处理事务。<br>\r\n- 外部的事务管理器一般：为@Transactional注释，原因是sql语言对事务的处理无法单独调用，所以需要外部程序管理事务<br>\r\n@Transactional注解：这表示该方法应该在事务管理下运行，如果发生异常，则事务将被回滚。<br>\r\n\r\n> 假设：每次执行事务，显示学生的名字和年龄，并且年龄+1。\r\n\r\n- 其它的都差不多，重点如下\r\n    </div>\r\n\r\n```\r\n    @Override\r\n    @Transactional\r\n    public List<User> updateAge() {\r\n        SqlSessionFactory factory = giveFactory();\r\n        SqlSession sqlSession = factory.openSession();\r\n        List<User> users = sqlSession.getMapper(ProductDAO.class).getAll();\r\n        for (User u : users) {\r\n            boolean re = sqlSession.getMapper(ProductDAO.class).update(u.getId(), u.getName(), u.getSex(), u.getAge() + 1);\r\n            if (!re) {\r\n                LOGGER.warn(() -> {\r\n                    return \"update fail UserId = \" + u.getId();\r\n                });\r\n            }\r\n        }\r\n        sqlSession.commit();\r\n        users = sqlSession.getMapper(ProductDAO.class).getAll();\r\n        return users;\r\n    }\r\n```\r\n<div >\r\n    <h3>3.1.3 别名</h3>\r\n\r\n> 以下为博主翻译:\r\n> \r\n为了减少代码冗余，咱们添加了别名系统，你可以给你的类取个别名，是不是很厉害><\r\n\r\n当然你也可以让mybatis自己找别名，咱就是说，mybatis还是很智能的。 \r\n啊啊，如果你没有给它取别名也被关系，他会自动给孩子们取个别名，首字母小写开头。\r\n\r\n嗨，还有更多。我们给java的常用类都取了个默认别名，你看你看，但是大小写敏感，敏感也没办法嘛，名字太多了。\r\n\r\n<img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/listalias.png\" width=\"100%\"/>\r\n</div>\r\n\r\n```\r\n    <configuration>\r\n    <properties resource=\"db.properties\"/>\r\n    <settings> <!--settings需要在properties后面 environments前面 否则会报红 猜测是加载顺序有规定-->\r\n        <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n        <!--有效的值包括SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者一个完全合格的类名，该类实现org.apache.ibatis.logging.Log接口，并将一个字符串作为构造函数参数。-->\r\n    </settings>\r\n    <typeAliases>\r\n        <typeAlias alias=\"MANAGER\" type=\"com.hyh.transaction.impl.TransactionFactoryImpl\"/>\r\n        <package name=\"com.hyh.dataSourceFactoryImpl\"/>\r\n    </typeAliases>\r\n    <environments default=\"development\">\r\n        <environment id=\"development\">\r\n            <transactionManager type=\"MANAGER\">\r\n                <property name=\"autoCommit\" value=\"false\"/>\r\n            </transactionManager>\r\n            <dataSource type=\"DRUID\">\r\n                <property name=\"driver\" value=\"${oracle_driver}\"/>\r\n                <property name=\"url\" value=\"${oracle_url}\"/>\r\n                <property name=\"username\" value=\"${oracle_username}\"/>\r\n                <property name=\"password\" value=\"${oracle_password}\"/>\r\n            </dataSource>\r\n        </environment>\r\n    </environments>\r\n    <mappers>\r\n        <mapper resource=\"TestInterfaceMapper.xml\"/> <!--都只能在resources文件夹-->\r\n    </mappers>\r\n</configuration>\r\n\r\n@Alias(\"DRUID\")\r\n// https://blog.csdn.net/m0_70031574/article/details/131947655\r\npublic class DruidDataSource implements DataSourceFactory { // java: illegal character: \'\\ufeff\' remove BOM in File Editor and recreate file\r\n```\r\n<div >\r\n    <h3>3.1.4 类处理器</h3>\r\n    \r\n> 以下为博主翻译:\r\n> \r\n每当你在preparedStatement设置参数或者结果集返回值的时候我们都会派出类处理器来处理数据类型：也就是说，哼哼，把它们变成java可以接受的数据类型。\r\n    \r\n> 注意！3.4.5我们就可以默认支持JSR-310（一种时间与日期的接口）\r\n\r\n<h3>3.1.5 处理枚举</h3>\r\n\r\n> 以下为博主翻译:\r\n\r\n你必须使用我们的org.apache.ibatis.type.EnumOrdinalTypeHandler or EnumTypeHandler来转换枚举类型。\r\n\r\n- 如果你用第一个的话就代表你想保留数字，就在mybatis-config.xml里添加\r\n```\r\n<typeHandlers>\r\n        <typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\"\r\n                     javaType=\"java.math.RoundingMode\"/>\r\n</typeHandlers>\r\n```\r\n- ww第二个就是保留值啦\r\n\r\n#### 其他\r\n> 3.1.6 你可以修改返回数据的底层逻辑\r\n> 3.1.7 你可以在特定方法里使用插件\r\n> 3.1.9 你可以用id来初始化多个数据库\r\n\r\n#### 思维导图\r\n<div>\r\n    <img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/1.png\" width=\"100%\">\r\n    <img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/2.png\" width=\"100%\">\r\n    <img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/3.png\" width=\"100%\">\r\n    <img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/4.png\" width=\"100%\">\r\n    <img src=\"http://mail.hampster.work:9000/online/hampster/java/mybatis-pool/5.png\" width=\"100%\">\r\n    \r\n> working on: <br>\r\n> ssh/sshm <br>\r\n> 属性大全做到dbcp removeAbandond还有c3p0<br>\r\n> 关于1.中statementtype为prepared 还是 static 的设置区别<br>\r\n> @的情况是否可以设置自增序列为id?<br>\r\n> 将log输出到文件<br>\r\n> mapper对存储过程，视图，序列，触发器等的处理\r\n</div>\r\n', '2025-01-11 11:43:40'),(10, 2, 'Web', '## Web\r\n#### cycle 语句\r\n```\r\n{% for item in xx.loop %}\r\n    {% cycle \'1\' \'2\' \'3\' \'4\' as xxxx silent%}\r\n    <li>{{ item }}: {{ xxxx }}</li>\r\n{% endfor %}\r\n```\r\n- silent: 意思是静默准备，否则要多输出一个准备值', '2025-01-11 10:21:44'),(11, 2, 'Pytorch', '## Pytorch\r\n\r\n### 核心\r\n\r\n- 编解码框架  \r\n        - 通过对hidden state的循环输入输出 来获取结果  \r\n        - 但是很难处理长句子  \r\n- 注意力机制  \r\n        - 解决长句的处理，让其只专注于其中几个hidden state  \r\n- 传递式学习  \r\n\r\n### pytorch对一般张量的处理[自然语言模型最终用到的数据形式]\r\n\r\n参考书目：Natural Language Processing with Transformers  \r\n\r\n> 简单来说，就是把数据向自己预期的数据方向靠近\r\n\r\n```\r\ndef train(x, y):\r\n    input_size = 784  # Assuming the input size required by the model is 784\r\n\r\n    # Generate random input data within the required range\r\n    X = torch.randn(x, input_size)  # Creating random data with shape (x, 784)\r\n    y = torch.empty(x, dtype=torch.float).random_(y) # 标签，来自官方文档\r\n\r\n    model = nn.Sequential(\r\n        nn.Linear(input_size, 200),\r\n        nn.ReLU(),\r\n        nn.Linear(200, 10)\r\n    )\r\n    loss_fn = nn.CrossEntropyLoss()\r\n    optimizer = optim.SGD(model.parameters(), lr=0.01)\r\n    \r\n    # Assuming y is a tensor containing the target labels\r\n\r\n    for epoch in range(10):\r\n        for i in range(len(X)):\r\n\r\n            y_pred = model(X[i])\r\n\r\n            loss = loss_fn(y_pred, y) # Ensure y[i] has proper shape for CrossEntropyLoss\r\n            print(\"epoch: {}, i: {}, loss: {}\".format(epoch, i, loss.item())) # print loss\r\n\r\n            # Before the backward pass, use the optimizer object to zero all of the \r\n            # gradients for the variables it will update (which are the learnable weights\r\n            # of the model)\r\n            optimizer.zero_grad()\r\n\r\n            loss.backward() # compute gradient of the loss\r\n            optimizer.step() # let optimizer to update parameter\r\n\r\n```\r\n\r\n### 语料库下载\r\nhttps://zhuanlan.zhihu.com/p/163616279  \r\n社区互动： web_zh_2019，大小3G，提取密码：2rk6\r\n\r\n### 格式处理\r\n```\r\n# 参考书目：自然语言处理\r\nparent_name = \"F:\\\\HUAXINBeforeJob\\\\python_projects\\\\Natural_Language_Processing_with_Transformers\\\\1212\\\\NLPwithPytorch\"\r\ndef printLines(file, n=10):\r\n    with open(file, \'r\', encoding=\"utf-8\") as datafile:\r\n        lines = datafile.readlines()\r\n        for ln in range(len(lines[:n])):\r\n            if lines[ln].strip() == \"\":\r\n                print()\r\n            elif ln + 1 < len(lines[:n]) and lines[ln + 1].strip() != \"\" \\\r\n                and (ln - 1 > 0 and lines[ln - 1].strip() != \"\"):\r\n                pass\r\n            elif lines[ln].strip() != \"\":\r\n                # \", \".join(jieba.cut(line)).strip()\r\n                print(lines[ln].strip(), end=\"\\t\")\r\n\r\nprintLines(os.path.join(parent_name, \"zh_2019_test.txt\"))\r\n```\r\n\r\n### 中文分词模块\r\nhttps://github.com/fxsjy/jieba\r\n```\r\n安装\r\npip install jieba / pip3 install jieba\r\n```\r\n\r\n### 创建词典【数据预处理与过滤】\r\n\r\n```\r\n# token定义\r\nPAD_token = 0 # 表示填槽，例如:今天的天气是__ 中 _ 为填槽\r\nSOS_token = 1 # 句子的开始EOStoken=2#句子的结束\r\nEOS_token = 2 # end of sentence\r\nclass Voc:\r\n    def __init__(self, name):\r\n        self.name = name\r\n        self.trimmed = False\r\n        self.word2index = {} # 词位\r\n        self.index2word = {PAD_token:\"PAD\", SOS_token:\"SOS\", EOS_token:\"EOS\"}\r\n        self.num_words = 3 # 目前有 SOS、EOS、PAD这3个token\r\n        self.word2count = {} # 词频\r\n    def addSentence(self, sentence):\r\n        for word in jieba.cut(sentence):\r\n            self.addWord(word)\r\n    def addWord(self, word):\r\n        if word not in self.word2index: # 将内容转换为数字\r\n            self.word2index[word] = self.num_words\r\n            self.word2count[word] = 1\r\n            self.index2word[self.num_words] = word\r\n            self.num_words += 1 \r\n        else:\r\n            self.word2count[word] += 1\r\n    #删除频次小于mincount的token\r\n    def trim(self, min_count):\r\n        if self.trimmed:\r\n            return\r\n        self.trimmed = True\r\n        keep_words = []\r\n        for k, v in self.word2count.items():\r\n            if v >= min_count:\r\n                keep_words.append(k)\r\n        print(\'keep_words {} / {} = {:.4f}\'.format( # :代表格式化字符的开始\r\n                len(keep_words), len(self.word2index), len(keep_words) / len(self.word2index)\r\n        ))\r\n        #重新构造词典\r\n        self.word2index = {}\r\n        self.word2count = {}\r\n        self.index2word = {PAD_token: \"PAD\", SOS_token: \"SOS\", EOS_token:\"EOS\"}\r\n        selfnum_words = 3 # Count default tokens#重新构造后词频就没有意义了(都是1)\r\n        for word in keep_words:\r\n            self.addWord(word)\r\ndef normalizeString(s):\r\n    #因为把不用的字符都变成空格，所以可能存在多个连续空格\r\n    #下面的正则替换把多个空格变成一个空格，最后去掉前后空格\r\n    s = re.sub(r\"s*\", r\"\", s).strip()\r\n    return s\r\n#读取问答句对并且返回Voc词典对象\r\ndef readVocs(datafile, corpus_name):\r\n    print(\"\\nReading lines...\")\r\n    #文件每行读取到list lines中\r\n    lines = open(datafile, encoding=\'utf-8\').read().strip().split(\'\\n\')\r\n    #每行用tab切分成问答两个句子，然后调用normalizeString函数进行处理\r\n    pairs = [[normalizeString(s) for s in l.split(\'\\t\') if normalizeString(s) != \"\"] for l in lines]\r\n    voc = Voc(corpus_name)\r\n    return voc, pairs\r\nvoc, pairs = readVocs(os.path.join(parent_name, \"myfile.txt\"), \"first try\")\r\ndef loadPrepareData(corpus, corpus_name, datafile): # corpus 语料\r\n    print(\"Start preparing training data ...\")\r\n    voc.pairs = readVocs(datafile, corpus_name)\r\n    print(\"Read {!s} sentence pairs\".format(len(pairs)))\r\n    print(\"Trimmed to {!s} sentence pairs\".format(len(pairs)))\r\n    print(\"Counting words...\")\r\n    for pair in pairs:\r\n        voc.addSentence(pair[0])\r\n        voc.addSentence(pair[1] if len(pair) > 1 else \"\")\r\n        # print(\"Counted words:\", voc.num_words)\r\n    return voc,pairs\r\n#装载voc和句子对\r\nsave_dir = os.path.join(\"data\",\"save\")\r\nvoc, pairs = loadPrepareData(\"???\", \"corpus_name\", os.path.join(parent_name, \"myfile.txt\"))\r\n# 输出一些词位 和 词频\r\nprint(\"word index:\")\r\ncount = 0\r\nfor key, value in voc.word2index.items():\r\n    if count < 10:\r\n        print(key, \':\', value)\r\n        count += 1\r\n    else:\r\n        break\r\nprint(\"word frequency:\")\r\ncount = 0\r\nfor key, value in voc.word2count.items():\r\n    if count < 10:\r\n        print(key, \':\', value)\r\n        count += 1\r\n    else:\r\n        break\r\n\r\n#输出一些句对\r\nprint(\"\\npairs:\")\r\nfor pair in pairs[:10]:\r\n    print(pair)\r\n\r\nMIN_COUNT=3#值为3\r\ndef trimRareWords(voc, pairs, MIN_OUNT):\r\n    #去 voc中频次小于3的词\r\n    voc.trim(MIN_COUNT)\r\n    #保留的句对\r\n    keep_pairs =[]\r\n    for pair in pairs:\r\n        input_sentence = pair[0]\r\n        output_sentence = pair[1] if len(pair) > 1 else \"\"\r\n        keep_input = True\r\n        keep_output = True\r\n        #检查问题\r\n        for word in jieba.cut(input_sentence):\r\n            if word not in voc.word2index:\r\n                keep_input = False\r\n                break\r\n        #检查答案\r\n        for word in jieba.cut(output_sentence):\r\n            if word not in voc.word2index:\r\n                keep_output = False\r\n                break\r\n        #如果问题和答案都只包含高频词，我们才保留这个句对\r\n        if keep_input and keep_output:\r\n            keep_pairs.append(pair)\r\n    print(\"Trimmed from {} pairs to {}, {:.4f} of total\".format(len(pairs), len(keep_pairs), len(keep_pairs) / len(pairs)))\r\n    return keep_pairs\r\n#实际进行处理\r\npairs = trimRareWords(voc, pairs, MIN_COUNT)\r\nprint(voc.word2count)\r\nprint(\"\\npairs:\")\r\nfor pair in pairs:\r\n    print(pair)\r\n```\r\n\r\n### 语句张量\r\n\r\n> 将语句转换为索引和时间步所构成的张量，让其可以分批次或者跨批次处理\r\n> > 索引：将单词转化为词汇表中的索引  \r\n> > 时间步：将句子中的单词按照顺序排列，每个单词都有一个时间步，时间步从1开始，最后一个时间步为句子的长度  \r\n> > \r\n> > 张量：为了加快训练速度，重复利用cpu的并行能力，我们把批处理的量定义为一个形状张量（max_length x batch_size）\r\n> > > 形状张量中的每个句子长度都不一样，如果小于max_length，则需要在EOS_token后面填充0[PAD_token]，使得每个批次的句子长度一样\r\n> > > 而非零的部分，就是单词的索引\r\n> > 我们可以通过转置该张量的方式来将每一行代表每个句子的所有索引，变为每一行代表同一时间处理的所有索引【每批数据都是同时开始处理的】，可以更好地跨批次处理  \r\n>   \r\n> 同时我们需要一个二进制掩码张量来方便计算，PAD_token的位置为0，其他位置为1，这样在计算loss时，就可以忽略PAD_token的影响  \r\n> 定义输出的目标张量，准备计算loss\r\n\r\n参考github:对英语的自然语言处理\r\nhttps://github.com/chongzicbo/nlp-ml-dl-notes/blob/4d88ad096ced23393aa94c4bec32a1afb8f58cd0/code/pytorch_tutorials/pytorch_chatbot.ipynb#L708\r\n\r\n```\r\n\r\ndef indexesFromSentence(voc, sentence):\r\n    return [voc.word2index[word] for word in jieba.cut(sentence)] + [EOS_token]\r\n\r\n\r\n# 合并数据，相当于行列转置 | 将多个列表以纵向的方式进行封装，返回列表长度以原列表最长长度为准\r\ndef zeroPadding(l, fillvalue=PAD_token):\r\n    return list(itertools.zip_longest(*l, fillvalue=fillvalue))  # 通过返回包含所有第i个元素的元组的迭代器来转置数据\r\n\r\n\r\n# 记录PADtoken的位置为0，其他的为1\r\ndef binaryMatrix(l, value=PAD_token):\r\n    m = []\r\n    for i, seq in enumerate(l):\r\n        m.append([])\r\n        for token in seq:\r\n            if token == PAD_token:\r\n                m[i].append(0)\r\n            else:\r\n                m[i].append(1)\r\n    return m\r\n\r\n\r\n# 返回填充前(加入结束indexEOS token做标记)的长度和填充后的输入序列张量\r\ndef inputVar(l, voc):\r\n    indexes_batch = [indexesFromSentence(voc, sentence) for sentence in l]\r\n    lengths = torch.tensor([len(indexes) for indexes in indexes_batch])\r\n    padList = zeroPadding(indexes_batch)\r\n    padVar = torch.LongTensor(padList)\r\n    return padVar, lengths  # 句子长度列表\r\n\r\n\r\n# 返回填充目标序列张量、填充掩码和最大目标长障def outputVar(l, voc):\r\n\r\n# 返回填充前(加入结束index EOS_token做标记)最长的一个长度和填充后的输入序列张量和填充后的标记mask\r\ndef outputVar(l, voc):\r\n    indexes_batch = [indexesFromSentence(voc, sentence) for sentence in l]\r\n    max_target_len = max([len(indexes) for indexes in indexes_batch])\r\n    padList = zeroPadding(indexes_batch)\r\n    mask = binaryMatrix(padList)  # 返回二进制的mask tensor 大小与目标张量相同,因为是掩码张量，此时PAD_token的位置为1，其他的为0\r\n    mask = torch.ByteTensor(mask)\r\n    padVar = torch.LongTensor(padList)\r\n    return padVar, mask, max_target_len\r\n\r\n\r\ndef batch2TrainData(voc, pair_batch):\r\n    pair_batch.sort(key=lambda x: len(x[0].split(\" \")), reverse=True)\r\n    input_batch, output_batch = [], []\r\n    for pair in pair_batch:\r\n        input_batch.append(pair[0]) # 问句\r\n        output_batch.append(pair[1]) # 答句\r\n    inp, lengths = inputVar(input_batch, voc)\r\n    output, mask, max_target_len = outputVar(output_batch, voc)\r\n    return inp, lengths, output, mask, max_target_len\r\n\r\n\r\n# 返回给定 batch对的所有项目\r\ndef batch2TrainData(voc, pair_batch):\r\n    pair_batch.sort(key=lambda x: len(jieba.lcut(x[0])), reverse=True) # 以词语数量排序\r\n    input_batch, output_batch = [], []\r\n    for pair in pair_batch:\r\n        input_batch.append(pair[0])\r\n        output_batch.append(pair[1])\r\n    inp, lengths = inputVar(input_batch, voc)\r\n    output, mask, max_target_len = outputVar(output_batch, voc)\r\n    return inp, lengths, output, mask, max_target_len\r\n\r\n\r\n# 验证例子\r\nsmall_batch_size = 5\r\nbatches = batch2TrainData(voc, [random.choice(pairs) for _ in range(small_batch_size)])\r\ninput_variable, lengths, target_variable, mask, max_target_len = batches\r\nprint(\"input_variable:\", input_variable)\r\nprint(\"lengths:\", lengths)\r\nprint(\"target_variable:\", target_variable)\r\nprint(\"mask:\", mask)\r\n\r\n```\r\n\r\n### 定义模型\r\n    </mark>\r\n    <img src=\"Encoder_decoder_with_pair_of_RNNS.jpg\">\r\n    <mark class=\"markdown\">\r\n> 这里使用了序列到序列的模型\r\n> > 1. 编码器：将输入序列转换为上下文向量\r\n> > 2. 解码器：将上下文向量转换为输出序列, 返回下一个单词的概率，下一次迭代使用的state\r\n\r\n> 使用了多层门循环单元GRU(RUN变体)\r\n> > 具有两个输入顺序相反的独立RUN，提供过去和未来上下文的优势\r\n\r\n> embedding\r\n> > 作用：将每个单词映射到特征空间\r\n> > 目的：特征空间中的值会被训练为和它们有相似意义的词语\r\n\r\n> Attn\r\n> > 以上一个解码器返回的state为基础，计算出注意力权重，生成权重张量\r\n</mark>\r\n<img src=\"Encoder_decoder_with_attention.jpg\">\r\n<mark class=\"markdown\">\r\n ```\r\n class EncoderRNN(nn.Module):\r\n    def __init__(self, hidden_size, embedding, n_layers=1, dropout=0):\r\n        super(EncoderRNN, self).__init__()\r\n        self.n_layers = n_layers\r\n        self.hidden_size = hidden_size\r\n        self.embedding = embedding\r\n\r\n        # Initialize GRU; the input_size and hidden_size params are both set to \'hidden_size\'\r\n        #   because our input size is a word embedding with number of features == hidden_size\r\n        self.gru = nn.GRU(hidden_size, hidden_size, n_layers, dropout=(0 if n_layers == 1 else dropout),\r\n                          bidirectional=True)\r\n\r\n    def forward(self, input_seq, input_lengths, hidden=None):\r\n        # 将输入的词索引转为word embedding\r\n        embedded = self.embedding(input_seq)\r\n        # pack padded batch of sequences for RNN module\r\n        packed = torch.nn.utils.rnn.pack_padded_sequence(embedded, input_lengths)\r\n        # 将pack后的输入送进gru\r\n        outputs, hidden = self.gru(packed, hidden)\r\n        # unpack padding\r\n        outputs, _ = torch.nn.utils.rnn.pad_packed_sequence(outputs)\r\n        # 两个方向相加\r\n        outputs = outputs[:, :, :self.hidden_size] + outputs[:, :, self.hidden_size:]\r\n        return outputs, hidden\r\n\r\n\r\nclass Attn(torch.nn.Module):\r\n    def __init__(self, method, hidden_size):\r\n        super(Attn, self).__init__()\r\n        self.method = method\r\n        if self.method not in [\"dot\", \"general\", \"concat\"]:\r\n            raise ValueError(self.method, \"is not an appropriate attention method\")\r\n\r\n        self.hidden_size = hidden_size\r\n        if self.method == \"general\":\r\n            self.attn = torch.nn.Linear(self.hidden_size, hidden_size)\r\n        elif self.method == \"concat\":\r\n            self.attn = torch.nn.Linear(self.hidden_size * 2, hidden_size)\r\n            self.v = torch.nn.Parameter(torch.FloatTensor(hidden_size))  # 可训练参数\r\n\r\n    def dot_score(self, hidden, encoder_output):\r\n        return torch.sum(hidden * encoder_output, dim=2)\r\n\r\n    def general_score(self, hidden, encoder_output):\r\n        energy = self.attn(encoder_output)\r\n        return torch.sum(hidden * energy, dim=2)\r\n\r\n    def concat_score(self, hidden, encoder_output):\r\n        energy = self.attn(torch.cat((hidden.expand(encoder_output.size(0), -1, -1), encoder_output), 2)).tanh()\r\n        return torch.sum(self.v * energy, dim=2)\r\n\r\n    def forward(self, hidden, encoder_outputs):\r\n        # 计算权重\r\n        if self.method == \"general\":\r\n            attn_energies = self.general_score(hidden, encoder_outputs)\r\n        elif self.method == \"concat\":\r\n            attn_energies = self.concat_score(hidden, encoder_outputs)\r\n        elif self.method == \"dot\":\r\n            attn_energies = self.dot_score(hidden, encoder_outputs)\r\n\r\n        # 转置 max_length和batch_size维\r\n        attn_energies = attn_energies.t()\r\n\r\n        # 返回归一化的概率得分\r\n        return F.softmax(attn_energies, dim=1).unsqueeze(1)\r\n\r\n\r\nclass LuongAttnDecoderRNN(nn.Module):\r\n    def __init__(self, attn_model, embedding, hidden_size, output_size, n_layers=1, dropout=0.1):\r\n        super(LuongAttnDecoderRNN, self).__init__()\r\n\r\n        self.attn_model = attn_model\r\n        self.hidden_size = hidden_size\r\n        self.output_size = output_size\r\n        self.n_layers = n_layers\r\n        self.dropout = dropout\r\n\r\n        self.embedding = embedding\r\n        self.embedding_dropout = nn.Dropout(dropout)\r\n        self.gru = nn.GRU(hidden_size, hidden_size, n_layers, dropout=(0 if n_layers == 1 else dropout))\r\n        self.concat = nn.Linear(hidden_size * 2, hidden_size)\r\n        self.out = nn.Linear(hidden_size, output_size)\r\n        self.attn = Attn(attn_model, hidden_size)\r\n\r\n    def forward(self, input_step, last_hidden, encoder_outputs):\r\n        embedded = self.embedding(input_step)  # 输入一个单词，获取Embedding向量\r\n        embedded = self.embedding_dropout(embedded)  # 对Embedding向量进行Dropout\r\n        rnn_output, hidden = self.gru(embedded, last_hidden)  # 将Dropout后的embedding向量输入GRU模块\r\n        # 计算注意力权重\r\n        attn_weights = self.attn(rnn_output, encoder_outputs)  # 使用解码器中当前时间步GRU的output与encoder_outputs计算注意力\r\n        context = attn_weights.bmm(\r\n            encoder_outputs.transpose(0, 1))  # bmm:batch的矩阵乘法 ，注意力矩阵和encoder_outputs进行计算获取context\r\n        rnn_output = rnn_output.squeeze(0)\r\n        context = context.squeeze(1)\r\n        concat_input = torch.cat((rnn_output, context), 1)\r\n        concat_output = torch.tanh(self.concat(concat_input))\r\n        # 预测下一个词\r\n        output = self.out(concat_output)\r\n        output = F.softmax(output, dim=1)\r\n        return output, hidden\r\n ```\r\n\r\n ### 计算损失\r\n > 该损失函数计算与掩码张量中1对应的位置的平均负对数似然\r\n\r\n > 平均负对数似然\r\n \r\n > 似然\r\n > > 数学上的最大似然估计是指，通过已知的随机样本（的概率）计算原模型（发生）的概率\r\n\r\n > 负对数\r\n > > 将容易不稳定或溢出的小概率转换为相对应的容易计算的大概率\r\n\r\n ```\r\ndef maskNLLLoss(inp,target,mask):\r\nnTotal=mask.sum()\r\ncrossEntropy=-torch.log(torch.gather(inp,1,target.view(-1,1)).squeeze(1))\r\nloss=crossEntropy.masked_select(mask.bool()).mean()\r\nloss=loss.to(device)\r\nreturn loss,nTotal.item()\r\n```\r\n\r\n### 训练迭代\r\n\r\n> 零化梯度\r\n> > 梯度是损失函数对于模型参数的变化率，归零是为了避免上次参数影响这次计算出的梯度\r\n\r\n```\r\nMAX_LENGTH = 10\r\nteacher_forcing_ratio = 0.3\r\n\r\ndef train(input_variable, lengths, target_variable, mask, max_target_len, encoder, decoder, embedding, encoder_optimizer, decoder_optimizer, batch_size, clip, max_length=MAX_LENGTH):\r\n    # 梯度归零\r\n    encoder_optimizer.zero_grad()\r\n    decoder_optimizer.zero_grad()\r\n\r\n    # 设置设备选项\r\n    input_variable = input_variable.to(device)\r\n    lengths = lengths.to(device)\r\n    target_variable = target_variable.to(device)\r\n    mask = mask.to(device)\r\n\r\n    # 初始化变量\r\n    loss = 0\r\n    print_losses = []\r\n    n_totals = 0\r\n\r\n    encoder_outputs, encoder_hidden = encoder(input_variable, lengths)\r\n\r\n    decoder_input = torch.LongTensor([[SOS_token for _ in range(batch_size)]])\r\n    decoder_input = decoder_input.to(device)\r\n\r\n    # encoder最后的隐藏状态作为decoder的初始隐藏状态\r\n    decoder_hidden = encoder_hidden[:decoder.n_layers]\r\n\r\n    # 是否使用teacher forcing\r\n    use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False\r\n\r\n    if use_teacher_forcing:\r\n        for t in range(max_target_len):\r\n            decoder_output, decoder_hidden = decoder(decoder_input, decoder_hidden, encoder_outputs)\r\n            # Teacher forcing: next input is current target\r\n            decoder_input = target_variable[t].view(1, -1)\r\n\r\n            # 计算损失\r\n            mask_loss, nTotal = maskNLLLoss(decoder_output, target_variable[t], mask[t])\r\n            loss += mask_loss\r\n            print_losses.append(mask_loss.item() * nTotal)\r\n            n_totals += nTotal\r\n\r\n    else:\r\n        for t in range(max_target_len):\r\n            decoder_output, decoder_hidden = decoder(decoder_input, decoder_hidden, encoder_outputs)\r\n            _, topi = decoder_output.topk(1)\r\n            decoder_input = torch.LongTensor([[topi[i][0] for i in range(batch_size)]])\r\n            decoder_input = decoder_input.to(device)\r\n\r\n            # 计算损失\r\n            mask_loss, nTotal = maskNLLLoss(decoder_output, target_variable[t], mask[t])\r\n            loss += mask_loss\r\n            print_losses.append(mask_loss.item() * nTotal)\r\n            n_totals += n_totals\r\n\r\n    # 反向传播\r\n    loss.backward()\r\n    # 梯度裁剪\r\n    _ = torch.nn.utils.clip_grad_norm_(encoder.parameters(), clip)\r\n    _ = torch.nn.utils.clip_grad_norm_(decoder.parameters(), clip)\r\n\r\n    # 权重更新\r\n    encoder_optimizer.step()\r\n    decoder_optimizer.step()\r\n\r\n    return sum(print_losses) / n_totals\r\n\r\n# 迭代运行\r\ndef trainIters(model_name, voc, pairs, encoder, decoder, encoder_optimizer, decoder_optimizer, embedding,\r\n               encoder_n_layers, decoder_n_layers, save_dir, n_iteration, batch_size, print_every, save_every, clip,\r\n               corpus_name, loadFilename):\r\n    training_batches = [batch2TrainData(voc, [random.choice(pairs) for _ in range(batch_size)]) for _ in\r\n                        range(n_iteration)]\r\n    print(\"初始化...\")\r\n    start_iteration = 1\r\n    print_loss = 0\r\n    if loadFilename:\r\n        start_iteration = checkpoint[\'iteration\'] + 1\r\n    print(\"Training...\")\r\n    for iteration in range(start_iteration, n_iteration + 1):\r\n        training_batch = training_batches[iteration - 1]\r\n        # 提取训练所需数据\r\n        input_variable, lengths, target_variable, mask, max_target_len = training_batch\r\n        loss = train(input_variable, lengths, target_variable, mask, max_target_len, encoder, decoder, embedding,\r\n                     encoder_optimizer, decoder_optimizer, batch_size, clip)\r\n        print_loss += loss\r\n\r\n        if iteration % print_every == 0:\r\n            print_loss_avg = print_loss / print_every\r\n            print(\"Iteration: {}; Percent complete: {:.1f}%; Average loss: {:.4f}\".format(iteration,\r\n                                                                                          iteration / n_iteration * 100,\r\n                                                                                          print_loss_avg))\r\n            print_loss = 0\r\n\r\n        # save checkpoint\r\n        if (iteration % save_every == 0):\r\n            directory = os.path.join(save_dir, model_name, corpus_name,\r\n                                     \"{}-{}-{}\".format(encoder_n_layers, decoder_n_layers, hidden_size))\r\n            if not os.path.exists(directory):\r\n                os.makedirs(directory)\r\n            torch.save({\"iteration\": iteration, \"en\": encoder.state_dict(), \"de\": decoder.state_dict(),\r\n                        \"en_opt\": encoder_optimizer.state_dict(),\r\n                        \"de_opt\": decoder_optimizer.state_dict(), \"loss\": loss, \"voc_dict\": voc.__dict__,\r\n                        \"embedding\": embedding.state_dict()\r\n                        }, os.path.join(directory, \"{}_{}.tar\".format(iteration, \"checkpoint\")))\r\n\r\n\r\n```\r\n\r\n### 评估\r\n\r\n> 评估单词和句子，让它们在没有输出返回数据的情况下，直接根据概率分布情况选择下一个单词\r\n\r\n> 标准化\r\n> > 将输入转化为符合处理标准的字符串\r\n\r\n```\r\nclass GreedySearchDecoder(nn.Module):\r\n    def __init__(self, encoder, decoder):\r\n        super(GreedySearchDecoder, self).__init__()\r\n        self.encoder = encoder\r\n        self.decoder = decoder\r\n\r\n    def forward(self, input_seq, input_length, max_length):\r\n        # Forward input through encoder model\r\n        encoder_outputs, encoder_hidden = self.encoder(input_seq, input_length)\r\n        # Prepare encoder\'s final hidden layer to be first hidden input to the decoder\r\n        decoder_hidden = encoder_hidden[:decoder.n_layers]\r\n        # Initialize decoder input with SOS_token\r\n        decoder_input = torch.ones(1, 1, device=device, dtype=torch.long) * SOS_token\r\n        # Initialize tensors to append decoded words to\r\n        all_tokens = torch.zeros([0], device=device, dtype=torch.long)\r\n        all_scores = torch.zeros([0], device=device)\r\n        # Iteratively decode one word token at a time\r\n        for _ in range(max_length):\r\n            # Forward pass through decoder\r\n            decoder_output, decoder_hidden = self.decoder(decoder_input, decoder_hidden, encoder_outputs)\r\n            # Obtain most likely word token and its softmax score\r\n            decoder_scores, decoder_input = torch.max(decoder_output, dim=1)\r\n            # Record token and score\r\n            all_tokens = torch.cat((all_tokens, decoder_input), dim=0)\r\n            all_scores = torch.cat((all_scores, decoder_scores), dim=0)\r\n            # Prepare current token to be next decoder input (add a dimension)\r\n            decoder_input = torch.unsqueeze(decoder_input, 0)\r\n        # Return collections of word tokens and scores\r\n        return all_tokens, all_scores\r\n    \r\ndef evaluate(encoder, decoder, searcher, voc, sentence, max_length=MAX_LENGTH):\r\n    ### Format input sentence as a batch\r\n    # words -> indexes\r\n    indexes_batch = [indexesFromSentence(voc, sentence)]\r\n    # Create lengths tensor\r\n    lengths = torch.tensor([len(indexes) for indexes in indexes_batch])\r\n    # Transpose dimensions of batch to match models\' expectations\r\n    input_batch = torch.LongTensor(indexes_batch).transpose(0, 1)\r\n    # Use appropriate device\r\n    input_batch = input_batch.to(device)\r\n    lengths = lengths.to(device)\r\n    # Decode sentence with searcher\r\n    tokens, scores = searcher(input_batch, lengths, max_length)\r\n    # indexes -> words\r\n    decoded_words = [voc.index2word[token.item()] for token in tokens]\r\n    return decoded_words\r\n\r\ndef evaluateInput(encoder, decoder, searcher, voc):\r\n    input_sentence = \'\'\r\n    while(1):\r\n        try:\r\n            # Get input sentence\r\n            input_sentence = input(\'> \')\r\n            # Check if it is quit case\r\n            if input_sentence == \'q\' or input_sentence == \'quit\': break\r\n            # Normalize sentence\r\n            input_sentence = normalizeString(input_sentence) # 变成符合标准的输入\r\n            # Evaluate sentence\r\n            output_words = evaluate(encoder, decoder, searcher, voc, input_sentence)\r\n            # Format and print response sentence\r\n            output_words[:] = [x for x in output_words if not (x == \'EOS\' or x == \'PAD\')]\r\n            print(\'Bot:\', \' \'.join(output_words))\r\n\r\n        except KeyError:\r\n            print(\"Error: Encountered unknown word.\")\r\n```\r\n\r\n### 运行及训练模型\r\n\r\n```\r\n# Configure models\r\nmodel_name = \'cb_model\'\r\nattn_model = \'dot\'\r\n#attn_model = \'general\'\r\n#attn_model = \'concat\'\r\nhidden_size = 500\r\nencoder_n_layers = 2\r\ndecoder_n_layers = 2\r\ndropout = 0.1\r\nbatch_size = 64\r\n\r\n# Set checkpoint to load from; set to None if starting from scratch\r\nloadFilename = None\r\ncheckpoint_iter = 200 # 4000\r\n#loadFilename = os.path.join(save_dir, model_name, \"corpus_name\",\r\n#                            \'{}-{}-{}\'.format(encoder_n_layers, decoder_n_layers, hidden_size),\r\n#                            \'{}_checkpoint.tar\'.format(checkpoint_iter))\r\n\r\n# Load model if a loadFilename is provided\r\nif loadFilename:\r\n    # If loading on same machine the model was trained on\r\n    checkpoint = torch.load(loadFilename)\r\n    # If loading a model trained on GPU to CPU\r\n    #checkpoint = torch.load(loadFilename, map_location=torch.device(\'cpu\'))\r\n    encoder_sd = checkpoint[\'en\']\r\n    decoder_sd = checkpoint[\'de\']\r\n    encoder_optimizer_sd = checkpoint[\'en_opt\']\r\n    decoder_optimizer_sd = checkpoint[\'de_opt\']\r\n    embedding_sd = checkpoint[\'embedding\']\r\n    voc.__dict__ = checkpoint[\'voc_dict\']\r\n\r\nprint(\'Building encoder and decoder ...\')\r\n# Initialize word embeddings\r\nembedding = nn.Embedding(voc.num_words, hidden_size)\r\nif loadFilename:\r\n    embedding.load_state_dict(embedding_sd)\r\n# Initialize encoder & decoder models\r\nencoder = EncoderRNN(hidden_size, embedding, encoder_n_layers, dropout)\r\ndecoder = LuongAttnDecoderRNN(attn_model, embedding, hidden_size, voc.num_words, decoder_n_layers, dropout)\r\nif loadFilename:\r\n    encoder.load_state_dict(encoder_sd)\r\n    decoder.load_state_dict(decoder_sd)\r\n# Use appropriate device\r\nencoder = encoder.to(device)\r\ndecoder = decoder.to(device)\r\nprint(\'Models built and ready to go!\')\r\n\r\n\r\n# Configure training/optimization\r\nclip = 50.0\r\nteacher_forcing_ratio = 1.0\r\nlearning_rate = 0.0001\r\ndecoder_learning_ratio = 5.0\r\nn_iteration = 200 # 4000 # 0\r\nprint_every = 1\r\nsave_every = 100 # 500\r\n\r\n# Ensure dropout layers are in train mode\r\nencoder.train()\r\ndecoder.train()\r\n\r\n# Initialize optimizers\r\nprint(\'Building optimizers ...\')\r\nencoder_optimizer = optim.Adam(encoder.parameters(), lr=learning_rate)\r\ndecoder_optimizer = optim.Adam(decoder.parameters(), lr=learning_rate * decoder_learning_ratio)\r\nif loadFilename:\r\n    encoder_optimizer.load_state_dict(encoder_optimizer_sd)\r\n    decoder_optimizer.load_state_dict(decoder_optimizer_sd)\r\n\r\n# Run training iterations\r\nprint(\"Starting Training!\")\r\ntrainIters(model_name, voc, pairs, encoder, decoder, encoder_optimizer, decoder_optimizer,\r\n           embedding, encoder_n_layers, decoder_n_layers, save_dir, n_iteration, batch_size,\r\n           print_every, save_every, clip, \"corpus_name\", loadFilename)\r\n```\r\n\r\n### 启动\r\n> 可以将之前的迭代次数设置为0以快速启动\r\n```\r\n# Set dropout layers to eval mode\r\nencoder.eval()\r\ndecoder.eval()\r\n\r\n# Initialize search module\r\nsearcher = GreedySearchDecoder(encoder, decoder)\r\n\r\n# Begin chatting (uncomment and run the following line to begin)\r\nevaluateInput(encoder, decoder, searcher, voc)\r\n```\r\n', '2025-01-11 10:25:42'),(12, 2, 'BS4', '## BS4\r\n### 爬取特定文本和属性\r\n```\r\nfrom bs4 import BeautifulSoup\r\n\r\nhtml_doc = \"\"\"\r\n<html>\r\n  <body>\r\n    <div class=\"content\">Content 1</div>\r\n    <div id=\"main\" class=\"content\">Content 2</div>\r\n    <div class=\"content\" data-type=\"important\">Important Content</div>\r\n  </body>\r\n</html>\r\n\"\"\"\r\n\r\n# 假设html_doc是网页源代码，使用Beautiful Soup解析\r\nsoup = BeautifulSoup(html_doc, \'html.parser\')\r\n\r\n# 查找所有带有特定属性data-type的<div>标签\r\ndivs_with_attr = soup.find_all(\'div\', {\'data-type\': \'important\'})\r\n\r\n# 打印结果\r\nfor div in divs_with_attr:\r\n    print(div.text)\r\n\r\n\r\nhtml_doc = \"\"\"\r\n<html>\r\n  <body>\r\n    <p>This is a paragraph with some text.</p>\r\n    <p>Another paragraph with different text.</p>\r\n    <p>One more paragraph here.</p>\r\n  </body>\r\n</html>\r\n\"\"\"\r\n\r\n# 假设html_doc是网页源代码，使用Beautiful Soup解析\r\nsoup = BeautifulSoup(html_doc, \'html.parser\')\r\n\r\n# 查找包含特定文字内容的<p>标签\r\ntarget_text = \'different text\'\r\nparagraphs_with_text = soup.find_all(\'p\', string=lambda string: string and target_text in string)\r\n\r\n# 打印结果\r\nfor p in paragraphs_with_text:\r\n    print(p.text)\r\n```\r\n', '2025-01-11 10:30:18'),(13, 2, 'LeetCode106', '## LeetCode106\r\n```python\r\n# Definition for a binary tree node.\r\nfrom typing import List, Optional\r\n\r\n\r\nclass TreeNode(object):\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\ndef inorder(root):\r\n    if root is None:\r\n        return\r\n    inorder(root.left)\r\n    print(root.val)\r\n    inorder(root.right)\r\n\r\ndef postorder(root):\r\n    if root is None:\r\n        return\r\n    postorder(root.left)\r\n    postorder(root.right)\r\n    print(root.val)\r\n\r\ndef preorder(root):\r\n    if root is None:\r\n        return\r\n    print(root.val)\r\n    preorder(root.left)\r\n    preorder(root.right)\r\n\r\ntr27 = TreeNode(27); tr55 = TreeNode(55)\r\n\r\n# first\r\ntree = TreeNode(67)\r\n# second & third\r\ntree.left = TreeNode(30, TreeNode(34), tr27)\r\ntree.right = TreeNode(70, TreeNode(66), tr55)\r\n# forth\r\ntr27.left = TreeNode(12)\r\ntr55.left = TreeNode(41)\r\n\r\ninorder(tree)\r\nprint(\"——————————————————————————————————————————\")\r\npreorder(tree)\r\n\r\ninorder = [9, 3, 15, 20, 7]\r\npostorder = [9, 15, 7, 20, 3]\r\n\r\n```\r\n> 对于不同顺序的遍历推导主要为：查看源代码执行，返回上一层或者已经遍历过都不会打印\r\n\r\n> 1.抓住右序遍历根节点永远在最右边的规律  \r\n> 2.通过右序遍历得到的根节点，在中序遍历中递归寻找整颗数  \r\n> ——————————————————————————————————————————————————  \r\n> 3.通过对右序遍历列表的操作, 保留递归层数位置的数据  \r\n> 退出条件：没有多的数字给找到的根节点做子树  \r\n\r\n> 草稿：  \r\n> 先打印退出条件的数为：  \r\n\r\n> 参考一: https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/426738/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-14/?envType=daily-question&envId=2024-02-21\r\n\r\n```python\r\ndef printTree(root, level=0, prefix=\"Root:\"):\r\n    if root is not None:\r\n        print(\" \" * (level * 4) + prefix, root.val)\r\n        printTree(root.left, level + 1, \"L:\")\r\n        printTree(root.right, level + 1, \"R:\")\r\n\r\nclass Solution:\r\n    def buildTree(self, inorder, postorder) -> TreeNode:\r\n        def helper(in_left, in_right, flag=\"right\"):\r\n            # 如果这里没有节点构造二叉树了，就结束\r\n            if in_left > in_right:\r\n                return None\r\n\r\n            # 选择 post_idx 位置的元素作为当前子树根节点\r\n            val = postorder.pop()\r\n            root = TreeNode(val)\r\n\r\n            # 根据 root 所在位置分成左右两棵子树\r\n            index = idx_map[val]\r\n            print(index)\r\n            print(root.val, in_left, in_right, flag)\r\n\r\n            # 构造右子树\r\n            root.right = helper(index + 1, in_right, \"right\")\r\n            # 构造左子树\r\n            root.left = helper(in_left, index - 1, \"left\")\r\n            return root\r\n\r\n        # 建立（元素，下标）键值对的哈希表\r\n        idx_map = {val: idx for idx, val in enumerate(inorder)}\r\n        return helper(0, len(inorder) - 1)\r\n\r\n\r\ninorder = [-4,-10,3,-1,7,11,-8,2]\r\npostorder = [-4,-1,3,-10,11,-8,2,7]\r\n# inorder = [9, 3, 15, 20, 7]\r\n# postorder = [9, 15, 7, 20, 3]\r\nprintTree(Solution().buildTree(inorder, postorder))\r\n\r\nprint(\"——————————————————————————————————————————————————\")\r\n\r\nclass Solution(object):\r\n    def buildTree(self, inorder, postorder):\r\n        def hRecursion(before, after, postorder, depth, flag=\"right\") -> TreeNode:\r\n            if (len(before) == 0 and len(after) == 0) or len(postorder) == 0:\r\n                return\r\n            root = postorder[-1] \r\n            out = TreeNode(root)\r\n\r\n            rootIndex = inorder.index(root)\r\n            print(root, inorder, rootIndex, postorder)\r\n	      # 后续遍历的最后一个值在中序遍历中的索引带入后续遍历中就是下一个根节点的值\r\n\r\n            after = inorder[rootIndex + 1:]\r\n            before = inorder[0:rootIndex]\r\n\r\n            if root in inorder: inorder.remove(root)\r\n\r\n            out.left = hRecursion(before, [], postorder[:rootIndex], depth, \"left\")\r\n            out.right = hRecursion([], after, postorder[rootIndex : -1], depth + 1, \"right\")\r\n\r\n            return out\r\n        return hRecursion([], inorder, postorder, 0)\r\n\r\n# inorder = [1, 2]\r\n# postorder = [2, 1]\r\n# inorder = [9, 3, 15, 20, 7]\r\n# postorder = [9, 15, 7, 20, 3]\r\n# inorder = [-1]\r\n# postorder = [-1]\r\n# inorder = [1,2,3,4]\r\n# postorder = [1,4,3,2]\r\ninorder = [-4,-10,3,-1,7,11,-8,2]\r\npostorder = [-4,-1,3,-10,11,-8,2,7]\r\nprintTree(Solution().buildTree(inorder, postorder))\r\n\r\nprint(\"————————————————————————输出——————————————————————————\")\r\n\r\n7 [-4, -10, 3, -1, 7, 11, -8, 2] 4 [-4, -1, 3, -10, 11, -8, 2, 7]\r\n-10 [-4, -10, 3, -1, 11, -8, 2] 1 [-4, -1, 3, -10]\r\n-4 [-4, 3, -1, 11, -8, 2] 0 [-4]\r\n3 [3, -1, 11, -8, 2] 0 [-1, 3]\r\n-1 [-1, 11, -8, 2] 0 [-1]\r\n2 [11, -8, 2] 2 [11, -8, 2]\r\n-8 [11, -8] 1 [11, -8]\r\n11 [11] 0 [11]\r\nRoot: 7\r\n    L: -10\r\n        L: -4\r\n        R: 3\r\n            R: -1\r\n    R: 2\r\n        L: -8\r\n            L: 11\r\n```\r\n\r\n> 之前上面的方法无法在递归的时候正确回到相应的层数，因为递归的时候层数没有保留，所以在递归的时候无法正确回到相应的层数  \r\n> 通过参考该方法,利用对右序递归的操作保留层数数据:通过中序和后序遍历的规律来找到正确的下一个根节点，以保留层数数据    \r\n> 抓住不论中序还是后序左节点永远先遍历的特点  \r\n> 参考二: https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/2647794/tu-jie-cong-on2-dao-onpythonjavacgojsrus-w8ny/\r\n\r\n```python\r\nclass Solution:\r\n    def buildTree(self, inorder: List[int], postorder: List[int], depth) -> Optional[TreeNode]:\r\n        if not postorder:  # 空节点\r\n            return None\r\n        left_size = inorder.index(postorder[-1])  # 左子树的大小\r\n        print(depth)\r\n        left = self.buildTree(inorder[:left_size], postorder[:left_size], depth + 1)\r\n        right = self.buildTree(inorder[left_size + 1:], postorder[left_size: -1], depth + 1)\r\n        return TreeNode(postorder[-1], left, right)\r\n\r\ninorder = [-4,-10,3,-1,7,11,-8,2]\r\npostorder = [-4,-1,3,-10,11,-8,2,7]\r\nprintTree(Solution().buildTree(inorder, postorder, 0))\r\n```\r\n', '2025-01-11 11:25:43'),(14, 2, 'LeetCode2312', '## LeetCode2312\r\n图片参考：https://leetcode.cn/problems/selling-pieces-of-wood/solutions/2689164/javapython3cdong-tai-gui-hua-mei-ju-mei-l9bl8/  \r\n代码参考：https://leetcode.cn/problems/selling-pieces-of-wood/solutions/1611240/by-endlesscheng-mrmd/\r\n#### 思路\r\n> 1.从第一步开始推导：切第一刀的最大结果值可能为 1.本身就有x * y的价格 2.横切一刀后最大的价格 3.竖切一刀最大的价格  \r\n> 2.通过累加，从小到大计算出最大结果值。\r\n```python\r\n# 记忆化搜索：使用备忘录避免重复计算来跳过重叠子问题的计算方式\r\nclass Solution:\r\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\r\n        pr = {(x - 1, y - 1): p for x, y, p in prices}\r\n        print(pr)\r\n        f = [[0] * n for _ in range(m)]\r\n        for i in range(m):  # 从小到大计算出最大解，录入f数组（备忘录）\r\n            for j in range(n):\r\n                f[i][j] = max(pr.get((i, j), 0), \r\n                          max((f[k][j] + f[i - 1 - k][j] for k in range(math.ceil((i - 1) / 2) + 1)), \r\n                              default=0),\r\n                          max((f[i][q] + f[i][j - 1 - q] for q in range(math.ceil((j - 1) / 2) + 1)), \r\n                              default=0))\r\n        return f[m - 1][n - 1]\r\n```\r\n', '2025-01-11 11:40:01'),(15, 3, 'Mailserver', '## Mailserver\r\n### 通过docker搭建自己的mailserver需要以下网址\r\n🔥 反向ptr记录需要向ip地址拥有者申请，因为反向记录属于 xx.xx.xx.in-addr.arpa 域名，阿里云IP直接开工单找对话客服，很快可以申请  \r\n- docker-mail搭建示例：https://docker-mailserver.github.io/docker-mailserver/latest/examples  \r\n> 如果没有对域名备案可以使用网站中的cloudflare-dns来申请证书\r\n- dns记录验证：https://ifthenel.se/self-hosted-mail-server/ # 其中DKIM的验证不一定准确，可以在https://dmarcly.com/tools/dkim-record-checker 上查看  \r\n> 如果25端口无法解封可以考虑采取  \r\n> > 为postfix设置relayhost，测试及可用第三方为：https://docs.sendgrid.com/for-developers/sending-email/getting-started-smtp  \r\n> > 设置relayhost及验证方式为：https://www.lunanode.com/guides/postfix_smtp_secure  \r\n- 如果要使用api的方式添加sender, 查看： \r\n> https://docs.sendgrid.com/api-reference/sender-verification/create-verified-sender-request\r\n#### docker-compose示例\r\n```\r\nmailserver:\r\n	image: ghcr.io/docker-mailserver/docker-mailserver:latest\r\n	container_name: mailserver\r\n	# Provide the FQDN of your mail server here (Your DNS MX record should point to this value)\r\n	hostname: mail.hampster.work\r\n	ports:\r\n		- \"25:25\"\r\n		- \"143:143\"\r\n		- \"110:110\"\r\n		- \"465:465\"\r\n		- \"587:587\"\r\n		- \"993:993\"\r\n	volumes:\r\n		- ./docker-data/dms/config/postfix-main.cf:/etc/postfix/main.cf\r\n		- ./docker-data/dms/config/sasl_passwd:/etc/postfix/sasl_passwd\r\n		- ./docker-data/dms/mail-data/:/var/mail/\r\n		- ./docker-data/dms/mail-state/:/var/mail-state/\r\n		- ./docker-data/dms/mail-logs/:/var/log/mail/\r\n		- ./docker-data/dms/config/:/tmp/docker-mailserver/\r\n		- /etc/localtime:/etc/localtime:ro\r\n		- ./docker-data/certbot/certs/:/etc/letsencrypt/:ro\r\n	environment:\r\n		- ENABLE_RSPAMD=1\r\n		- ENABLE_CLAMAV=1\r\n		- ENABLE_FAIL2BAN=1\r\n		- SSL_TYPE=letsencrypt\r\n	cap_add:\r\n		- NET_ADMIN # For Fail2Ban to work\r\n	command: /bin/bash -c \"supervisord -c /etc/supervisor/supervisord.conf & sleep 30 && chmod 600 /etc/postfix/sasl_passwd && postmap /etc/postfix/sasl_passwd && service postfix reload && tail -f /dev/null\"\r\n	# restart: always\r\n	networks:\r\n	- abc\r\n```\r\n#### 注意\r\n如果要通过下一步验证需要打开25端口的映射，添加\r\n```\r\nports:\r\n- \"30:25\" # 25端口受到限制，且检验对象为非SSL端口\r\n- \"143:143\" # +SSL : 993 # IMAP\r\n- \"110:110\" # +SSL : 465 # POP3\r\n```\r\n\r\n### 测试过程（没有申请SSL和域名备案的情况下）\r\n#### smtp测试\r\nhttps://www.cnblogs.com/taoshihan/p/6732039.html\r\n```\r\n[root@hampster config]# telnet localhost 30\r\n...\r\n220 mail.hampster.work ESMTP\r\nHELO mail.hampster.work\r\n250 mail.hampster.work\r\nauth login\r\n334 VXNlcm5hbWU6\r\nXXXXXXXXXXXXXXXXXXXXXX # 账号的base64编码\r\n334 UGFzc3dvcmQ6\r\nXXXXXXXXXXXXXXXXXXXXXX # 密码的base64编码\r\n235 2.7.0 Authentication successful\r\nmail from:<hampster@hampster.work>\r\n250 2.1.0 Ok\r\nrcpt to:<ajh415@hotmail.com>\r\n250 2.1.5 Ok\r\ndata\r\n354 End data with <CR><LF>.<CR><LF>\r\nFrom:<hampster@hampster.work>\r\nTo:<ajh415@hotmail.com>\r\nSubject:ning\r\n\r\nawefawefawef,juisdfo,wfaweyfihgh.awefjaweijf?jwefoiuvbhhsr!!!!\r\nawefjiowefowaif------!!!!!\r\n.\r\n250 2.0.0 Ok: queued as D790522CA3\r\n```\r\n> 如果验证时没有发送出去，可以使用邮件客户端（例如163邮箱大师）登录再发送，就可以成功\r\n\r\n#### imap测试\r\n```\r\n[root@hampster ~]# telnet mail.hampster.work 143\r\nTrying 47.94.167.22...\r\nConnected to mail.hampster.work.\r\nEscape character is \'^]\'.\r\n* OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE LITERAL+ AUTH=PLAIN AUTH=LO\r\na login hampster@hampster.work PASSWORD\r\na OK [CAPABILITY IMAP4rev1 SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED ICH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SNIPPET=FUZZY PREVIEW=FUZZY AL+ NOTIFY SPECIAL-USE QUOTA] Logged in\r\na LIST \"\" \"*\"\r\n* LIST (\\HasNoChildren \\Trash) \".\" Trash\r\n* LIST (\\HasNoChildren \\Sent) \".\" Sent\r\n* LIST (\\HasNoChildren \\Junk) \".\" Junk\r\n* LIST (\\HasNoChildren \\Drafts) \".\" Drafts\r\n* LIST (\\HasNoChildren) \".\" INBOX\r\na OK List completed (0.002 + 0.000 + 0.001 secs).\r\na EXAMINE INBOX\r\n* FLAGS (\\Answered \\Flagged \\Deleted \\Seen \\Draft)\r\n* OK [PERMANENTFLAGS ()] Read-only mailbox.\r\n* 0 EXISTS\r\n* 0 RECENT\r\n* OK [UIDVALIDITY 1709077637] UIDs valid\r\n* OK [UIDNEXT 1] Predicted next UID\r\na OK [READ-ONLY] Examine completed (0.001 + 0.000 secs).\r\n```\r\n', '2025-01-11 11:50:27'),(16, 3, 'Service Discovery', '\r\n## Service Discovery\r\n### Consul\r\n##### yaml配置\r\n```\r\n  consul:\r\n    container_name: consul\r\n    image: hashicorp/consul\r\n    restart: always\r\n    ports:\r\n      - \"31008:8500\"\r\n      - \"31006:8600\"\r\n    volumes:\r\n      - \"./consul/data:/data:rw\"\r\n      - \"./consul/conf:/etc/consul/conf\"\r\n      - \"./consul/values:/etc/consul/values\"\r\n    command: consul agent -server -ui -node server-1 -client \"0.0.0.0\" -data-dir \"/data\" -bind \"127.0.0.1\" -bootstrap-expect 1 -config-file \"/etc/consul/conf/config.json\"\r\n```\r\nhttps://blog.csdn.net/LaoRenYuHai_/article/details/140097560\r\n### Nacos\r\n#### nacos配置中心\r\n##### yaml配置\r\n> official-example: https://github.com/nacos-group/nacos-docker/blob/master/example/standalone-derby.yaml <br/>\r\n> official-description: https://nacos.io/docs/latest/quickstart/quick-start-docker/?spm=5238cd80.c984973.0.0.6be14023CJebBn#nacos--grafana--prometheus\r\n```\r\nnacos:\r\n  image: nacos/nacos-server:latest\r\n  container_name: nacos-standalone\r\n  restart: always\r\n  environment:\r\n    - PREFER_HOST_MODE=HOST\r\n    - MODE=standalone\r\n    - NACOS_AUTH_IDENTITY_KEY=IDENTITY_KEY\r\n    - NACOS_AUTH_IDENTITY_VALUE=IDENTITY_VALUE\r\n    - NACOS_AUTH_TOKEN=TOKEN\r\n#	 - NACOS_AUTH_ENABLE=true\r\n  volumes:\r\n    - ./standalone-logs/:/home/nacos/logs\r\n  ports:\r\n    - \"8848:8848\"\r\n    - \"9848:9848\"\r\nprometheus:\r\n  container_name: prometheus\r\n  image: prom/prometheus:latest\r\n  volumes:\r\n    - ./prometheus/prometheus-standalone.yaml:/etc/prometheus/prometheus.yml\r\n  ports:\r\n    - \"9090:9090\"\r\n  depends_on:\r\n    - nacos\r\n  restart: always\r\ngrafana:\r\n  container_name: grafana\r\n  image: grafana/grafana:latest\r\n  ports:\r\n    - 3000:3000\r\n  restart: always\r\n```\r\n- visit-link：[http://127.0.0.1:8848/nacos/](http://127.0.0.1:8848/nacos/)\r\n\r\n##### post请求添加配置\r\n```\r\nhttp://HOST:8848/nacos/v1/cs/configs?dataId=name-prod.yaml&group=DEFAULT_GROUP&content=useLocalCache: true&type=yaml\r\n```\r\n> 添加后可以在visit-link里面的Configuration-Management -> Configurations中看到\r\n\r\n##### bootstrap配置\r\n```\r\nserver:  \r\n  port: PORT\r\nspring:  \r\n  application:  \r\n    name: name\r\n  cloud:  \r\n      nacos:  \r\n          config:  \r\n            server-addr: host:8848  \r\n            file-extension: yaml  \r\n            group: DEFAULT_GROUP  \r\n#            shared-configs:  \r\n#              - ${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\r\n  profiles:  \r\n    active: prod  \r\n  config:  \r\n    import: nacos:${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}\r\n```\r\n##### SpringCloud测试接口\r\n```\r\nimport org.springframework.beans.factory.annotation.Value;  \r\nimport org.springframework.cloud.context.config.annotation.RefreshScope;  \r\nimport org.springframework.web.bind.annotation.RequestMapping;  \r\nimport org.springframework.web.bind.annotation.RestController;  \r\n  \r\n@RestController  \r\n@RequestMapping(\"/config\")  \r\n@RefreshScope  \r\npublic class ConfigController {  \r\n  \r\n    @Value(\"${useLocalCache:false}\")  \r\n//    @NacosConfig(dataId = \"blog-prod.yaml\", group = \"DEFAULT_GROUP\", key = \"config.useLocalCache\", defaultValue = \"false\")  \r\n  private boolean useLocalCache;  \r\n  \r\n    @RequestMapping(\"/useLocalCache\")  \r\n    public boolean getUseLocalCache() {  \r\n        return useLocalCache;  \r\n    }  \r\n}\r\n```\r\n#### 添加鉴权\r\n> 放入内网后再添加鉴权会让访问更安全\r\n```\r\n# 取消注释yaml文件env里面的\r\n#	 - NACOS_AUTH_ENABLE=true\r\n```\r\n> 此外还可以对访问ip进行限制\r\n```\r\n# 如果经过NAT转发添加到FORWARD,没有直接添加到INPUT\r\niptables -I FORWARD -p tcp --dport 8848 -j DROP        \r\niptables -I FORWARD -p tcp --dport 8848 -s IPALLOW -j ACCEPT\r\n```\r\n> 如果ip会变化则使用类似以下的脚本\r\n```\r\n#!/bin/bash\r\n\r\n# 环境变量\r\nexport PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\r\n\r\n# 配置域名\r\nDOMAIN=\"example.com\"\r\n\r\n# 解析域名到 IP\r\nRESOLVED_IP=$(dig +short $DOMAIN | head -n 1)\r\n\r\nif [ -z \"$RESOLVED_IP\" ]; then\r\n    echo \"Failed to resolve domain: $DOMAIN\"\r\n    exit 1\r\nfi\r\n\r\n# 清除旧规则（如果已存在）\r\niptables -D FORWARD $(iptables -L FORWARD --line-numbers | awk \'$2 == \"ACCEPT\" && $5 ~ /.*compute.amazonaws.com/ && $7 == \"tcp\" && $8 == \"dpt:8848\" {print $1}\')\r\n\r\n# 添加新规则\r\niptables -I FORWARD -p tcp --dport 8848 -s $RESOLVED_IP -j ACCEPT\r\n\r\necho \"Updated iptables rule: Allowed $DOMAIN ($RESOLVED_IP) on port 8848\"\r\n```\r\n\r\n##### 鉴权后的网络请求访问格式\r\n> https://nacos.io/docs/next/manual/user/auth/?spm=5238cd80.23f13fa2.0.0.30a87e148NOIJQ\r\n```\r\n# 首先需要使用用户名和密码登陆nacos。(直接复制到POSTMAN可知-d来自www-form数据)\r\n# 注：www-form用于普通表单数据,data-form用于图片视频（一般表现为multipart/form-data）\r\ncurl -X POST \'127.0.0.1:8848/nacos/v1/auth/login\' -d \'username=nacos&password=nacos\'\r\n# 若用户名和密码正确,返回信息access-token,返回后添加到之前的请求后面:\r\nhttp://HOST:8848/nacos/v1/cs/configs?dataId=name-prod.yaml&group=DEFAULT_GROUP&content=useLocalCache: true&type=yaml&access-token=xxxxxxxxxxxxxxxxxx\r\n```\r\n\r\n#### 服务发现与管理\r\n> to be continued', '2025-01-21 14:31:06');
UNLOCK TABLES;
COMMIT;
BEGIN;
LOCK TABLES `hampster`.`blog_type` WRITE;
DELETE FROM `hampster`.`blog_type`;
INSERT INTO `hampster`.`blog_type` (`bt_id`,`bt_name`) VALUES (1, 'JAVA'),(2, 'PYTHON'),(3, 'CONTAINER');
UNLOCK TABLES;
COMMIT;
BEGIN;
LOCK TABLES `hampster`.`user` WRITE;
DELETE FROM `hampster`.`user`;
INSERT INTO `hampster`.`user` (`u_id`,`u_name`,`u_pass`,`u_mail`,`u_phone`,`u_token`) VALUES (1, 'AbHamster', '$2a$10$eO6TGS6WzWd/MjJygL2VZ.ua52Bbj/sRNyFq.ccGJgyGePu7dDjVK', 'ajh415@hotmail.com', NULL, 'geMZyxvnN8cuthUm'),(2, 'Registered Hamster', '$2a$10$azvhCPgEelnOQgWIco92uOAx3vCaXkFOuv4WP4bu/6CFV1P8ZGxom', 'test', NULL, 'i6TL41yRB0JnwQPM'),(4, 'Registered Hamster', '$2a$10$OedsxBTd4EvruV0vt9ru6e/lwhuVtz/LvwnzBJnzX2iwRZKTF5YXi', '0', NULL, 'kCL4Gu6JRIMXZ0b4'),(5, 'Registered Hamster', '$2a$10$sLMkSabtAW6AK1vjL47Ky.KzgXtNp/O8Dvq.GXHym.TpOZQyUALd6', '1', NULL, '1kXXy9ab3MFBgr9s'),(6, 'Registered Hamster', '$2a$10$FU1RDepo6pBoqeFwcITmYuzNuCby7AZa5YJHq71uJ8gQc0RCsmILO', '2', NULL, 'ECREBptNEPpAesDs'),(7, 'Registered Hamster', '$2a$10$JdWKLkZ3X8bqxgdbtYbSb..pov6/XrPwvmNhqBQq35Kdjo.CHo5s2', '3', NULL, 'jhfUdoHGFw0W2eb4'),(8, 'Registered Hamster', '$2a$10$gOIKoUXFFIAl6MbD3F96RumAMtAKOmplInVIqZOZRZxgWfHdfGU/K', '45', NULL, 'hkajLX7qHZc07XJH'),(9, 'Registered Hamster', '$2a$10$9RBca/Vk5E5nIexzeEBDCuv5dW.PrtkkHpg27vySjWsV2hcVrIdjW', '65', NULL, 'AIkV92uCVqf72dUK'),(10, 'Registered Hamster', '$2a$10$21ps/1//Ai1v0ggMCajl1uRQ/wPXM737eCKyGohdNx6HHFzzPRaFu', '78', NULL, 'hVMwhI6BUAOmJnHt'),(11, 'Registered Hamster', '$2a$10$rtJLZ0euteiEB8bMh/3ZO.fkkfkZPpzn3hnIuvRPrk78oON18tu5.', '99', NULL, 'TIyDX2KCA3XlNhpy'),(12, 'Registered Hamster', '$2a$10$DrA/OKjcJEGJt8bAbpZXDOm0WK7.0q5KizReZBUupx00aGmpAhqlm', '0980', NULL, 'osrBn4jswK72S58n'),(13, 'Registered Hamster', '$2a$10$Ms5fLkc/4wqI.CpYT8uAZO07K4jASZvk1HiNbdmkzzmBCPIY9h7BO', '1000', NULL, 'Wknrje1EqDy8WgSv'),(14, 'uoiuy', '$2a$10$wyXWnkjCnYzx5HD.4Bp2I.8bEuztRbLIeiJUxCf9Geg1N3oUDoDVm', '1001', NULL, 'mM9yDQP8cFxsoJXQ'),(15, 'poipo', '$2a$10$.2pRvpGT367HMojxVlyoI.CDHgBniE9hww8Re9TLKGmPyAVJJ00bq', 'a1270898097@163.com', NULL, 'RTbhjHl2JjXsmMT7');
UNLOCK TABLES;
COMMIT;
